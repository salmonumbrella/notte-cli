// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2PasswordBearerScopes = "OAuth2PasswordBearer.Scopes"
)

// Defines values for AgentStatus.
const (
	AgentStatusActive AgentStatus = "active"
	AgentStatusClosed AgentStatus = "closed"
)

// Defines values for ApiSessionStartRequestBrowserType.
const (
	ApiSessionStartRequestBrowserTypeChrome        ApiSessionStartRequestBrowserType = "chrome"
	ApiSessionStartRequestBrowserTypeChromeNightly ApiSessionStartRequestBrowserType = "chrome-nightly"
	ApiSessionStartRequestBrowserTypeChromeTurbo   ApiSessionStartRequestBrowserType = "chrome-turbo"
	ApiSessionStartRequestBrowserTypeChromium      ApiSessionStartRequestBrowserType = "chromium"
	ApiSessionStartRequestBrowserTypeFirefox       ApiSessionStartRequestBrowserType = "firefox"
)

// Defines values for ApiSessionStartRequestScreenshotType.
const (
	ApiSessionStartRequestScreenshotTypeFull       ApiSessionStartRequestScreenshotType = "full"
	ApiSessionStartRequestScreenshotTypeLastAction ApiSessionStartRequestScreenshotType = "last_action"
	ApiSessionStartRequestScreenshotTypeRaw        ApiSessionStartRequestScreenshotType = "raw"
)

// Defines values for DeleteCredentialsResponseStatus.
const (
	DeleteCredentialsResponseStatusFailure DeleteCredentialsResponseStatus = "failure"
	DeleteCredentialsResponseStatusSuccess DeleteCredentialsResponseStatus = "success"
)

// Defines values for DeleteCreditCardResponseStatus.
const (
	DeleteCreditCardResponseStatusFailure DeleteCreditCardResponseStatus = "failure"
	DeleteCreditCardResponseStatusSuccess DeleteCreditCardResponseStatus = "success"
)

// Defines values for DeleteFunctionResponseStatus.
const (
	DeleteFunctionResponseStatusFailure DeleteFunctionResponseStatus = "failure"
	DeleteFunctionResponseStatusSuccess DeleteFunctionResponseStatus = "success"
)

// Defines values for DeletePersonaResponseStatus.
const (
	DeletePersonaResponseStatusFailure DeletePersonaResponseStatus = "failure"
	DeletePersonaResponseStatusSuccess DeletePersonaResponseStatus = "success"
)

// Defines values for DeletePhoneNumberResponseStatus.
const (
	DeletePhoneNumberResponseStatusFailure DeletePhoneNumberResponseStatus = "failure"
	DeletePhoneNumberResponseStatusSuccess DeletePhoneNumberResponseStatus = "success"
)

// Defines values for DeleteVaultResponseStatus.
const (
	DeleteVaultResponseStatusFailure DeleteVaultResponseStatus = "failure"
	DeleteVaultResponseStatusSuccess DeleteVaultResponseStatus = "success"
)

// Defines values for FunctionRunUpdateRequestStatus.
const (
	FunctionRunUpdateRequestStatusActive FunctionRunUpdateRequestStatus = "active"
	FunctionRunUpdateRequestStatusClosed FunctionRunUpdateRequestStatus = "closed"
	FunctionRunUpdateRequestStatusFailed FunctionRunUpdateRequestStatus = "failed"
)

// Defines values for GetFunctionRunResponseStatus.
const (
	GetFunctionRunResponseStatusActive GetFunctionRunResponseStatus = "active"
	GetFunctionRunResponseStatusClosed GetFunctionRunResponseStatus = "closed"
	GetFunctionRunResponseStatusFailed GetFunctionRunResponseStatus = "failed"
)

// Defines values for GlobalScrapeRequestBrowserType.
const (
	GlobalScrapeRequestBrowserTypeChrome        GlobalScrapeRequestBrowserType = "chrome"
	GlobalScrapeRequestBrowserTypeChromeNightly GlobalScrapeRequestBrowserType = "chrome-nightly"
	GlobalScrapeRequestBrowserTypeChromeTurbo   GlobalScrapeRequestBrowserType = "chrome-turbo"
	GlobalScrapeRequestBrowserTypeChromium      GlobalScrapeRequestBrowserType = "chromium"
	GlobalScrapeRequestBrowserTypeFirefox       GlobalScrapeRequestBrowserType = "firefox"
)

// Defines values for GlobalScrapeRequestScreenshotType.
const (
	GlobalScrapeRequestScreenshotTypeFull       GlobalScrapeRequestScreenshotType = "full"
	GlobalScrapeRequestScreenshotTypeLastAction GlobalScrapeRequestScreenshotType = "last_action"
	GlobalScrapeRequestScreenshotTypeRaw        GlobalScrapeRequestScreenshotType = "raw"
)

// Defines values for ImageCategory.
const (
	ContentImage ImageCategory = "content_image"
	Decorative   ImageCategory = "decorative"
	Favicon      ImageCategory = "favicon"
	Icon         ImageCategory = "icon"
	SvgContent   ImageCategory = "svg_content"
	SvgIcon      ImageCategory = "svg_icon"
)

// Defines values for LlmModel.
const (
	AnthropicclaudeSonnet4520250929            LlmModel = "anthropic/claude-sonnet-4-5-20250929"
	Cerebrasllama3370b                         LlmModel = "cerebras/llama-3.3-70b"
	DeepseekdeepseekR1                         LlmModel = "deepseek/deepseek-r1"
	Geminigemini20Flash                        LlmModel = "gemini/gemini-2.0-flash"
	Groqllama3370bVersatile                    LlmModel = "groq/llama-3.3-70b-versatile"
	Openaigpt4o                                LlmModel = "openai/gpt-4o"
	Openroutergooglegemma327bIt                LlmModel = "openrouter/google/gemma-3-27b-it"
	PerplexitysonarPro                         LlmModel = "perplexity/sonar-pro"
	TogetherAimetaLlamaLlama3370BInstructTurbo LlmModel = "together_ai/meta-llama/Llama-3.3-70B-Instruct-Turbo"
	VertexAigemini20Flash                      LlmModel = "vertex_ai/gemini-2.0-flash"
	VertexAigemini25Flash                      LlmModel = "vertex_ai/gemini-2.5-flash"
)

// Defines values for NetworkLogFileType.
const (
	Request  NetworkLogFileType = "request"
	Response NetworkLogFileType = "response"
)

// Defines values for ProxyGeolocationCountry.
const (
	Ad ProxyGeolocationCountry = "ad"
	Ae ProxyGeolocationCountry = "ae"
	Af ProxyGeolocationCountry = "af"
	Ag ProxyGeolocationCountry = "ag"
	Ai ProxyGeolocationCountry = "ai"
	Al ProxyGeolocationCountry = "al"
	Am ProxyGeolocationCountry = "am"
	Ao ProxyGeolocationCountry = "ao"
	Ar ProxyGeolocationCountry = "ar"
	At ProxyGeolocationCountry = "at"
	Au ProxyGeolocationCountry = "au"
	Aw ProxyGeolocationCountry = "aw"
	Az ProxyGeolocationCountry = "az"
	Ba ProxyGeolocationCountry = "ba"
	Bb ProxyGeolocationCountry = "bb"
	Bd ProxyGeolocationCountry = "bd"
	Be ProxyGeolocationCountry = "be"
	Bf ProxyGeolocationCountry = "bf"
	Bg ProxyGeolocationCountry = "bg"
	Bh ProxyGeolocationCountry = "bh"
	Bi ProxyGeolocationCountry = "bi"
	Bj ProxyGeolocationCountry = "bj"
	Bm ProxyGeolocationCountry = "bm"
	Bn ProxyGeolocationCountry = "bn"
	Bo ProxyGeolocationCountry = "bo"
	Bq ProxyGeolocationCountry = "bq"
	Br ProxyGeolocationCountry = "br"
	Bs ProxyGeolocationCountry = "bs"
	Bt ProxyGeolocationCountry = "bt"
	Bw ProxyGeolocationCountry = "bw"
	By ProxyGeolocationCountry = "by"
	Bz ProxyGeolocationCountry = "bz"
	Ca ProxyGeolocationCountry = "ca"
	Cd ProxyGeolocationCountry = "cd"
	Cg ProxyGeolocationCountry = "cg"
	Ch ProxyGeolocationCountry = "ch"
	Ci ProxyGeolocationCountry = "ci"
	Cl ProxyGeolocationCountry = "cl"
	Cm ProxyGeolocationCountry = "cm"
	Cn ProxyGeolocationCountry = "cn"
	Co ProxyGeolocationCountry = "co"
	Cr ProxyGeolocationCountry = "cr"
	Cu ProxyGeolocationCountry = "cu"
	Cv ProxyGeolocationCountry = "cv"
	Cw ProxyGeolocationCountry = "cw"
	Cy ProxyGeolocationCountry = "cy"
	Cz ProxyGeolocationCountry = "cz"
	De ProxyGeolocationCountry = "de"
	Dj ProxyGeolocationCountry = "dj"
	Dk ProxyGeolocationCountry = "dk"
	Dm ProxyGeolocationCountry = "dm"
	Do ProxyGeolocationCountry = "do"
	Dz ProxyGeolocationCountry = "dz"
	Ec ProxyGeolocationCountry = "ec"
	Ee ProxyGeolocationCountry = "ee"
	Eg ProxyGeolocationCountry = "eg"
	Es ProxyGeolocationCountry = "es"
	Et ProxyGeolocationCountry = "et"
	Fi ProxyGeolocationCountry = "fi"
	Fj ProxyGeolocationCountry = "fj"
	Fr ProxyGeolocationCountry = "fr"
	Ga ProxyGeolocationCountry = "ga"
	Gb ProxyGeolocationCountry = "gb"
	Gd ProxyGeolocationCountry = "gd"
	Ge ProxyGeolocationCountry = "ge"
	Gf ProxyGeolocationCountry = "gf"
	Gg ProxyGeolocationCountry = "gg"
	Gh ProxyGeolocationCountry = "gh"
	Gi ProxyGeolocationCountry = "gi"
	Gm ProxyGeolocationCountry = "gm"
	Gn ProxyGeolocationCountry = "gn"
	Gp ProxyGeolocationCountry = "gp"
	Gq ProxyGeolocationCountry = "gq"
	Gr ProxyGeolocationCountry = "gr"
	Gt ProxyGeolocationCountry = "gt"
	Gu ProxyGeolocationCountry = "gu"
	Gw ProxyGeolocationCountry = "gw"
	Gy ProxyGeolocationCountry = "gy"
	Hk ProxyGeolocationCountry = "hk"
	Hn ProxyGeolocationCountry = "hn"
	Hr ProxyGeolocationCountry = "hr"
	Ht ProxyGeolocationCountry = "ht"
	Hu ProxyGeolocationCountry = "hu"
	Id ProxyGeolocationCountry = "id"
	Ie ProxyGeolocationCountry = "ie"
	Il ProxyGeolocationCountry = "il"
	Im ProxyGeolocationCountry = "im"
	In ProxyGeolocationCountry = "in"
	Iq ProxyGeolocationCountry = "iq"
	Ir ProxyGeolocationCountry = "ir"
	Is ProxyGeolocationCountry = "is"
	It ProxyGeolocationCountry = "it"
	Je ProxyGeolocationCountry = "je"
	Jm ProxyGeolocationCountry = "jm"
	Jo ProxyGeolocationCountry = "jo"
	Jp ProxyGeolocationCountry = "jp"
	Ke ProxyGeolocationCountry = "ke"
	Kg ProxyGeolocationCountry = "kg"
	Kh ProxyGeolocationCountry = "kh"
	Kn ProxyGeolocationCountry = "kn"
	Kr ProxyGeolocationCountry = "kr"
	Kw ProxyGeolocationCountry = "kw"
	Ky ProxyGeolocationCountry = "ky"
	Kz ProxyGeolocationCountry = "kz"
	La ProxyGeolocationCountry = "la"
	Lb ProxyGeolocationCountry = "lb"
	Lc ProxyGeolocationCountry = "lc"
	Lk ProxyGeolocationCountry = "lk"
	Lr ProxyGeolocationCountry = "lr"
	Ls ProxyGeolocationCountry = "ls"
	Lt ProxyGeolocationCountry = "lt"
	Lu ProxyGeolocationCountry = "lu"
	Lv ProxyGeolocationCountry = "lv"
	Ly ProxyGeolocationCountry = "ly"
	Ma ProxyGeolocationCountry = "ma"
	Md ProxyGeolocationCountry = "md"
	Me ProxyGeolocationCountry = "me"
	Mf ProxyGeolocationCountry = "mf"
	Mg ProxyGeolocationCountry = "mg"
	Mk ProxyGeolocationCountry = "mk"
	Ml ProxyGeolocationCountry = "ml"
	Mm ProxyGeolocationCountry = "mm"
	Mn ProxyGeolocationCountry = "mn"
	Mo ProxyGeolocationCountry = "mo"
	Mq ProxyGeolocationCountry = "mq"
	Mr ProxyGeolocationCountry = "mr"
	Mt ProxyGeolocationCountry = "mt"
	Mu ProxyGeolocationCountry = "mu"
	Mv ProxyGeolocationCountry = "mv"
	Mw ProxyGeolocationCountry = "mw"
	Mx ProxyGeolocationCountry = "mx"
	My ProxyGeolocationCountry = "my"
	Mz ProxyGeolocationCountry = "mz"
	Na ProxyGeolocationCountry = "na"
	Nc ProxyGeolocationCountry = "nc"
	Ne ProxyGeolocationCountry = "ne"
	Ng ProxyGeolocationCountry = "ng"
	Ni ProxyGeolocationCountry = "ni"
	Nl ProxyGeolocationCountry = "nl"
	No ProxyGeolocationCountry = "no"
	Np ProxyGeolocationCountry = "np"
	Nz ProxyGeolocationCountry = "nz"
	Om ProxyGeolocationCountry = "om"
	Pa ProxyGeolocationCountry = "pa"
	Pe ProxyGeolocationCountry = "pe"
	Pf ProxyGeolocationCountry = "pf"
	Pg ProxyGeolocationCountry = "pg"
	Ph ProxyGeolocationCountry = "ph"
	Pk ProxyGeolocationCountry = "pk"
	Pl ProxyGeolocationCountry = "pl"
	Pr ProxyGeolocationCountry = "pr"
	Ps ProxyGeolocationCountry = "ps"
	Pt ProxyGeolocationCountry = "pt"
	Py ProxyGeolocationCountry = "py"
	Qa ProxyGeolocationCountry = "qa"
	Re ProxyGeolocationCountry = "re"
	Ro ProxyGeolocationCountry = "ro"
	Rs ProxyGeolocationCountry = "rs"
	Ru ProxyGeolocationCountry = "ru"
	Rw ProxyGeolocationCountry = "rw"
	Sa ProxyGeolocationCountry = "sa"
	Sc ProxyGeolocationCountry = "sc"
	Sd ProxyGeolocationCountry = "sd"
	Se ProxyGeolocationCountry = "se"
	Sg ProxyGeolocationCountry = "sg"
	Si ProxyGeolocationCountry = "si"
	Sk ProxyGeolocationCountry = "sk"
	Sl ProxyGeolocationCountry = "sl"
	Sm ProxyGeolocationCountry = "sm"
	Sn ProxyGeolocationCountry = "sn"
	So ProxyGeolocationCountry = "so"
	Sr ProxyGeolocationCountry = "sr"
	Ss ProxyGeolocationCountry = "ss"
	St ProxyGeolocationCountry = "st"
	Sv ProxyGeolocationCountry = "sv"
	Sx ProxyGeolocationCountry = "sx"
	Sy ProxyGeolocationCountry = "sy"
	Sz ProxyGeolocationCountry = "sz"
	Tc ProxyGeolocationCountry = "tc"
	Tg ProxyGeolocationCountry = "tg"
	Th ProxyGeolocationCountry = "th"
	Tj ProxyGeolocationCountry = "tj"
	Tm ProxyGeolocationCountry = "tm"
	Tn ProxyGeolocationCountry = "tn"
	Tr ProxyGeolocationCountry = "tr"
	Tt ProxyGeolocationCountry = "tt"
	Tw ProxyGeolocationCountry = "tw"
	Tz ProxyGeolocationCountry = "tz"
	Ua ProxyGeolocationCountry = "ua"
	Ug ProxyGeolocationCountry = "ug"
	Us ProxyGeolocationCountry = "us"
	Uy ProxyGeolocationCountry = "uy"
	Uz ProxyGeolocationCountry = "uz"
	Vc ProxyGeolocationCountry = "vc"
	Ve ProxyGeolocationCountry = "ve"
	Vg ProxyGeolocationCountry = "vg"
	Vi ProxyGeolocationCountry = "vi"
	Vn ProxyGeolocationCountry = "vn"
	Ye ProxyGeolocationCountry = "ye"
	Za ProxyGeolocationCountry = "za"
	Zm ProxyGeolocationCountry = "zm"
	Zw ProxyGeolocationCountry = "zw"
)

// Defines values for SessionResponseBrowserType.
const (
	Chrome        SessionResponseBrowserType = "chrome"
	ChromeNightly SessionResponseBrowserType = "chrome-nightly"
	ChromeTurbo   SessionResponseBrowserType = "chrome-turbo"
	Chromium      SessionResponseBrowserType = "chromium"
	Firefox       SessionResponseBrowserType = "firefox"
)

// Defines values for SessionResponseStatus.
const (
	SessionResponseStatusActive   SessionResponseStatus = "active"
	SessionResponseStatusClosed   SessionResponseStatus = "closed"
	SessionResponseStatusError    SessionResponseStatus = "error"
	SessionResponseStatusTimedOut SessionResponseStatus = "timed_out"
)

// Defines values for SpaceCategory.
const (
	Auth          SpaceCategory = "auth"
	Captcha       SpaceCategory = "captcha"
	DataFeed      SpaceCategory = "data-feed"
	Form          SpaceCategory = "form"
	Homepage      SpaceCategory = "homepage"
	Item          SpaceCategory = "item"
	ManageCookies SpaceCategory = "manage-cookies"
	Other         SpaceCategory = "other"
	Overlay       SpaceCategory = "overlay"
	Payment       SpaceCategory = "payment"
	SearchResults SpaceCategory = "search-results"
)

// Defines values for SubscriptionType.
const (
	Admin      SubscriptionType = "admin"
	Free       SubscriptionType = "free"
	Growth     SubscriptionType = "growth"
	Interview  SubscriptionType = "interview"
	Minoan     SubscriptionType = "minoan"
	Playground SubscriptionType = "playground"
	Pro        SubscriptionType = "pro"
	Proofs     SubscriptionType = "proofs"
)

// Defines values for UpdateFunctionRunResponseStatus.
const (
	Stopped UpdateFunctionRunResponseStatus = "stopped"
	Updated UpdateFunctionRunResponseStatus = "updated"
)

// ActionParameter defines model for ActionParameter.
type ActionParameter struct {
	Default *string   `json:"default"`
	Name    string    `json:"name"`
	Type    string    `json:"type"`
	Values  *[]string `json:"values,omitempty"`
}

// ActionSpace defines model for ActionSpace.
type ActionSpace struct {
	Actions        *[]ActionSpace_Actions_Item        `json:"actions,omitempty"`
	BrowserActions *[]ActionSpace_BrowserActions_Item `json:"browser_actions,omitempty"`

	// Category Category of the action space (e.g., 'homepage', 'search-results', 'item')
	Category interface{} `json:"category"`

	// Description Human-readable description of the current web page
	Description string `json:"description"`

	// InteractionActions List of available interaction actions in the current state
	InteractionActions []ActionSpace_InteractionActions_Item `json:"interaction_actions"`
	Markdown           *string                               `json:"markdown,omitempty"`
}

// ActionSpace_Actions_Item defines model for ActionSpace.actions.Item.
type ActionSpace_Actions_Item struct {
	union json.RawMessage
}

// ActionSpace_BrowserActions_Item defines model for ActionSpace.browser_actions.Item.
type ActionSpace_BrowserActions_Item struct {
	union json.RawMessage
}

// ActionSpace_InteractionActions_Item defines model for ActionSpace.interaction_actions.Item.
type ActionSpace_InteractionActions_Item struct {
	union json.RawMessage
}

// AddCredentialsRequest defines model for AddCredentialsRequest.
type AddCredentialsRequest struct {
	Credentials CredentialsDictInput `json:"credentials"`
	Url         string               `json:"url"`
}

// AddCredentialsResponse defines model for AddCredentialsResponse.
type AddCredentialsResponse struct {
	// Status Status of the created credentials
	Status string `json:"status"`
}

// AddCreditCardRequest defines model for AddCreditCardRequest.
type AddCreditCardRequest struct {
	CreditCard CreditCardDictInput `json:"credit_card"`
}

// AddCreditCardResponse defines model for AddCreditCardResponse.
type AddCreditCardResponse struct {
	// Status Status of the created credit card
	Status string `json:"status"`
}

// AgentFunctionCodeResponse defines model for AgentFunctionCodeResponse.
type AgentFunctionCodeResponse struct {
	// JsonActions Json actions to replicate agent steps
	JsonActions []map[string]interface{} `json:"json_actions"`

	// PythonScript Python script to replicate agent steps
	PythonScript string `json:"python_script"`
}

// AgentResponse defines model for AgentResponse.
type AgentResponse struct {
	// AgentId The ID of the agent
	AgentId string `json:"agent_id"`

	// ClosedAt The closing time of the agent
	ClosedAt *string `json:"closed_at"`

	// CreatedAt The creation time of the agent
	CreatedAt time.Time `json:"created_at"`

	// CreditUsage Credit usage for the agent. None if the agent is still running
	CreditUsage *float32 `json:"credit_usage"`

	// Saved Whether the agent is saved as a workflow
	Saved *bool `json:"saved,omitempty"`

	// SessionId The ID of the session
	SessionId string      `json:"session_id"`
	Status    AgentStatus `json:"status"`
}

// AgentStatus defines model for AgentStatus.
type AgentStatus string

// AgentStatusResponse defines model for AgentStatusResponse.
type AgentStatusResponse struct {
	// AgentId The ID of the agent
	AgentId string `json:"agent_id"`

	// Answer The answer to the agent task. None if the agent is still running
	Answer *string `json:"answer"`

	// ClosedAt The closing time of the agent
	ClosedAt *string `json:"closed_at"`

	// CreatedAt The creation time of the agent
	CreatedAt time.Time `json:"created_at"`

	// CreditUsage Credit usage for the agent. None if the agent is still running
	CreditUsage *float32 `json:"credit_usage"`

	// Replay The session replay in `.webp` format
	Replay *string `json:"replay"`

	// ReplayStartOffset The start offset of the replay
	ReplayStartOffset int `json:"replay_start_offset"`

	// ReplayStopOffset The stop offset of the replay
	ReplayStopOffset int `json:"replay_stop_offset"`

	// Saved Whether the agent is saved as a workflow
	Saved *bool `json:"saved,omitempty"`

	// SessionId The ID of the session
	SessionId string      `json:"session_id"`
	Status    AgentStatus `json:"status"`

	// Steps The steps that the agent has currently taken
	Steps *[]map[string]interface{} `json:"steps,omitempty"`

	// Success Whether the agent task was successful. None if the agent is still running
	Success *bool `json:"success"`

	// Task The task that the agent is currently running
	Task string `json:"task"`

	// Url The URL that the agent started on
	Url *string `json:"url"`
}

// ApiAgentStartRequest defines model for ApiAgentStartRequest.
type ApiAgentStartRequest struct {
	// MaxSteps The maximum number of steps the agent should take
	MaxSteps *int `json:"max_steps,omitempty"`

	// NotifierConfig Config used for the notifier
	NotifierConfig *map[string]interface{} `json:"notifier_config"`

	// PersonaId The persona to use for the agent
	PersonaId *string `json:"persona_id"`

	// ReasoningModel The reasoning model to use
	ReasoningModel *ApiAgentStartRequest_ReasoningModel `json:"reasoning_model,omitempty"`

	// ResponseFormat The response format to use for the agent answer. You can use a Pydantic model or a JSON Schema dict (cf. https://docs.pydantic.dev/latest/concepts/json_schema/#generating-json-schema.)
	ResponseFormat interface{} `json:"response_format"`

	// SessionId The ID of the session to run the agent on
	SessionId string `json:"session_id"`

	// SessionOffset [Experimental] The step from which the agent should gather information from in the session. If none, fresh memory
	SessionOffset *int `json:"session_offset"`

	// Task The task that the agent should perform
	Task string `json:"task"`

	// Url The URL that the agent should start on (optional)
	Url *string `json:"url"`

	// UseVision Whether to use vision for the agent. Not all reasoning models support vision.
	UseVision *bool `json:"use_vision,omitempty"`

	// VaultId The vault to use for the agent
	VaultId *string `json:"vault_id"`
}

// ApiAgentStartRequestReasoningModel1 defines model for .
type ApiAgentStartRequestReasoningModel1 = string

// ApiAgentStartRequest_ReasoningModel The reasoning model to use
type ApiAgentStartRequest_ReasoningModel struct {
	union json.RawMessage
}

// ApiExecutionResponse defines model for ApiExecutionResponse.
type ApiExecutionResponse struct {
	Action    ApiExecutionResponse_Action `json:"action"`
	Data      interface{}                 `json:"data"`
	Exception *string                     `json:"exception"`
	Message   string                      `json:"message"`
	Session   SessionResponse             `json:"session"`
	Success   bool                        `json:"success"`
}

// ApiExecutionResponse_Action defines model for ApiExecutionResponse.Action.
type ApiExecutionResponse_Action struct {
	union json.RawMessage
}

// ApiSessionStartRequest defines model for ApiSessionStartRequest.
type ApiSessionStartRequest struct {
	// BrowserType The browser type to use. Can be chromium, chrome or firefox.
	BrowserType *ApiSessionStartRequestBrowserType `json:"browser_type,omitempty"`

	// CdpUrl The CDP URL of another remote session provider.
	CdpUrl *string `json:"cdp_url"`

	// ChromeArgs Overwrite the chrome instance arguments
	ChromeArgs *[]interface{} `json:"chrome_args"`

	// Headless Whether to run the session in headless mode.
	Headless *bool `json:"headless,omitempty"`

	// IdleTimeoutMinutes Idle timeout in minutes. Session closes after this period of inactivity (resets on each operation).
	IdleTimeoutMinutes *int `json:"idle_timeout_minutes,omitempty"`

	// MaxDurationMinutes Maximum session lifetime in minutes (absolute maximum, not affected by activity).
	MaxDurationMinutes *int `json:"max_duration_minutes,omitempty"`

	// Profile Browser profile configuration for state persistence
	Profile interface{} `json:"profile"`

	// Proxies List of custom proxies to use for the session. If True, the default proxies will be used.
	Proxies *ApiSessionStartRequest_Proxies `json:"proxies,omitempty"`

	// ScreenshotType The type of screenshot to use for the session.
	ScreenshotType *ApiSessionStartRequestScreenshotType `json:"screenshot_type,omitempty"`

	// SolveCaptchas Whether to try to automatically solve captchas
	SolveCaptchas *bool `json:"solve_captchas,omitempty"`

	// UseFileStorage Whether FileStorage should be attached to the session.
	UseFileStorage *bool `json:"use_file_storage,omitempty"`

	// UserAgent The user agent to use for the session
	UserAgent *string `json:"user_agent"`

	// ViewportHeight The height of the viewport
	ViewportHeight *int `json:"viewport_height"`

	// ViewportWidth The width of the viewport
	ViewportWidth *int `json:"viewport_width"`
}

// ApiSessionStartRequestBrowserType The browser type to use. Can be chromium, chrome or firefox.
type ApiSessionStartRequestBrowserType string

// ApiSessionStartRequestProxies0 defines model for .
type ApiSessionStartRequestProxies0 = []ApiSessionStartRequest_Proxies_0_Item

// ApiSessionStartRequest_Proxies_0_Item defines model for ApiSessionStartRequest.Proxies.0.Item.
type ApiSessionStartRequest_Proxies_0_Item struct {
	union json.RawMessage
}

// ApiSessionStartRequestProxies1 defines model for .
type ApiSessionStartRequestProxies1 = bool

// ApiSessionStartRequest_Proxies List of custom proxies to use for the session. If True, the default proxies will be used.
type ApiSessionStartRequest_Proxies struct {
	union json.RawMessage
}

// ApiSessionStartRequestScreenshotType The type of screenshot to use for the session.
type ApiSessionStartRequestScreenshotType string

// BaseModel defines model for BaseModel.
type BaseModel = map[string]interface{}

// BodyFileUploadDownloadedFileStorageSessionIdDownloadsFilenamePost defines model for Body_file_upload_downloaded_file_storage__session_id__downloads__filename__post.
type BodyFileUploadDownloadedFileStorageSessionIdDownloadsFilenamePost struct {
	File openapi_types.File `json:"file"`
}

// BodyFileUploadStorageUploadsFilenamePost defines model for Body_file_upload_storage_uploads__filename__post.
type BodyFileUploadStorageUploadsFilenamePost struct {
	File openapi_types.File `json:"file"`
}

// BodyFunctionCreateFunctionsPost defines model for Body_function_create_functions_post.
type BodyFunctionCreateFunctionsPost struct {
	Description *string            `json:"description"`
	File        openapi_types.File `json:"file"`
	Name        *string            `json:"name"`
	Shared      *bool              `json:"shared,omitempty"`
}

// BodyFunctionUpdateFunctionsFunctionIdPost defines model for Body_function_update_functions__function_id__post.
type BodyFunctionUpdateFunctionsFunctionIdPost struct {
	File openapi_types.File `json:"file"`
}

// BodySessionCookiesSetSessionsSessionIdCookiesPost defines model for Body_session_cookies_set_sessions__session_id__cookies_post.
type BodySessionCookiesSetSessionsSessionIdCookiesPost struct {
	Cookies []Cookie `json:"cookies"`
}

// BoundingBox defines model for BoundingBox.
type BoundingBox struct {
	Height         float32  `json:"height"`
	IframeOffsetX  *float32 `json:"iframe_offset_x,omitempty"`
	IframeOffsetY  *float32 `json:"iframe_offset_y,omitempty"`
	NotteId        *string  `json:"notte_id"`
	ScrollX        float32  `json:"scroll_x"`
	ScrollY        float32  `json:"scroll_y"`
	ViewportHeight float32  `json:"viewport_height"`
	ViewportWidth  float32  `json:"viewport_width"`
	Width          float32  `json:"width"`
	X              float32  `json:"x"`
	Y              float32  `json:"y"`
}

// CaptchaSolveAction defines model for CaptchaSolveAction.
type CaptchaSolveAction struct {
	CaptchaType *string `json:"captcha_type"`
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// CheckActionInput defines model for CheckAction-Input.
type CheckActionInput struct {
	Category    *string                    `json:"category,omitempty"`
	Description *string                    `json:"description,omitempty"`
	Id          *string                    `json:"id,omitempty"`
	Param       interface{}                `json:"param"`
	PressEnter  *bool                      `json:"press_enter"`
	Selector    *CheckActionInput_Selector `json:"selector"`
	TextLabel   *string                    `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int    `json:"timeout,omitempty"`
	Type    *string `json:"type,omitempty"`
	Value   bool    `json:"value"`
}

// CheckActionInputSelector0 defines model for .
type CheckActionInputSelector0 = string

// CheckActionInput_Selector defines model for CheckActionInput.Selector.
type CheckActionInput_Selector struct {
	union json.RawMessage
}

// CheckActionOutput defines model for CheckAction-Output.
type CheckActionOutput struct {
	Category    *string                     `json:"category,omitempty"`
	Description *string                     `json:"description,omitempty"`
	Id          *string                     `json:"id,omitempty"`
	PressEnter  *bool                       `json:"press_enter"`
	Selector    *CheckActionOutput_Selector `json:"selector"`
	TextLabel   *string                     `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int    `json:"timeout,omitempty"`
	Type    *string `json:"type,omitempty"`
	Value   bool    `json:"value"`
}

// CheckActionOutputSelector0 defines model for .
type CheckActionOutputSelector0 = string

// CheckActionOutput_Selector defines model for CheckActionOutput.Selector.
type CheckActionOutput_Selector struct {
	union json.RawMessage
}

// ClickActionInput defines model for ClickAction-Input.
type ClickActionInput struct {
	Category    *string                    `json:"category,omitempty"`
	Description *string                    `json:"description,omitempty"`
	Id          *string                    `json:"id,omitempty"`
	Param       interface{}                `json:"param"`
	PressEnter  *bool                      `json:"press_enter"`
	Selector    *ClickActionInput_Selector `json:"selector"`
	TextLabel   *string                    `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int    `json:"timeout,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// ClickActionInputSelector0 defines model for .
type ClickActionInputSelector0 = string

// ClickActionInput_Selector defines model for ClickActionInput.Selector.
type ClickActionInput_Selector struct {
	union json.RawMessage
}

// ClickActionOutput defines model for ClickAction-Output.
type ClickActionOutput struct {
	Category    *string                     `json:"category,omitempty"`
	Description *string                     `json:"description,omitempty"`
	Id          *string                     `json:"id,omitempty"`
	PressEnter  *bool                       `json:"press_enter"`
	Selector    *ClickActionOutput_Selector `json:"selector"`
	TextLabel   *string                     `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int    `json:"timeout,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// ClickActionOutputSelector0 defines model for .
type ClickActionOutputSelector0 = string

// ClickActionOutput_Selector defines model for ClickActionOutput.Selector.
type ClickActionOutput_Selector struct {
	union json.RawMessage
}

// CloseTabAction defines model for CloseTabAction.
type CloseTabAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// CompletionAction defines model for CompletionAction.
type CompletionAction struct {
	Answer      string  `json:"answer"`
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Success     bool    `json:"success"`
	Type        *string `json:"type,omitempty"`
}

// Cookie defines model for Cookie.
type Cookie struct {
	Domain         string   `json:"domain"`
	ExpirationDate *float32 `json:"expirationDate"`
	Expires        *float32 `json:"expires"`
	HostOnly       *bool    `json:"hostOnly"`
	HttpOnly       bool     `json:"httpOnly"`
	Name           string   `json:"name"`
	Path           string   `json:"path"`
	SameSite       *string  `json:"sameSite"`
	Secure         *bool    `json:"secure"`
	Session        *bool    `json:"session"`
	StoreId        *string  `json:"storeId"`
	Value          string   `json:"value"`
}

// CreatePhoneNumberResponse defines model for CreatePhoneNumberResponse.
type CreatePhoneNumberResponse struct {
	// PhoneNumber The phone number that was created
	PhoneNumber string `json:"phone_number"`

	// Status Status of the created virtual number
	Status string `json:"status"`
}

// Credential defines model for Credential.
type Credential struct {
	Email    *string `json:"email"`
	Url      string  `json:"url"`
	Username *string `json:"username"`
}

// CredentialsDictInput defines model for CredentialsDict-Input.
type CredentialsDictInput struct {
	Email     *string `json:"email,omitempty"`
	MfaSecret *string `json:"mfa_secret,omitempty"`
	Password  string  `json:"password"`
	Username  *string `json:"username,omitempty"`
}

// CredentialsDictOutput defines model for CredentialsDict-Output.
type CredentialsDictOutput struct {
	Email     *string `json:"email,omitempty"`
	MfaSecret *string `json:"mfa_secret,omitempty"`
	Password  string  `json:"password"`
	Username  *string `json:"username,omitempty"`
}

// CreditCardDictInput defines model for CreditCardDict-Input.
type CreditCardDictInput struct {
	CardCvv            string `json:"card_cvv"`
	CardFullExpiration string `json:"card_full_expiration"`
	CardHolderName     string `json:"card_holder_name"`
	CardNumber         string `json:"card_number"`
}

// CreditCardDictOutput defines model for CreditCardDict-Output.
type CreditCardDictOutput struct {
	CardCvv            string `json:"card_cvv"`
	CardFullExpiration string `json:"card_full_expiration"`
	CardHolderName     string `json:"card_holder_name"`
	CardNumber         string `json:"card_number"`
}

// DataSpace defines model for DataSpace.
type DataSpace struct {
	// Images List of images extracted from the page (ID and download link)
	Images *[]interface{} `json:"images"`

	// Markdown Markdown representation of the extracted data
	Markdown string `json:"markdown"`

	// Structured Structured data extracted from the page in JSON format
	Structured interface{} `json:"structured"`
}

// DeleteCredentialsResponse defines model for DeleteCredentialsResponse.
type DeleteCredentialsResponse struct {
	// Message Message of the deletion
	Message *string `json:"message,omitempty"`

	// Status Status of the deletion
	Status DeleteCredentialsResponseStatus `json:"status"`
}

// DeleteCredentialsResponseStatus Status of the deletion
type DeleteCredentialsResponseStatus string

// DeleteCreditCardResponse defines model for DeleteCreditCardResponse.
type DeleteCreditCardResponse struct {
	// Message Message of the deletion
	Message *string `json:"message,omitempty"`

	// Status Status of the deletion
	Status DeleteCreditCardResponseStatus `json:"status"`
}

// DeleteCreditCardResponseStatus Status of the deletion
type DeleteCreditCardResponseStatus string

// DeleteFunctionResponse defines model for DeleteFunctionResponse.
type DeleteFunctionResponse struct {
	// Message The message of the deletion
	Message string `json:"message"`

	// Status The status of the deletion
	Status DeleteFunctionResponseStatus `json:"status"`
}

// DeleteFunctionResponseStatus The status of the deletion
type DeleteFunctionResponseStatus string

// DeletePersonaResponse defines model for DeletePersonaResponse.
type DeletePersonaResponse struct {
	// Message Message of the deletion
	Message *string `json:"message,omitempty"`

	// Status Status of the deletion
	Status DeletePersonaResponseStatus `json:"status"`
}

// DeletePersonaResponseStatus Status of the deletion
type DeletePersonaResponseStatus string

// DeletePhoneNumberResponse defines model for DeletePhoneNumberResponse.
type DeletePhoneNumberResponse struct {
	// Message Message of the deletion
	Message *string `json:"message,omitempty"`

	// Status Status of the deletion
	Status DeletePhoneNumberResponseStatus `json:"status"`
}

// DeletePhoneNumberResponseStatus Status of the deletion
type DeletePhoneNumberResponseStatus string

// DeleteVaultResponse defines model for DeleteVaultResponse.
type DeleteVaultResponse struct {
	// Message Message of the deletion
	Message *string `json:"message,omitempty"`

	// Status Status of the deletion
	Status DeleteVaultResponseStatus `json:"status"`
}

// DeleteVaultResponseStatus Status of the deletion
type DeleteVaultResponseStatus string

// DownloadFileActionInput defines model for DownloadFileAction-Input.
type DownloadFileActionInput struct {
	Category    *string                           `json:"category,omitempty"`
	Description *string                           `json:"description,omitempty"`
	Id          *string                           `json:"id,omitempty"`
	Param       interface{}                       `json:"param"`
	PressEnter  *bool                             `json:"press_enter"`
	Selector    *DownloadFileActionInput_Selector `json:"selector"`
	TextLabel   *string                           `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int    `json:"timeout,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// DownloadFileActionInputSelector0 defines model for .
type DownloadFileActionInputSelector0 = string

// DownloadFileActionInput_Selector defines model for DownloadFileActionInput.Selector.
type DownloadFileActionInput_Selector struct {
	union json.RawMessage
}

// DownloadFileActionOutput defines model for DownloadFileAction-Output.
type DownloadFileActionOutput struct {
	Category    *string                            `json:"category,omitempty"`
	Description *string                            `json:"description,omitempty"`
	Id          *string                            `json:"id,omitempty"`
	PressEnter  *bool                              `json:"press_enter"`
	Selector    *DownloadFileActionOutput_Selector `json:"selector"`
	TextLabel   *string                            `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int    `json:"timeout,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// DownloadFileActionOutputSelector0 defines model for .
type DownloadFileActionOutputSelector0 = string

// DownloadFileActionOutput_Selector defines model for DownloadFileActionOutput.Selector.
type DownloadFileActionOutput_Selector struct {
	union json.RawMessage
}

// EmailReadAction defines model for EmailReadAction.
type EmailReadAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`

	// Limit Max number of emails to return
	Limit *int `json:"limit,omitempty"`

	// OnlyUnread Return only previously unread emails
	OnlyUnread *bool `json:"only_unread,omitempty"`

	// Timedelta Return only emails that are not older than `timedelta`
	Timedelta *string `json:"timedelta"`
	Type      *string `json:"type,omitempty"`
}

// EmailResponse defines model for EmailResponse.
type EmailResponse struct {
	// CreatedAt Creation date
	CreatedAt time.Time `json:"created_at"`

	// EmailId Email UUID
	EmailId string `json:"email_id"`

	// HtmlContent HTML body, can be uncorrelated with raw content
	HtmlContent *string `json:"html_content"`

	// SenderEmail Email address of the sender
	SenderEmail *string `json:"sender_email"`

	// SenderName Name (if available) of the sender
	SenderName *string `json:"sender_name"`

	// Subject Subject of the email
	Subject string `json:"subject"`

	// TextContent Raw textual body, can be uncorrelated with html content
	TextContent *string `json:"text_content"`
}

// ExecutionResponse defines model for ExecutionResponse.
type ExecutionResponse struct {
	// Message A message describing the operation
	Message string `json:"message"`

	// Success Whether the operation was successful
	Success bool `json:"success"`
}

// ExternalProxy defines model for ExternalProxy.
type ExternalProxy struct {
	Bypass   *string `json:"bypass"`
	Password *string `json:"password"`
	Server   string  `json:"server"`
	Type     *string `json:"type,omitempty"`
	Username *string `json:"username"`
}

// FallbackFillActionInput defines model for FallbackFillAction-Input.
type FallbackFillActionInput struct {
	Category        *string                           `json:"category,omitempty"`
	ClearBeforeFill *bool                             `json:"clear_before_fill,omitempty"`
	Description     *string                           `json:"description,omitempty"`
	Id              *string                           `json:"id,omitempty"`
	Param           interface{}                       `json:"param"`
	PressEnter      *bool                             `json:"press_enter"`
	Selector        *FallbackFillActionInput_Selector `json:"selector"`
	TextLabel       *string                           `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int                          `json:"timeout,omitempty"`
	Type    *string                       `json:"type,omitempty"`
	Value   FallbackFillActionInput_Value `json:"value"`
}

// FallbackFillActionInputSelector0 defines model for .
type FallbackFillActionInputSelector0 = string

// FallbackFillActionInput_Selector defines model for FallbackFillActionInput.Selector.
type FallbackFillActionInput_Selector struct {
	union json.RawMessage
}

// FallbackFillActionInputValue0 defines model for .
type FallbackFillActionInputValue0 = string

// FallbackFillActionInputValue1 defines model for .
type FallbackFillActionInputValue1 = string

// FallbackFillActionInput_Value defines model for FallbackFillActionInput.Value.
type FallbackFillActionInput_Value struct {
	union json.RawMessage
}

// FallbackFillActionOutput defines model for FallbackFillAction-Output.
type FallbackFillActionOutput struct {
	Category        *string                            `json:"category,omitempty"`
	ClearBeforeFill *bool                              `json:"clear_before_fill,omitempty"`
	Description     *string                            `json:"description,omitempty"`
	Id              *string                            `json:"id,omitempty"`
	PressEnter      *bool                              `json:"press_enter"`
	Selector        *FallbackFillActionOutput_Selector `json:"selector"`
	TextLabel       *string                            `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int                           `json:"timeout,omitempty"`
	Type    *string                        `json:"type,omitempty"`
	Value   FallbackFillActionOutput_Value `json:"value"`
}

// FallbackFillActionOutputSelector0 defines model for .
type FallbackFillActionOutputSelector0 = string

// FallbackFillActionOutput_Selector defines model for FallbackFillActionOutput.Selector.
type FallbackFillActionOutput_Selector struct {
	union json.RawMessage
}

// FallbackFillActionOutputValue0 defines model for .
type FallbackFillActionOutputValue0 = string

// FallbackFillActionOutputValue1 defines model for .
type FallbackFillActionOutputValue1 = string

// FallbackFillActionOutput_Value defines model for FallbackFillActionOutput.Value.
type FallbackFillActionOutput_Value struct {
	union json.RawMessage
}

// FileLinkResponse defines model for FileLinkResponse.
type FileLinkResponse struct {
	// Url URL to download file from
	Url string `json:"url"`
}

// FileUploadResponse defines model for FileUploadResponse.
type FileUploadResponse struct {
	// Success Whether the upload was successful
	Success bool `json:"success"`
}

// FillActionInput defines model for FillAction-Input.
type FillActionInput struct {
	Category        *string                   `json:"category,omitempty"`
	ClearBeforeFill *bool                     `json:"clear_before_fill,omitempty"`
	Description     *string                   `json:"description,omitempty"`
	Id              *string                   `json:"id,omitempty"`
	Param           interface{}               `json:"param"`
	PressEnter      *bool                     `json:"press_enter"`
	Selector        *FillActionInput_Selector `json:"selector"`
	TextLabel       *string                   `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int                  `json:"timeout,omitempty"`
	Type    *string               `json:"type,omitempty"`
	Value   FillActionInput_Value `json:"value"`
}

// FillActionInputSelector0 defines model for .
type FillActionInputSelector0 = string

// FillActionInput_Selector defines model for FillActionInput.Selector.
type FillActionInput_Selector struct {
	union json.RawMessage
}

// FillActionInputValue0 defines model for .
type FillActionInputValue0 = string

// FillActionInputValue1 defines model for .
type FillActionInputValue1 = string

// FillActionInput_Value defines model for FillActionInput.Value.
type FillActionInput_Value struct {
	union json.RawMessage
}

// FillActionOutput defines model for FillAction-Output.
type FillActionOutput struct {
	Category        *string                    `json:"category,omitempty"`
	ClearBeforeFill *bool                      `json:"clear_before_fill,omitempty"`
	Description     *string                    `json:"description,omitempty"`
	Id              *string                    `json:"id,omitempty"`
	PressEnter      *bool                      `json:"press_enter"`
	Selector        *FillActionOutput_Selector `json:"selector"`
	TextLabel       *string                    `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int                   `json:"timeout,omitempty"`
	Type    *string                `json:"type,omitempty"`
	Value   FillActionOutput_Value `json:"value"`
}

// FillActionOutputSelector0 defines model for .
type FillActionOutputSelector0 = string

// FillActionOutput_Selector defines model for FillActionOutput.Selector.
type FillActionOutput_Selector struct {
	union json.RawMessage
}

// FillActionOutputValue0 defines model for .
type FillActionOutputValue0 = string

// FillActionOutputValue1 defines model for .
type FillActionOutputValue1 = string

// FillActionOutput_Value defines model for FillActionOutput.Value.
type FillActionOutput_Value struct {
	union json.RawMessage
}

// FormFillAction defines model for FormFillAction.
type FormFillAction struct {
	Category    *string                                              `json:"category,omitempty"`
	Description *string                                              `json:"description,omitempty"`
	Type        *string                                              `json:"type,omitempty"`
	Value       map[string]FormFillAction_Value_AdditionalProperties `json:"value"`
}

// FormFillActionValue0 defines model for .
type FormFillActionValue0 = string

// FormFillActionValue1 defines model for .
type FormFillActionValue1 = string

// FormFillAction_Value_AdditionalProperties defines model for FormFillAction.value.AdditionalProperties.
type FormFillAction_Value_AdditionalProperties struct {
	union json.RawMessage
}

// FrameData defines model for FrameData.
type FrameData struct {
	// FrameData DOM Content of the frame
	FrameData string `json:"frameData"`

	// FrameUrl URL of the frame
	FrameUrl string `json:"frameUrl"`
}

// FunctionRunUpdateRequest defines model for FunctionRunUpdateRequest.
type FunctionRunUpdateRequest struct {
	// Logs The logs of the workflow run
	Logs *[]string `json:"logs,omitempty"`

	// Result The result of the workflow run
	Result interface{} `json:"result"`

	// SessionId The ID of the session
	SessionId *string `json:"session_id"`

	// Status The status of the workflow run
	Status FunctionRunUpdateRequestStatus `json:"status"`

	// Variables The variables of the workflow run
	Variables *map[string]interface{} `json:"variables"`
}

// FunctionRunUpdateRequestStatus The status of the workflow run
type FunctionRunUpdateRequestStatus string

// GetCookiesResponse defines model for GetCookiesResponse.
type GetCookiesResponse struct {
	Cookies []Cookie `json:"cookies"`
}

// GetCredentialsResponse defines model for GetCredentialsResponse.
type GetCredentialsResponse struct {
	Credentials CredentialsDictOutput `json:"credentials"`
}

// GetCreditCardResponse defines model for GetCreditCardResponse.
type GetCreditCardResponse struct {
	CreditCard CreditCardDictOutput `json:"credit_card"`
}

// GetFunctionResponse defines model for GetFunctionResponse.
type GetFunctionResponse struct {
	// CreatedAt The creation time of the workflow
	CreatedAt time.Time `json:"created_at"`

	// Description The description of the workflow
	Description *string `json:"description"`

	// FunctionId The ID of the function
	FunctionId string `json:"function_id"`

	// LatestVersion The version of the workflow
	LatestVersion string `json:"latest_version"`

	// Name The name of the workflow
	Name *string `json:"name"`

	// ReferenceWorkflowId The ID of the reference workflow (i.e wether the workflow was forked from another workflow or not)
	ReferenceWorkflowId *string `json:"reference_workflow_id"`

	// Shared Whether the workflow is public and can beshared with other users
	Shared *bool `json:"shared,omitempty"`

	// Status The status of the workflow
	Status string `json:"status"`

	// UpdatedAt The last update time of the workflow
	UpdatedAt time.Time `json:"updated_at"`

	// Variables The variables to run the workflow with
	Variables *[]interface{} `json:"variables"`

	// Versions The versions of the workflow
	Versions   []string `json:"versions"`
	WorkflowId *string  `json:"workflow_id,omitempty"`
}

// GetFunctionRunResponse defines model for GetFunctionRunResponse.
type GetFunctionRunResponse struct {
	CreatedAt time.Time `json:"created_at"`

	// FunctionId The ID of the function
	FunctionId string `json:"function_id"`

	// FunctionRunId The ID of the function run
	FunctionRunId string `json:"function_run_id"`

	// Local Whether the workflow has been run locally or on the cloud
	Local *bool `json:"local,omitempty"`

	// Logs The logs of the workflow run
	Logs *[]string `json:"logs,omitempty"`

	// Result The result of the workflow run (if any)
	Result *string `json:"result"`

	// SessionId The ID of the session
	SessionId *string                      `json:"session_id"`
	Status    GetFunctionRunResponseStatus `json:"status"`
	UpdatedAt time.Time                    `json:"updated_at"`

	// Variables The variables of the workflow run
	Variables     *map[string]interface{} `json:"variables"`
	WorkflowId    *string                 `json:"workflow_id,omitempty"`
	WorkflowRunId *string                 `json:"workflow_run_id,omitempty"`
}

// GetFunctionRunResponseStatus defines model for GetFunctionRunResponse.Status.
type GetFunctionRunResponseStatus string

// GetFunctionWithLinkResponse defines model for GetFunctionWithLinkResponse.
type GetFunctionWithLinkResponse struct {
	// CreatedAt The creation time of the workflow
	CreatedAt time.Time `json:"created_at"`

	// Description The description of the workflow
	Description *string `json:"description"`

	// FunctionId The ID of the function
	FunctionId string `json:"function_id"`

	// LatestVersion The version of the workflow
	LatestVersion string `json:"latest_version"`

	// Name The name of the workflow
	Name *string `json:"name"`

	// ReferenceWorkflowId The ID of the reference workflow (i.e wether the workflow was forked from another workflow or not)
	ReferenceWorkflowId *string `json:"reference_workflow_id"`

	// Shared Whether the workflow is public and can beshared with other users
	Shared *bool `json:"shared,omitempty"`

	// Status The status of the workflow
	Status string `json:"status"`

	// UpdatedAt The last update time of the workflow
	UpdatedAt time.Time `json:"updated_at"`

	// Url URL to download file from
	Url string `json:"url"`

	// Variables The variables to run the workflow with
	Variables *[]interface{} `json:"variables"`

	// Versions The versions of the workflow
	Versions   []string `json:"versions"`
	WorkflowId *string  `json:"workflow_id,omitempty"`
}

// GlobalScrapeRequest defines model for GlobalScrapeRequest.
type GlobalScrapeRequest struct {
	// BrowserType The browser type to use. Can be chromium, chrome or firefox.
	BrowserType *GlobalScrapeRequestBrowserType `json:"browser_type,omitempty"`

	// CdpUrl The CDP URL of another remote session provider.
	CdpUrl *string `json:"cdp_url"`

	// ChromeArgs Overwrite the chrome instance arguments
	ChromeArgs *[]interface{} `json:"chrome_args"`

	// Headless Whether to run the session in headless mode.
	Headless *bool `json:"headless,omitempty"`

	// IdleTimeoutMinutes Idle timeout in minutes. Session closes after this period of inactivity (resets on each operation).
	IdleTimeoutMinutes *int `json:"idle_timeout_minutes,omitempty"`

	// IgnoredTags HTML tags to ignore from the page
	IgnoredTags *[]interface{} `json:"ignored_tags"`

	// Instructions Additional instructions to use for the scrape. E.g. 'Extract only the title, date and content of the articles.'
	Instructions *string `json:"instructions"`

	// MaxDurationMinutes Maximum session lifetime in minutes (absolute maximum, not affected by activity).
	MaxDurationMinutes *int `json:"max_duration_minutes,omitempty"`

	// OnlyImages Whether to only scrape images from the page. If True, the page content is excluded.
	OnlyImages *bool `json:"only_images,omitempty"`

	// OnlyMainContent Whether to only scrape the main content of the page. If True, navbars, footers, etc. are excluded.
	OnlyMainContent *bool `json:"only_main_content,omitempty"`

	// Profile Browser profile configuration for state persistence
	Profile interface{} `json:"profile"`

	// Proxies List of custom proxies to use for the session. If True, the default proxies will be used.
	Proxies *GlobalScrapeRequest_Proxies `json:"proxies,omitempty"`

	// ResponseFormat The response format to use for the scrape. You can use a Pydantic model or a JSON Schema dict (cf. https://docs.pydantic.dev/latest/concepts/json_schema/#generating-json-schema.)
	ResponseFormat interface{} `json:"response_format"`

	// ScrapeImages Whether to scrape images from the page. Images are scraped by default.
	ScrapeImages *bool `json:"scrape_images,omitempty"`

	// ScrapeLinks Whether to scrape links from the page. Links are scraped by default.
	ScrapeLinks *bool `json:"scrape_links,omitempty"`

	// ScreenshotType The type of screenshot to use for the session.
	ScreenshotType *GlobalScrapeRequestScreenshotType `json:"screenshot_type,omitempty"`

	// Selector Playwright selector to scope the scrape to. Only content inside this selector will be scraped.
	Selector *string `json:"selector"`

	// SolveCaptchas Whether to try to automatically solve captchas
	SolveCaptchas *bool  `json:"solve_captchas,omitempty"`
	Url           string `json:"url"`

	// UseFileStorage Whether FileStorage should be attached to the session.
	UseFileStorage *bool `json:"use_file_storage,omitempty"`

	// UseLinkPlaceholders Whether to use link/image placeholders to reduce the number of tokens in the prompt and hallucinations. However this is an experimental feature and might not work as expected.
	UseLinkPlaceholders *bool `json:"use_link_placeholders,omitempty"`

	// UserAgent The user agent to use for the session
	UserAgent *string `json:"user_agent"`

	// ViewportHeight The height of the viewport
	ViewportHeight *int `json:"viewport_height"`

	// ViewportWidth The width of the viewport
	ViewportWidth *int `json:"viewport_width"`
}

// GlobalScrapeRequestBrowserType The browser type to use. Can be chromium, chrome or firefox.
type GlobalScrapeRequestBrowserType string

// GlobalScrapeRequestProxies0 defines model for .
type GlobalScrapeRequestProxies0 = []GlobalScrapeRequest_Proxies_0_Item

// GlobalScrapeRequest_Proxies_0_Item defines model for GlobalScrapeRequest.Proxies.0.Item.
type GlobalScrapeRequest_Proxies_0_Item struct {
	union json.RawMessage
}

// GlobalScrapeRequestProxies1 defines model for .
type GlobalScrapeRequestProxies1 = bool

// GlobalScrapeRequest_Proxies List of custom proxies to use for the session. If True, the default proxies will be used.
type GlobalScrapeRequest_Proxies struct {
	union json.RawMessage
}

// GlobalScrapeRequestScreenshotType The type of screenshot to use for the session.
type GlobalScrapeRequestScreenshotType string

// GoBackAction defines model for GoBackAction.
type GoBackAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// GoForwardAction defines model for GoForwardAction.
type GoForwardAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// GotoAction defines model for GotoAction.
type GotoAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
	Url         string  `json:"url"`
}

// GotoNewTabAction defines model for GotoNewTabAction.
type GotoNewTabAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
	Url         string  `json:"url"`
}

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Description *string `json:"description,omitempty"`
	Status      *string `json:"status,omitempty"`
	Version     *string `json:"version,omitempty"`
}

// HelpAction defines model for HelpAction.
type HelpAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Reason      string  `json:"reason"`
	Type        *string `json:"type,omitempty"`
}

// ImageCategory defines model for ImageCategory.
type ImageCategory string

// ImageData defines model for ImageData.
type ImageData struct {
	// Category Category of the image (icon, svg, content, etc.)
	Category interface{} `json:"category"`

	// Description Description of the image
	Description *string `json:"description"`

	// Url URL of the image
	Url *string `json:"url"`
}

// ImprovePromptRequest defines model for ImprovePromptRequest.
type ImprovePromptRequest struct {
	Prompt string `json:"prompt"`
}

// ImprovePromptResponse defines model for ImprovePromptResponse.
type ImprovePromptResponse struct {
	Prompt    string         `json:"prompt"`
	Variables *[]interface{} `json:"variables"`
}

// LegacyAgentStatusResponse defines model for LegacyAgentStatusResponse.
type LegacyAgentStatusResponse struct {
	// AgentId The ID of the agent
	AgentId string `json:"agent_id"`

	// Answer The answer to the agent task. None if the agent is still running
	Answer *string `json:"answer"`

	// ClosedAt The closing time of the agent
	ClosedAt *string `json:"closed_at"`

	// CreatedAt The creation time of the agent
	CreatedAt time.Time `json:"created_at"`

	// CreditUsage Credit usage for the agent. None if the agent is still running
	CreditUsage *float32 `json:"credit_usage"`

	// Replay The session replay in `.webp` format
	Replay *string `json:"replay"`

	// ReplayStartOffset The start offset of the replay
	ReplayStartOffset int `json:"replay_start_offset"`

	// ReplayStopOffset The stop offset of the replay
	ReplayStopOffset int `json:"replay_stop_offset"`

	// Saved Whether the agent is saved as a workflow
	Saved *bool `json:"saved,omitempty"`

	// SessionId The ID of the session
	SessionId string                    `json:"session_id"`
	Status    AgentStatus               `json:"status"`
	Steps     *[]map[string]interface{} `json:"steps,omitempty"`

	// Success Whether the agent task was successful. None if the agent is still running
	Success *bool `json:"success"`

	// Task The task that the agent is currently running
	Task string `json:"task"`

	// Url The URL that the agent started on
	Url *string `json:"url"`
}

// ListCredentialsResponse defines model for ListCredentialsResponse.
type ListCredentialsResponse struct {
	// Credentials URLs for which we hold credentials
	Credentials []Credential `json:"credentials"`
}

// ListFilesResponse defines model for ListFilesResponse.
type ListFilesResponse struct {
	// Files Names of available files
	Files []string `json:"files"`
}

// LlmModel defines model for LlmModel.
type LlmModel string

// MultiFactorFillActionInput defines model for MultiFactorFillAction-Input.
type MultiFactorFillActionInput struct {
	Category        *string                              `json:"category,omitempty"`
	ClearBeforeFill *bool                                `json:"clear_before_fill,omitempty"`
	Description     *string                              `json:"description,omitempty"`
	Id              *string                              `json:"id,omitempty"`
	Param           interface{}                          `json:"param"`
	PressEnter      *bool                                `json:"press_enter"`
	Selector        *MultiFactorFillActionInput_Selector `json:"selector"`
	TextLabel       *string                              `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int                             `json:"timeout,omitempty"`
	Type    *string                          `json:"type,omitempty"`
	Value   MultiFactorFillActionInput_Value `json:"value"`
}

// MultiFactorFillActionInputSelector0 defines model for .
type MultiFactorFillActionInputSelector0 = string

// MultiFactorFillActionInput_Selector defines model for MultiFactorFillActionInput.Selector.
type MultiFactorFillActionInput_Selector struct {
	union json.RawMessage
}

// MultiFactorFillActionInputValue0 defines model for .
type MultiFactorFillActionInputValue0 = string

// MultiFactorFillActionInputValue1 defines model for .
type MultiFactorFillActionInputValue1 = string

// MultiFactorFillActionInput_Value defines model for MultiFactorFillActionInput.Value.
type MultiFactorFillActionInput_Value struct {
	union json.RawMessage
}

// MultiFactorFillActionOutput defines model for MultiFactorFillAction-Output.
type MultiFactorFillActionOutput struct {
	Category        *string                               `json:"category,omitempty"`
	ClearBeforeFill *bool                                 `json:"clear_before_fill,omitempty"`
	Description     *string                               `json:"description,omitempty"`
	Id              *string                               `json:"id,omitempty"`
	PressEnter      *bool                                 `json:"press_enter"`
	Selector        *MultiFactorFillActionOutput_Selector `json:"selector"`
	TextLabel       *string                               `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int                              `json:"timeout,omitempty"`
	Type    *string                           `json:"type,omitempty"`
	Value   MultiFactorFillActionOutput_Value `json:"value"`
}

// MultiFactorFillActionOutputSelector0 defines model for .
type MultiFactorFillActionOutputSelector0 = string

// MultiFactorFillActionOutput_Selector defines model for MultiFactorFillActionOutput.Selector.
type MultiFactorFillActionOutput_Selector struct {
	union json.RawMessage
}

// MultiFactorFillActionOutputValue0 defines model for .
type MultiFactorFillActionOutputValue0 = string

// MultiFactorFillActionOutputValue1 defines model for .
type MultiFactorFillActionOutputValue1 = string

// MultiFactorFillActionOutput_Value defines model for MultiFactorFillActionOutput.Value.
type MultiFactorFillActionOutput_Value struct {
	union json.RawMessage
}

// NetworkLogFile defines model for NetworkLogFile.
type NetworkLogFile struct {
	DownloadUrl                 *string            `json:"download_url"`
	DownloadUrlExpiresInSeconds *int               `json:"download_url_expires_in_seconds"`
	Filename                    string             `json:"filename"`
	Path                        string             `json:"path"`
	Type                        NetworkLogFileType `json:"type"`
}

// NetworkLogFileType defines model for NetworkLogFile.Type.
type NetworkLogFileType string

// NetworkLogsResponse defines model for NetworkLogsResponse.
type NetworkLogsResponse struct {
	Requests   []NetworkLogFile `json:"requests"`
	Responses  []NetworkLogFile `json:"responses"`
	SessionId  string           `json:"session_id"`
	TotalCount int              `json:"total_count"`
}

// NodeSelectors defines model for NodeSelectors.
type NodeSelectors struct {
	CssSelector              string   `json:"css_selector"`
	IframeParentCssSelectors []string `json:"iframe_parent_css_selectors"`
	InIframe                 bool     `json:"in_iframe"`
	InShadowRoot             bool     `json:"in_shadow_root"`
	NotteSelector            *string  `json:"notte_selector"`
	PlaywrightSelector       *string  `json:"playwright_selector"`
	PythonSelector           *string  `json:"python_selector"`
	XpathSelector            string   `json:"xpath_selector"`
}

// NotteProxy defines model for NotteProxy.
type NotteProxy struct {
	Country interface{} `json:"country"`
	Id      *string     `json:"id"`
	Type    *string     `json:"type,omitempty"`
}

// NudgePromptRequest defines model for NudgePromptRequest.
type NudgePromptRequest struct {
	AgentMessages []map[string]interface{} `json:"agent_messages"`
	Task          string                   `json:"task"`
}

// NudgePromptResponse defines model for NudgePromptResponse.
type NudgePromptResponse struct {
	Prompt string `json:"prompt"`
}

// ObserveRequest defines model for ObserveRequest.
type ObserveRequest struct {
	// Instructions Additional instructions to use for the observation.
	Instructions *string `json:"instructions"`

	// MaxNbActions The maximum number of actions to list after which the listing will stop. Used when min_nb_actions is not provided.
	MaxNbActions *int `json:"max_nb_actions,omitempty"`

	// MinNbActions The minimum number of actions to list before stopping. If not provided, the listing will continue until the maximum number of actions is reached.
	MinNbActions *int `json:"min_nb_actions"`

	// PerceptionType Whether to run with fast or deep perception
	PerceptionType *string `json:"perception_type"`

	// Url The URL to observe. If not provided, uses the current page URL.
	Url *string `json:"url"`
}

// ObserveResponse defines model for ObserveResponse.
type ObserveResponse struct {
	Metadata   SnapshotMetadata `json:"metadata"`
	Screenshot Screenshot       `json:"screenshot"`
	Session    SessionResponse  `json:"session"`
	Space      ActionSpace      `json:"space"`
}

// PaginatedResponseAgentResponse defines model for PaginatedResponse_AgentResponse_.
type PaginatedResponseAgentResponse struct {
	HasNext     bool            `json:"has_next"`
	HasPrevious *bool           `json:"has_previous,omitempty"`
	Items       []AgentResponse `json:"items"`
	Page        int             `json:"page"`
	PageSize    int             `json:"page_size"`
}

// PaginatedResponseGetFunctionResponse defines model for PaginatedResponse_GetFunctionResponse_.
type PaginatedResponseGetFunctionResponse struct {
	HasNext     bool                  `json:"has_next"`
	HasPrevious *bool                 `json:"has_previous,omitempty"`
	Items       []GetFunctionResponse `json:"items"`
	Page        int                   `json:"page"`
	PageSize    int                   `json:"page_size"`
}

// PaginatedResponseGetFunctionRunResponse defines model for PaginatedResponse_GetFunctionRunResponse_.
type PaginatedResponseGetFunctionRunResponse struct {
	HasNext     bool                     `json:"has_next"`
	HasPrevious *bool                    `json:"has_previous,omitempty"`
	Items       []GetFunctionRunResponse `json:"items"`
	Page        int                      `json:"page"`
	PageSize    int                      `json:"page_size"`
}

// PaginatedResponsePersonaResponse defines model for PaginatedResponse_PersonaResponse_.
type PaginatedResponsePersonaResponse struct {
	HasNext     bool              `json:"has_next"`
	HasPrevious *bool             `json:"has_previous,omitempty"`
	Items       []PersonaResponse `json:"items"`
	Page        int               `json:"page"`
	PageSize    int               `json:"page_size"`
}

// PaginatedResponseProfileResponse defines model for PaginatedResponse_ProfileResponse_.
type PaginatedResponseProfileResponse struct {
	HasNext     bool              `json:"has_next"`
	HasPrevious *bool             `json:"has_previous,omitempty"`
	Items       []ProfileResponse `json:"items"`
	Page        int               `json:"page"`
	PageSize    int               `json:"page_size"`
}

// PaginatedResponseSessionResponse defines model for PaginatedResponse_SessionResponse_.
type PaginatedResponseSessionResponse struct {
	HasNext     bool              `json:"has_next"`
	HasPrevious *bool             `json:"has_previous,omitempty"`
	Items       []SessionResponse `json:"items"`
	Page        int               `json:"page"`
	PageSize    int               `json:"page_size"`
}

// PaginatedResponseUsageLog defines model for PaginatedResponse_UsageLog_.
type PaginatedResponseUsageLog struct {
	HasNext     bool       `json:"has_next"`
	HasPrevious *bool      `json:"has_previous,omitempty"`
	Items       []UsageLog `json:"items"`
	Page        int        `json:"page"`
	PageSize    int        `json:"page_size"`
}

// PaginatedResponseVault defines model for PaginatedResponse_Vault_.
type PaginatedResponseVault struct {
	HasNext     bool    `json:"has_next"`
	HasPrevious *bool   `json:"has_previous,omitempty"`
	Items       []Vault `json:"items"`
	Page        int     `json:"page"`
	PageSize    int     `json:"page_size"`
}

// ParameterInfo defines model for ParameterInfo.
type ParameterInfo struct {
	Default *string `json:"default"`
	Name    string  `json:"name"`
	Type    *string `json:"type"`
}

// PersonaCreateRequest defines model for PersonaCreateRequest.
type PersonaCreateRequest struct {
	// CreatePhoneNumber Whether to create a phone number for the persona
	CreatePhoneNumber *bool `json:"create_phone_number,omitempty"`

	// CreateVault Whether to create a vault for the persona
	CreateVault *bool `json:"create_vault,omitempty"`
}

// PersonaResponse defines model for PersonaResponse.
type PersonaResponse struct {
	// Email Email of the persona
	Email string `json:"email"`

	// FirstName First name of the persona
	FirstName string `json:"first_name"`

	// LastName Last name of the persona
	LastName string `json:"last_name"`

	// PersonaId ID of the created persona
	PersonaId string `json:"persona_id"`

	// PhoneNumber Phone number of the persona (optional)
	PhoneNumber *string `json:"phone_number"`

	// Status Status of the persona (active, closed)
	Status string `json:"status"`

	// VaultId ID of the vault
	VaultId *string `json:"vault_id"`
}

// PressKeyAction defines model for PressKeyAction.
type PressKeyAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Key         string  `json:"key"`
	Type        *string `json:"type,omitempty"`
}

// ProfileCreateRequest defines model for ProfileCreateRequest.
type ProfileCreateRequest struct {
	// Name Name of the profile
	Name *string `json:"name"`
}

// ProfileDeleteResponse defines model for ProfileDeleteResponse.
type ProfileDeleteResponse struct {
	Message *string `json:"message,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// ProfileResponse defines model for ProfileResponse.
type ProfileResponse struct {
	// CreatedAt Profile creation timestamp
	CreatedAt time.Time `json:"created_at"`

	// Name Profile name
	Name *string `json:"name"`

	// ProfileId Profile ID (format: notte-profile-{16 hex chars})
	ProfileId string `json:"profile_id"`

	// UpdatedAt Profile last update timestamp
	UpdatedAt time.Time `json:"updated_at"`
}

// ProxyGeolocationCountry defines model for ProxyGeolocationCountry.
type ProxyGeolocationCountry string

// ReloadAction defines model for ReloadAction.
type ReloadAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// RootModelUnionDictStrAnyListDictStrAny defines model for RootModel_Union_dict_str__Any___list_dict_str__Any____.
type RootModelUnionDictStrAnyListDictStrAny struct {
	union json.RawMessage
}

// RootModelUnionDictStrAnyListDictStrAny0 defines model for .
type RootModelUnionDictStrAnyListDictStrAny0 map[string]interface{}

// RootModelUnionDictStrAnyListDictStrAny1 defines model for .
type RootModelUnionDictStrAnyListDictStrAny1 = []map[string]interface{}

// SMSResponse defines model for SMSResponse.
type SMSResponse struct {
	// Body SMS message body
	Body string `json:"body"`

	// CreatedAt Creation date
	CreatedAt time.Time `json:"created_at"`

	// Sender SMS sender phone number
	Sender *string `json:"sender"`

	// SmsId SMS UUID
	SmsId string `json:"sms_id"`
}

// ScheduleDeleteResponse defines model for ScheduleDeleteResponse.
type ScheduleDeleteResponse struct {
	Status string `json:"status"`
}

// ScheduleResponse defines model for ScheduleResponse.
type ScheduleResponse struct {
	Status string `json:"status"`
}

// SchemaGenerationResponse defines model for SchemaGenerationResponse.
type SchemaGenerationResponse struct {
	Error       *string                 `json:"error"`
	ModelSchema *map[string]interface{} `json:"model_schema"`
	Success     bool                    `json:"success"`
}

// ScrapeAction defines model for ScrapeAction.
type ScrapeAction struct {
	Category     *string `json:"category,omitempty"`
	Description  *string `json:"description,omitempty"`
	Instructions *string `json:"instructions"`

	// OnlyMainContent Whether to only scrape the main content of the page. If True, navbars, footers, etc. are excluded.
	OnlyMainContent *bool   `json:"only_main_content,omitempty"`
	Type            *string `json:"type,omitempty"`
}

// ScrapeFromHtmlRequest defines model for ScrapeFromHtmlRequest.
type ScrapeFromHtmlRequest struct {
	// Frames Frame data for all frames found in the page. The main frame has to be the first one
	Frames *[]FrameData `json:"frames,omitempty"`

	// IgnoredTags HTML tags to ignore from the page
	IgnoredTags *[]interface{} `json:"ignored_tags"`

	// Instructions User description as to what needs to be scraped
	Instructions *string `json:"instructions,omitempty"`

	// OnlyImages Whether to only scrape images from the page. If True, the page content is excluded.
	OnlyImages *bool `json:"only_images,omitempty"`

	// OnlyMainContent Whether to only scrape the main content of the page. If True, navbars, footers, etc. are excluded.
	OnlyMainContent *bool `json:"only_main_content,omitempty"`

	// ResponseFormat The response format to use for the scrape. You can use a Pydantic model or a JSON Schema dict (cf. https://docs.pydantic.dev/latest/concepts/json_schema/#generating-json-schema.)
	ResponseFormat interface{} `json:"response_format"`

	// ScrapeImages Whether to scrape images from the page. Images are scraped by default.
	ScrapeImages *bool `json:"scrape_images,omitempty"`

	// ScrapeLinks Whether to scrape links from the page. Links are scraped by default.
	ScrapeLinks *bool `json:"scrape_links,omitempty"`

	// Selector Playwright selector to scope the scrape to. Only content inside this selector will be scraped.
	Selector *string `json:"selector"`

	// UseLinkPlaceholders Whether to use link/image placeholders to reduce the number of tokens in the prompt and hallucinations. However this is an experimental feature and might not work as expected.
	UseLinkPlaceholders *bool `json:"use_link_placeholders,omitempty"`
}

// ScrapeRequest defines model for ScrapeRequest.
type ScrapeRequest struct {
	// IgnoredTags HTML tags to ignore from the page
	IgnoredTags *[]interface{} `json:"ignored_tags"`

	// Instructions Additional instructions to use for the scrape. E.g. 'Extract only the title, date and content of the articles.'
	Instructions *string `json:"instructions"`

	// OnlyImages Whether to only scrape images from the page. If True, the page content is excluded.
	OnlyImages *bool `json:"only_images,omitempty"`

	// OnlyMainContent Whether to only scrape the main content of the page. If True, navbars, footers, etc. are excluded.
	OnlyMainContent *bool `json:"only_main_content,omitempty"`

	// ResponseFormat The response format to use for the scrape. You can use a Pydantic model or a JSON Schema dict (cf. https://docs.pydantic.dev/latest/concepts/json_schema/#generating-json-schema.)
	ResponseFormat interface{} `json:"response_format"`

	// ScrapeImages Whether to scrape images from the page. Images are scraped by default.
	ScrapeImages *bool `json:"scrape_images,omitempty"`

	// ScrapeLinks Whether to scrape links from the page. Links are scraped by default.
	ScrapeLinks *bool `json:"scrape_links,omitempty"`

	// Selector Playwright selector to scope the scrape to. Only content inside this selector will be scraped.
	Selector *string `json:"selector"`

	// UseLinkPlaceholders Whether to use link/image placeholders to reduce the number of tokens in the prompt and hallucinations. However this is an experimental feature and might not work as expected.
	UseLinkPlaceholders *bool `json:"use_link_placeholders,omitempty"`
}

// ScrapeResponse defines model for ScrapeResponse.
type ScrapeResponse struct {
	// Images List of images extracted from the page (ID and download link)
	Images *[]interface{} `json:"images"`

	// Markdown Markdown representation of the extracted data
	Markdown string          `json:"markdown"`
	Session  SessionResponse `json:"session"`

	// Structured Structured data extracted from the page in JSON format
	Structured interface{} `json:"structured"`
}

// ScrapeSchemaResponse defines model for ScrapeSchemaResponse.
type ScrapeSchemaResponse struct {
	ModelSchema SchemaGenerationResponse `json:"model_schema"`

	// Scrape Output from the scrape, validated upon the model schema
	Scrape interface{} `json:"scrape"`
}

// Screenshot defines model for Screenshot.
type Screenshot struct {
	Bboxes       *[]BoundingBox     `json:"bboxes,omitempty"`
	LastActionId *string            `json:"last_action_id"`
	Raw          openapi_types.File `json:"raw"`
}

// ScrollDownAction defines model for ScrollDownAction.
type ScrollDownAction struct {
	Amount      *int    `json:"amount"`
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// ScrollUpAction defines model for ScrollUpAction.
type ScrollUpAction struct {
	Amount      *int    `json:"amount"`
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// SelectDropdownOptionActionInput defines model for SelectDropdownOptionAction-Input.
type SelectDropdownOptionActionInput struct {
	Category    *string                                   `json:"category,omitempty"`
	Description *string                                   `json:"description,omitempty"`
	Id          *string                                   `json:"id,omitempty"`
	Param       interface{}                               `json:"param"`
	PressEnter  *bool                                     `json:"press_enter"`
	Selector    *SelectDropdownOptionActionInput_Selector `json:"selector"`
	TextLabel   *string                                   `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int                                  `json:"timeout,omitempty"`
	Type    *string                               `json:"type,omitempty"`
	Value   SelectDropdownOptionActionInput_Value `json:"value"`
}

// SelectDropdownOptionActionInputSelector0 defines model for .
type SelectDropdownOptionActionInputSelector0 = string

// SelectDropdownOptionActionInput_Selector defines model for SelectDropdownOptionActionInput.Selector.
type SelectDropdownOptionActionInput_Selector struct {
	union json.RawMessage
}

// SelectDropdownOptionActionInputValue0 defines model for .
type SelectDropdownOptionActionInputValue0 = string

// SelectDropdownOptionActionInputValue1 defines model for .
type SelectDropdownOptionActionInputValue1 = string

// SelectDropdownOptionActionInput_Value defines model for SelectDropdownOptionActionInput.Value.
type SelectDropdownOptionActionInput_Value struct {
	union json.RawMessage
}

// SelectDropdownOptionActionOutput defines model for SelectDropdownOptionAction-Output.
type SelectDropdownOptionActionOutput struct {
	Category    *string                                    `json:"category,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Id          *string                                    `json:"id,omitempty"`
	PressEnter  *bool                                      `json:"press_enter"`
	Selector    *SelectDropdownOptionActionOutput_Selector `json:"selector"`
	TextLabel   *string                                    `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int                                   `json:"timeout,omitempty"`
	Type    *string                                `json:"type,omitempty"`
	Value   SelectDropdownOptionActionOutput_Value `json:"value"`
}

// SelectDropdownOptionActionOutputSelector0 defines model for .
type SelectDropdownOptionActionOutputSelector0 = string

// SelectDropdownOptionActionOutput_Selector defines model for SelectDropdownOptionActionOutput.Selector.
type SelectDropdownOptionActionOutput_Selector struct {
	union json.RawMessage
}

// SelectDropdownOptionActionOutputValue0 defines model for .
type SelectDropdownOptionActionOutputValue0 = string

// SelectDropdownOptionActionOutputValue1 defines model for .
type SelectDropdownOptionActionOutputValue1 = string

// SelectDropdownOptionActionOutput_Value defines model for SelectDropdownOptionActionOutput.Value.
type SelectDropdownOptionActionOutput_Value struct {
	union json.RawMessage
}

// SessionDebugResponse defines model for SessionDebugResponse.
type SessionDebugResponse struct {
	DebugUrl string                    `json:"debug_url"`
	Tabs     []TabSessionDebugResponse `json:"tabs"`
	Ws       WebSocketUrls             `json:"ws"`
}

// SessionOffsetResponse defines model for SessionOffsetResponse.
type SessionOffsetResponse struct {
	// Offset Current state of the session trajectory
	Offset int `json:"offset"`
}

// SessionProfile defines model for SessionProfile.
type SessionProfile struct {
	// Id Profile ID to use for this session
	Id string `json:"id"`

	// Persist Whether to save browser state to profile on session close
	Persist *bool `json:"persist,omitempty"`
}

// SessionResponse defines model for SessionResponse.
type SessionResponse struct {
	BrowserType *SessionResponseBrowserType `json:"browser_type,omitempty"`

	// CdpUrl The URL to connect to the CDP server.
	CdpUrl *string `json:"cdp_url"`

	// ClosedAt Session closing time
	ClosedAt *string `json:"closed_at"`

	// CreatedAt Session creation time
	CreatedAt time.Time `json:"created_at"`

	// CreditUsage Credit usage for the session. None
	CreditUsage *float32 `json:"credit_usage"`

	// Duration Session duration
	Duration *string `json:"duration,omitempty"`

	// Error Error message if the operation failed to complete
	Error *string `json:"error"`

	// Headless Whether to run the session in headless mode.
	Headless *bool `json:"headless,omitempty"`

	// IdleTimeoutMinutes Session idle timeout in minutes. Will timeout if now() > last access time + idle_timeout_minutes
	IdleTimeoutMinutes int `json:"idle_timeout_minutes"`

	// LastAccessedAt Last access time
	LastAccessedAt time.Time `json:"last_accessed_at"`

	// MaxDurationMinutes Session max duration in minutes. Will timeout if now() > creation time + max_duration_minutes
	MaxDurationMinutes *int `json:"max_duration_minutes,omitempty"`

	// NetworkRequestBytes Total byte usage for network requests.
	NetworkRequestBytes *int `json:"network_request_bytes,omitempty"`

	// NetworkResponseBytes Total byte usage for network responses.
	NetworkResponseBytes *int `json:"network_response_bytes,omitempty"`

	// Proxies Whether proxies were used for the session. True if any proxy was applied during session creation.
	Proxies *bool `json:"proxies,omitempty"`

	// SessionId The ID of the session (created or existing). Use this ID to interact with the session for the next operation.
	SessionId string `json:"session_id"`

	// SolveCaptchas Whether to solve captchas.
	SolveCaptchas *bool `json:"solve_captchas"`

	// Status Session status
	Status SessionResponseStatus `json:"status"`

	// Steps Steps of the session
	Steps *[]map[string]interface{} `json:"steps,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	TimeoutMinutes *int `json:"timeout_minutes,omitempty"`

	// UseFileStorage Whether FileStorage was attached to the session.
	UseFileStorage *bool `json:"use_file_storage,omitempty"`

	// UserAgent The user agent to use for the session
	UserAgent *string `json:"user_agent"`

	// ViewportHeight The height of the viewport
	ViewportHeight *int `json:"viewport_height"`

	// ViewportWidth The width of the viewport
	ViewportWidth *int `json:"viewport_width"`
}

// SessionResponseBrowserType defines model for SessionResponse.BrowserType.
type SessionResponseBrowserType string

// SessionResponseStatus Session status
type SessionResponseStatus string

// SmsReadAction defines model for SmsReadAction.
type SmsReadAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`

	// Limit Max number of sms to return
	Limit *int `json:"limit,omitempty"`

	// OnlyUnread Return only previously unread sms
	OnlyUnread *bool `json:"only_unread,omitempty"`

	// Timedelta Return only sms that are not older than `timedelta`
	Timedelta *string `json:"timedelta"`
	Type      *string `json:"type,omitempty"`
}

// SnapshotMetadata defines model for SnapshotMetadata.
type SnapshotMetadata struct {
	Tabs      []TabsData   `json:"tabs"`
	Timestamp *time.Time   `json:"timestamp,omitempty"`
	Title     string       `json:"title"`
	Url       string       `json:"url"`
	Viewport  ViewportData `json:"viewport"`
}

// SpaceCategory defines model for SpaceCategory.
type SpaceCategory string

// StructuredDataBaseModel defines model for StructuredData_BaseModel_.
type StructuredDataBaseModel struct {
	// Data Structured data extracted from the page in JSON format
	Data *StructuredDataBaseModel_Data `json:"data"`

	// Error Error message if the data was not extracted successfully
	Error *string `json:"error"`

	// Success Whether the data was extracted successfully
	Success *bool `json:"success,omitempty"`
}

// StructuredDataBaseModel_Data Structured data extracted from the page in JSON format
type StructuredDataBaseModel_Data struct {
	union json.RawMessage
}

// SubscriptionType defines model for SubscriptionType.
type SubscriptionType string

// SwitchTabAction defines model for SwitchTabAction.
type SwitchTabAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`
	TabIndex    int     `json:"tab_index"`
	Type        *string `json:"type,omitempty"`
}

// TabSessionDebugResponse defines model for TabSessionDebugResponse.
type TabSessionDebugResponse struct {
	DebugUrl string   `json:"debug_url"`
	Metadata TabsData `json:"metadata"`
	WsUrl    string   `json:"ws_url"`
}

// TabsData defines model for TabsData.
type TabsData struct {
	TabId int    `json:"tab_id"`
	Title string `json:"title"`
	Url   string `json:"url"`
}

// UpdateFunctionRunResponse defines model for UpdateFunctionRunResponse.
type UpdateFunctionRunResponse struct {
	// FunctionId The ID of the function
	FunctionId string `json:"function_id"`

	// FunctionRunId The ID of the function run
	FunctionRunId string                           `json:"function_run_id"`
	Status        *UpdateFunctionRunResponseStatus `json:"status,omitempty"`
	UpdatedAt     time.Time                        `json:"updated_at"`
	WorkflowId    *string                          `json:"workflow_id,omitempty"`
	WorkflowRunId *string                          `json:"workflow_run_id,omitempty"`
}

// UpdateFunctionRunResponseStatus defines model for UpdateFunctionRunResponse.Status.
type UpdateFunctionRunResponseStatus string

// UploadFileActionInput defines model for UploadFileAction-Input.
type UploadFileActionInput struct {
	Category    *string                         `json:"category,omitempty"`
	Description *string                         `json:"description,omitempty"`
	FilePath    string                          `json:"file_path"`
	Id          *string                         `json:"id,omitempty"`
	Param       interface{}                     `json:"param"`
	PressEnter  *bool                           `json:"press_enter"`
	Selector    *UploadFileActionInput_Selector `json:"selector"`
	TextLabel   *string                         `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int    `json:"timeout,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// UploadFileActionInputSelector0 defines model for .
type UploadFileActionInputSelector0 = string

// UploadFileActionInput_Selector defines model for UploadFileActionInput.Selector.
type UploadFileActionInput_Selector struct {
	union json.RawMessage
}

// UploadFileActionOutput defines model for UploadFileAction-Output.
type UploadFileActionOutput struct {
	Category    *string                          `json:"category,omitempty"`
	Description *string                          `json:"description,omitempty"`
	FilePath    string                           `json:"file_path"`
	Id          *string                          `json:"id,omitempty"`
	PressEnter  *bool                            `json:"press_enter"`
	Selector    *UploadFileActionOutput_Selector `json:"selector"`
	TextLabel   *string                          `json:"text_label"`

	// Timeout Action timeout in milliseconds
	Timeout *int    `json:"timeout,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// UploadFileActionOutputSelector0 defines model for .
type UploadFileActionOutputSelector0 = string

// UploadFileActionOutput_Selector defines model for UploadFileActionOutput.Selector.
type UploadFileActionOutput_Selector struct {
	union json.RawMessage
}

// UsageLog defines model for UsageLog.
type UsageLog struct {
	CreatedAt  time.Time `json:"created_at"`
	DurationMs int       `json:"duration_ms"`
	Endpoint   string    `json:"endpoint"`
}

// UsageResponse defines model for UsageResponse.
type UsageResponse struct {
	AdditionalCredits          int                    `json:"additional_credits"`
	BrowserUsageCost           float32                `json:"browser_usage_cost"`
	IsUsageLimitExceeded       bool                   `json:"is_usage_limit_exceeded"`
	LlmUsageCost               float32                `json:"llm_usage_cost"`
	MonthlyCreditsLimit        int                    `json:"monthly_credits_limit"`
	MonthlyCreditsUsage        float32                `json:"monthly_credits_usage"`
	MonthlySessionCount        int                    `json:"monthly_session_count"`
	MonthlySessionUsageMinutes float32                `json:"monthly_session_usage_minutes"`
	Period                     string                 `json:"period"`
	PlanType                   UsageResponse_PlanType `json:"plan_type"`
	ProxyUsageCost             float32                `json:"proxy_usage_cost"`
	ProxyUsageGb               float32                `json:"proxy_usage_gb"`
	TotalCost                  float32                `json:"total_cost"`
}

// UsageResponsePlanType1 defines model for .
type UsageResponsePlanType1 = string

// UsageResponse_PlanType defines model for UsageResponse.PlanType.
type UsageResponse_PlanType struct {
	union json.RawMessage
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []ValidationError_Loc_Item `json:"loc"`
	Msg  string                     `json:"msg"`
	Type string                     `json:"type"`
}

// ValidationErrorLoc0 defines model for .
type ValidationErrorLoc0 = string

// ValidationErrorLoc1 defines model for .
type ValidationErrorLoc1 = int

// ValidationError_Loc_Item defines model for ValidationError.loc.Item.
type ValidationError_Loc_Item struct {
	union json.RawMessage
}

// Vault defines model for Vault.
type Vault struct {
	CreatedAt  time.Time `json:"created_at"`
	ForPersona *bool     `json:"for_persona,omitempty"`
	Name       string    `json:"name"`
	VaultId    string    `json:"vault_id"`
}

// VaultCreateRequest defines model for VaultCreateRequest.
type VaultCreateRequest struct {
	// Name Name of the vault
	Name *string `json:"name,omitempty"`
}

// VaultUpdateRequest defines model for VaultUpdateRequest.
type VaultUpdateRequest struct {
	Name string `json:"name"`
}

// ViewportData defines model for ViewportData.
type ViewportData struct {
	ScrollX        int `json:"scroll_x"`
	ScrollY        int `json:"scroll_y"`
	TotalHeight    int `json:"total_height"`
	TotalWidth     int `json:"total_width"`
	ViewportHeight int `json:"viewport_height"`
	ViewportWidth  int `json:"viewport_width"`
}

// WaitAction defines model for WaitAction.
type WaitAction struct {
	Category    *string `json:"category,omitempty"`
	Description *string `json:"description,omitempty"`

	// TimeMs The amount of time to wait in milliseconds (max 30 seconds)
	TimeMs int     `json:"time_ms"`
	Type   *string `json:"type,omitempty"`
}

// WebSocketUrls defines model for WebSocketUrls.
type WebSocketUrls struct {
	// Cdp WebSocket URL to connect using CDP protocol
	Cdp string `json:"cdp"`

	// Logs WebSocket URL for live logs (obsveration / actions events)
	Logs string `json:"logs"`

	// Recording WebSocket URL for live session recording (screenshot stream)
	Recording string `json:"recording"`
}

// WorkflowScheduleCreateRequest defines model for WorkflowScheduleCreateRequest.
type WorkflowScheduleCreateRequest struct {
	Cron      string                  `json:"cron"`
	Variables *map[string]interface{} `json:"variables"`
}

// ListAgentsParams defines parameters for ListAgents.
type ListAgentsParams struct {
	// Page Page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// OnlyActive Whether to only return active sessions
	OnlyActive *bool `form:"only_active,omitempty" json:"only_active,omitempty"`

	// OnlySaved Whether to only return saved agents
	OnlySaved *bool `form:"only_saved,omitempty" json:"only_saved,omitempty"`

	// OnlyCurrentToken Whether to only return agents for the current token (apikey)
	OnlyCurrentToken    *bool   `form:"only_current_token,omitempty" json:"only_current_token,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// AgentStartParams defines parameters for AgentStart.
type AgentStartParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// AgentStatusParams defines parameters for AgentStatus.
type AgentStatusParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// AgentReplayParams defines parameters for AgentReplay.
type AgentReplayParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// AgentStopParams defines parameters for AgentStop.
type AgentStopParams struct {
	SessionId           string  `form:"session_id" json:"session_id"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// GetScriptParams defines parameters for GetScript.
type GetScriptParams struct {
	// AsWorkflow Whether to return code as standalone workflow or just relevant instructions
	AsWorkflow          bool    `form:"as_workflow" json:"as_workflow"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ListFunctionsParams defines parameters for ListFunctions.
type ListFunctionsParams struct {
	// Page Page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// OnlyActive Whether to only return active sessions
	OnlyActive *bool `form:"only_active,omitempty" json:"only_active,omitempty"`

	// OnlyCurrentToken Whether to only return sessions for the current token (apikey)
	OnlyCurrentToken    *bool   `form:"only_current_token,omitempty" json:"only_current_token,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionCreateParams defines parameters for FunctionCreate.
type FunctionCreateParams struct {
	// Restricted Whether to restrict the workflow code
	Restricted          *bool   `form:"restricted,omitempty" json:"restricted,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionDeleteParams defines parameters for FunctionDelete.
type FunctionDeleteParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionDownloadUrlParams defines parameters for FunctionDownloadUrl.
type FunctionDownloadUrlParams struct {
	Version *string `form:"version,omitempty" json:"version,omitempty"`

	// DecryptionKey The decryption key for the function
	DecryptionKey       *string `form:"decryption_key,omitempty" json:"decryption_key,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionUpdateParams defines parameters for FunctionUpdate.
type FunctionUpdateParams struct {
	// Version The version of the function to upload
	Version *string `form:"version,omitempty" json:"version,omitempty"`

	// Restricted Whether to restrict the function code
	Restricted          *bool   `form:"restricted,omitempty" json:"restricted,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionForkParams defines parameters for FunctionFork.
type FunctionForkParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ListFunctionRunsByFunctionIdParams defines parameters for ListFunctionRunsByFunctionId.
type ListFunctionRunsByFunctionIdParams struct {
	// Page Page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// OnlyActive Whether to only return active sessions
	OnlyActive *bool `form:"only_active,omitempty" json:"only_active,omitempty"`

	// OnlyCurrentToken Whether to only return sessions for the current token (apikey)
	OnlyCurrentToken    *bool   `form:"only_current_token,omitempty" json:"only_current_token,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionRunStartParams defines parameters for FunctionRunStart.
type FunctionRunStartParams struct {
	XNotteApiKey        string  `json:"x-notte-api-key"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionRunStopParams defines parameters for FunctionRunStop.
type FunctionRunStopParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionRunGetMetadataParams defines parameters for FunctionRunGetMetadata.
type FunctionRunGetMetadataParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionRunUpdateMetadataParams defines parameters for FunctionRunUpdateMetadata.
type FunctionRunUpdateMetadataParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionScheduleDeleteParams defines parameters for FunctionScheduleDelete.
type FunctionScheduleDeleteParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FunctionScheduleSetParams defines parameters for FunctionScheduleSet.
type FunctionScheduleSetParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ListPersonasParams defines parameters for ListPersonas.
type ListPersonasParams struct {
	// Page Page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// OnlyActive Whether to only return active sessions
	OnlyActive *bool `form:"only_active,omitempty" json:"only_active,omitempty"`

	// OnlyCurrentToken Whether to only return sessions for the current token (apikey)
	OnlyCurrentToken    *bool   `form:"only_current_token,omitempty" json:"only_current_token,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PersonaCreateParams defines parameters for PersonaCreate.
type PersonaCreateParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PersonaDeleteParams defines parameters for PersonaDelete.
type PersonaDeleteParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PersonaGetParams defines parameters for PersonaGet.
type PersonaGetParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PersonaEmailsListParams defines parameters for PersonaEmailsList.
type PersonaEmailsListParams struct {
	// Limit Maximum number of emails
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Timedelta Maximum time since email reception
	Timedelta *string `form:"timedelta,omitempty" json:"timedelta,omitempty"`

	// OnlyUnread Whether to only return unread messages
	OnlyUnread          *bool   `form:"only_unread,omitempty" json:"only_unread,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PersonaSmsListParams defines parameters for PersonaSmsList.
type PersonaSmsListParams struct {
	// Limit Maximum number of emails
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Timedelta Maximum time since email reception
	Timedelta *string `form:"timedelta,omitempty" json:"timedelta,omitempty"`

	// OnlyUnread Whether to only return unread messages
	OnlyUnread          *bool   `form:"only_unread,omitempty" json:"only_unread,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PersonaDeleteNumberParams defines parameters for PersonaDeleteNumber.
type PersonaDeleteNumberParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PersonaCreateNumberParams defines parameters for PersonaCreateNumber.
type PersonaCreateNumberParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ProfileListParams defines parameters for ProfileList.
type ProfileListParams struct {
	// Page Page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// Name Filter profiles by name
	Name                *string `form:"name,omitempty" json:"name,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ProfileCreateParams defines parameters for ProfileCreate.
type ProfileCreateParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ProfileDeleteParams defines parameters for ProfileDelete.
type ProfileDeleteParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ProfileGetParams defines parameters for ProfileGet.
type ProfileGetParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ScrapeWebpageParams defines parameters for ScrapeWebpage.
type ScrapeWebpageParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ScrapeFromHtmlParams defines parameters for ScrapeFromHtml.
type ScrapeFromHtmlParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ListSessionsParams defines parameters for ListSessions.
type ListSessionsParams struct {
	// Page Page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// OnlyActive Whether to only return active sessions
	OnlyActive *bool `form:"only_active,omitempty" json:"only_active,omitempty"`

	// OnlyCurrentToken Whether to only return sessions for the current token (apikey)
	OnlyCurrentToken    *bool   `form:"only_current_token,omitempty" json:"only_current_token,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// SessionStartParams defines parameters for SessionStart.
type SessionStartParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// SessionStatusParams defines parameters for SessionStatus.
type SessionStatusParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// SessionCookiesGetParams defines parameters for SessionCookiesGet.
type SessionCookiesGetParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// SessionCookiesSetParams defines parameters for SessionCookiesSet.
type SessionCookiesSetParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// SessionDebugInfoParams defines parameters for SessionDebugInfo.
type SessionDebugInfoParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// SessionNetworkLogsParams defines parameters for SessionNetworkLogs.
type SessionNetworkLogsParams struct {
	// Limit Maximum number of logs to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Download Whether to include download URLs for the logs
	Download            *bool   `form:"download,omitempty" json:"download,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// SessionOffsetParams defines parameters for SessionOffset.
type SessionOffsetParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PageExecuteJSONBody defines parameters for PageExecute.
type PageExecuteJSONBody struct {
	union json.RawMessage
}

// PageExecuteParams defines parameters for PageExecute.
type PageExecuteParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PageObserveParams defines parameters for PageObserve.
type PageObserveParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// PageScrapeParams defines parameters for PageScrape.
type PageScrapeParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// SessionReplayParams defines parameters for SessionReplay.
type SessionReplayParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// SessionStopParams defines parameters for SessionStop.
type SessionStopParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// GetSessionScriptParams defines parameters for GetSessionScript.
type GetSessionScriptParams struct {
	// AsWorkflow Whether to return code as standalone workflow or just relevant instructions
	AsWorkflow          bool    `form:"as_workflow" json:"as_workflow"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FileListUploadsParams defines parameters for FileListUploads.
type FileListUploadsParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FileUploadParams defines parameters for FileUpload.
type FileUploadParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FileListDownloadsParams defines parameters for FileListDownloads.
type FileListDownloadsParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FileDownloadParams defines parameters for FileDownload.
type FileDownloadParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// FileUploadDownloadedFileParams defines parameters for FileUploadDownloadedFile.
type FileUploadDownloadedFileParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// GetUsageParams defines parameters for GetUsage.
type GetUsageParams struct {
	// Period The montly period to get usage for, i.e May 2025
	Period              *string `form:"period,omitempty" json:"period,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// GetUsageLogsParams defines parameters for GetUsageLogs.
type GetUsageLogsParams struct {
	// Endpoint The endpoint to filter logs by
	Endpoint *string `form:"endpoint,omitempty" json:"endpoint,omitempty"`

	// Page Page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// OnlyActive Whether to only return active sessions
	OnlyActive *bool `form:"only_active,omitempty" json:"only_active,omitempty"`

	// OnlyCurrentToken Whether to only return sessions for the current token (apikey)
	OnlyCurrentToken    *bool   `form:"only_current_token,omitempty" json:"only_current_token,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// ListVaultsParams defines parameters for ListVaults.
type ListVaultsParams struct {
	// Page Page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// OnlyActive Whether to only return active sessions
	OnlyActive *bool `form:"only_active,omitempty" json:"only_active,omitempty"`

	// OnlyCurrentToken Whether to only return sessions for the current token (apikey)
	OnlyCurrentToken    *bool   `form:"only_current_token,omitempty" json:"only_current_token,omitempty"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultCreateParams defines parameters for VaultCreate.
type VaultCreateParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultDeleteParams defines parameters for VaultDelete.
type VaultDeleteParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultCredentialsListParams defines parameters for VaultCredentialsList.
type VaultCredentialsListParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultUpdateParams defines parameters for VaultUpdate.
type VaultUpdateParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultCreditCardDeleteParams defines parameters for VaultCreditCardDelete.
type VaultCreditCardDeleteParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultCreditCardGetParams defines parameters for VaultCreditCardGet.
type VaultCreditCardGetParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultCreditCardSetParams defines parameters for VaultCreditCardSet.
type VaultCreditCardSetParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultCredentialsDeleteParams defines parameters for VaultCredentialsDelete.
type VaultCredentialsDeleteParams struct {
	// Url URL upon which to get credentials
	Url                 string  `form:"url" json:"url"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultCredentialsGetParams defines parameters for VaultCredentialsGet.
type VaultCredentialsGetParams struct {
	// Url URL upon which to get credentials
	Url                 string  `form:"url" json:"url"`
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// VaultCredentialsAddParams defines parameters for VaultCredentialsAdd.
type VaultCredentialsAddParams struct {
	XNotteRequestOrigin *string `json:"x-notte-request-origin,omitempty"`
	XNotteSdkVersion    *string `json:"x-notte-sdk-version,omitempty"`
}

// AgentStartJSONRequestBody defines body for AgentStart for application/json ContentType.
type AgentStartJSONRequestBody = ApiAgentStartRequest

// FunctionCreateMultipartRequestBody defines body for FunctionCreate for multipart/form-data ContentType.
type FunctionCreateMultipartRequestBody = BodyFunctionCreateFunctionsPost

// FunctionUpdateMultipartRequestBody defines body for FunctionUpdate for multipart/form-data ContentType.
type FunctionUpdateMultipartRequestBody = BodyFunctionUpdateFunctionsFunctionIdPost

// FunctionRunUpdateMetadataJSONRequestBody defines body for FunctionRunUpdateMetadata for application/json ContentType.
type FunctionRunUpdateMetadataJSONRequestBody = FunctionRunUpdateRequest

// FunctionScheduleSetJSONRequestBody defines body for FunctionScheduleSet for application/json ContentType.
type FunctionScheduleSetJSONRequestBody = WorkflowScheduleCreateRequest

// PersonaCreateJSONRequestBody defines body for PersonaCreate for application/json ContentType.
type PersonaCreateJSONRequestBody = PersonaCreateRequest

// ProfileCreateJSONRequestBody defines body for ProfileCreate for application/json ContentType.
type ProfileCreateJSONRequestBody = ProfileCreateRequest

// ImprovePromptJSONRequestBody defines body for ImprovePrompt for application/json ContentType.
type ImprovePromptJSONRequestBody = ImprovePromptRequest

// NudgePromptJSONRequestBody defines body for NudgePrompt for application/json ContentType.
type NudgePromptJSONRequestBody = NudgePromptRequest

// ScrapeWebpageJSONRequestBody defines body for ScrapeWebpage for application/json ContentType.
type ScrapeWebpageJSONRequestBody = GlobalScrapeRequest

// ScrapeFromHtmlJSONRequestBody defines body for ScrapeFromHtml for application/json ContentType.
type ScrapeFromHtmlJSONRequestBody = ScrapeFromHtmlRequest

// SessionStartJSONRequestBody defines body for SessionStart for application/json ContentType.
type SessionStartJSONRequestBody = ApiSessionStartRequest

// SessionCookiesSetJSONRequestBody defines body for SessionCookiesSet for application/json ContentType.
type SessionCookiesSetJSONRequestBody = BodySessionCookiesSetSessionsSessionIdCookiesPost

// PageExecuteJSONRequestBody defines body for PageExecute for application/json ContentType.
type PageExecuteJSONRequestBody PageExecuteJSONBody

// PageObserveJSONRequestBody defines body for PageObserve for application/json ContentType.
type PageObserveJSONRequestBody = ObserveRequest

// PageScrapeJSONRequestBody defines body for PageScrape for application/json ContentType.
type PageScrapeJSONRequestBody = ScrapeRequest

// FileUploadMultipartRequestBody defines body for FileUpload for multipart/form-data ContentType.
type FileUploadMultipartRequestBody = BodyFileUploadStorageUploadsFilenamePost

// FileUploadDownloadedFileMultipartRequestBody defines body for FileUploadDownloadedFile for multipart/form-data ContentType.
type FileUploadDownloadedFileMultipartRequestBody = BodyFileUploadDownloadedFileStorageSessionIdDownloadsFilenamePost

// VaultCreateJSONRequestBody defines body for VaultCreate for application/json ContentType.
type VaultCreateJSONRequestBody = VaultCreateRequest

// VaultUpdateJSONRequestBody defines body for VaultUpdate for application/json ContentType.
type VaultUpdateJSONRequestBody = VaultUpdateRequest

// VaultCreditCardSetJSONRequestBody defines body for VaultCreditCardSet for application/json ContentType.
type VaultCreditCardSetJSONRequestBody = AddCreditCardRequest

// VaultCredentialsAddJSONRequestBody defines body for VaultCredentialsAdd for application/json ContentType.
type VaultCredentialsAddJSONRequestBody = AddCredentialsRequest

// AsFormFillAction returns the union data inside the ActionSpace_Actions_Item as a FormFillAction
func (t ActionSpace_Actions_Item) AsFormFillAction() (FormFillAction, error) {
	var body FormFillAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormFillAction overwrites any union data inside the ActionSpace_Actions_Item as the provided FormFillAction
func (t *ActionSpace_Actions_Item) FromFormFillAction(v FormFillAction) error {
	tmp := "form_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormFillAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided FormFillAction
func (t *ActionSpace_Actions_Item) MergeFormFillAction(v FormFillAction) error {
	tmp := "form_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGotoAction returns the union data inside the ActionSpace_Actions_Item as a GotoAction
func (t ActionSpace_Actions_Item) AsGotoAction() (GotoAction, error) {
	var body GotoAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGotoAction overwrites any union data inside the ActionSpace_Actions_Item as the provided GotoAction
func (t *ActionSpace_Actions_Item) FromGotoAction(v GotoAction) error {
	tmp := "goto"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGotoAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided GotoAction
func (t *ActionSpace_Actions_Item) MergeGotoAction(v GotoAction) error {
	tmp := "goto"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGotoNewTabAction returns the union data inside the ActionSpace_Actions_Item as a GotoNewTabAction
func (t ActionSpace_Actions_Item) AsGotoNewTabAction() (GotoNewTabAction, error) {
	var body GotoNewTabAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGotoNewTabAction overwrites any union data inside the ActionSpace_Actions_Item as the provided GotoNewTabAction
func (t *ActionSpace_Actions_Item) FromGotoNewTabAction(v GotoNewTabAction) error {
	tmp := "goto_new_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGotoNewTabAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided GotoNewTabAction
func (t *ActionSpace_Actions_Item) MergeGotoNewTabAction(v GotoNewTabAction) error {
	tmp := "goto_new_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCloseTabAction returns the union data inside the ActionSpace_Actions_Item as a CloseTabAction
func (t ActionSpace_Actions_Item) AsCloseTabAction() (CloseTabAction, error) {
	var body CloseTabAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCloseTabAction overwrites any union data inside the ActionSpace_Actions_Item as the provided CloseTabAction
func (t *ActionSpace_Actions_Item) FromCloseTabAction(v CloseTabAction) error {
	tmp := "close_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCloseTabAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided CloseTabAction
func (t *ActionSpace_Actions_Item) MergeCloseTabAction(v CloseTabAction) error {
	tmp := "close_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwitchTabAction returns the union data inside the ActionSpace_Actions_Item as a SwitchTabAction
func (t ActionSpace_Actions_Item) AsSwitchTabAction() (SwitchTabAction, error) {
	var body SwitchTabAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwitchTabAction overwrites any union data inside the ActionSpace_Actions_Item as the provided SwitchTabAction
func (t *ActionSpace_Actions_Item) FromSwitchTabAction(v SwitchTabAction) error {
	tmp := "switch_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwitchTabAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided SwitchTabAction
func (t *ActionSpace_Actions_Item) MergeSwitchTabAction(v SwitchTabAction) error {
	tmp := "switch_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoBackAction returns the union data inside the ActionSpace_Actions_Item as a GoBackAction
func (t ActionSpace_Actions_Item) AsGoBackAction() (GoBackAction, error) {
	var body GoBackAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoBackAction overwrites any union data inside the ActionSpace_Actions_Item as the provided GoBackAction
func (t *ActionSpace_Actions_Item) FromGoBackAction(v GoBackAction) error {
	tmp := "go_back"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoBackAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided GoBackAction
func (t *ActionSpace_Actions_Item) MergeGoBackAction(v GoBackAction) error {
	tmp := "go_back"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoForwardAction returns the union data inside the ActionSpace_Actions_Item as a GoForwardAction
func (t ActionSpace_Actions_Item) AsGoForwardAction() (GoForwardAction, error) {
	var body GoForwardAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoForwardAction overwrites any union data inside the ActionSpace_Actions_Item as the provided GoForwardAction
func (t *ActionSpace_Actions_Item) FromGoForwardAction(v GoForwardAction) error {
	tmp := "go_forward"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoForwardAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided GoForwardAction
func (t *ActionSpace_Actions_Item) MergeGoForwardAction(v GoForwardAction) error {
	tmp := "go_forward"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReloadAction returns the union data inside the ActionSpace_Actions_Item as a ReloadAction
func (t ActionSpace_Actions_Item) AsReloadAction() (ReloadAction, error) {
	var body ReloadAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReloadAction overwrites any union data inside the ActionSpace_Actions_Item as the provided ReloadAction
func (t *ActionSpace_Actions_Item) FromReloadAction(v ReloadAction) error {
	tmp := "reload"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReloadAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided ReloadAction
func (t *ActionSpace_Actions_Item) MergeReloadAction(v ReloadAction) error {
	tmp := "reload"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWaitAction returns the union data inside the ActionSpace_Actions_Item as a WaitAction
func (t ActionSpace_Actions_Item) AsWaitAction() (WaitAction, error) {
	var body WaitAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWaitAction overwrites any union data inside the ActionSpace_Actions_Item as the provided WaitAction
func (t *ActionSpace_Actions_Item) FromWaitAction(v WaitAction) error {
	tmp := "wait"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWaitAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided WaitAction
func (t *ActionSpace_Actions_Item) MergeWaitAction(v WaitAction) error {
	tmp := "wait"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPressKeyAction returns the union data inside the ActionSpace_Actions_Item as a PressKeyAction
func (t ActionSpace_Actions_Item) AsPressKeyAction() (PressKeyAction, error) {
	var body PressKeyAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPressKeyAction overwrites any union data inside the ActionSpace_Actions_Item as the provided PressKeyAction
func (t *ActionSpace_Actions_Item) FromPressKeyAction(v PressKeyAction) error {
	tmp := "press_key"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePressKeyAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided PressKeyAction
func (t *ActionSpace_Actions_Item) MergePressKeyAction(v PressKeyAction) error {
	tmp := "press_key"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScrollUpAction returns the union data inside the ActionSpace_Actions_Item as a ScrollUpAction
func (t ActionSpace_Actions_Item) AsScrollUpAction() (ScrollUpAction, error) {
	var body ScrollUpAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollUpAction overwrites any union data inside the ActionSpace_Actions_Item as the provided ScrollUpAction
func (t *ActionSpace_Actions_Item) FromScrollUpAction(v ScrollUpAction) error {
	tmp := "scroll_up"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollUpAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided ScrollUpAction
func (t *ActionSpace_Actions_Item) MergeScrollUpAction(v ScrollUpAction) error {
	tmp := "scroll_up"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScrollDownAction returns the union data inside the ActionSpace_Actions_Item as a ScrollDownAction
func (t ActionSpace_Actions_Item) AsScrollDownAction() (ScrollDownAction, error) {
	var body ScrollDownAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollDownAction overwrites any union data inside the ActionSpace_Actions_Item as the provided ScrollDownAction
func (t *ActionSpace_Actions_Item) FromScrollDownAction(v ScrollDownAction) error {
	tmp := "scroll_down"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollDownAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided ScrollDownAction
func (t *ActionSpace_Actions_Item) MergeScrollDownAction(v ScrollDownAction) error {
	tmp := "scroll_down"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCaptchaSolveAction returns the union data inside the ActionSpace_Actions_Item as a CaptchaSolveAction
func (t ActionSpace_Actions_Item) AsCaptchaSolveAction() (CaptchaSolveAction, error) {
	var body CaptchaSolveAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCaptchaSolveAction overwrites any union data inside the ActionSpace_Actions_Item as the provided CaptchaSolveAction
func (t *ActionSpace_Actions_Item) FromCaptchaSolveAction(v CaptchaSolveAction) error {
	tmp := "captcha_solve"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCaptchaSolveAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided CaptchaSolveAction
func (t *ActionSpace_Actions_Item) MergeCaptchaSolveAction(v CaptchaSolveAction) error {
	tmp := "captcha_solve"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHelpAction returns the union data inside the ActionSpace_Actions_Item as a HelpAction
func (t ActionSpace_Actions_Item) AsHelpAction() (HelpAction, error) {
	var body HelpAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHelpAction overwrites any union data inside the ActionSpace_Actions_Item as the provided HelpAction
func (t *ActionSpace_Actions_Item) FromHelpAction(v HelpAction) error {
	tmp := "help"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHelpAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided HelpAction
func (t *ActionSpace_Actions_Item) MergeHelpAction(v HelpAction) error {
	tmp := "help"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCompletionAction returns the union data inside the ActionSpace_Actions_Item as a CompletionAction
func (t ActionSpace_Actions_Item) AsCompletionAction() (CompletionAction, error) {
	var body CompletionAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletionAction overwrites any union data inside the ActionSpace_Actions_Item as the provided CompletionAction
func (t *ActionSpace_Actions_Item) FromCompletionAction(v CompletionAction) error {
	tmp := "completion"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletionAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided CompletionAction
func (t *ActionSpace_Actions_Item) MergeCompletionAction(v CompletionAction) error {
	tmp := "completion"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScrapeAction returns the union data inside the ActionSpace_Actions_Item as a ScrapeAction
func (t ActionSpace_Actions_Item) AsScrapeAction() (ScrapeAction, error) {
	var body ScrapeAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrapeAction overwrites any union data inside the ActionSpace_Actions_Item as the provided ScrapeAction
func (t *ActionSpace_Actions_Item) FromScrapeAction(v ScrapeAction) error {
	tmp := "scrape"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrapeAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided ScrapeAction
func (t *ActionSpace_Actions_Item) MergeScrapeAction(v ScrapeAction) error {
	tmp := "scrape"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailReadAction returns the union data inside the ActionSpace_Actions_Item as a EmailReadAction
func (t ActionSpace_Actions_Item) AsEmailReadAction() (EmailReadAction, error) {
	var body EmailReadAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailReadAction overwrites any union data inside the ActionSpace_Actions_Item as the provided EmailReadAction
func (t *ActionSpace_Actions_Item) FromEmailReadAction(v EmailReadAction) error {
	tmp := "email_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailReadAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided EmailReadAction
func (t *ActionSpace_Actions_Item) MergeEmailReadAction(v EmailReadAction) error {
	tmp := "email_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsReadAction returns the union data inside the ActionSpace_Actions_Item as a SmsReadAction
func (t ActionSpace_Actions_Item) AsSmsReadAction() (SmsReadAction, error) {
	var body SmsReadAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsReadAction overwrites any union data inside the ActionSpace_Actions_Item as the provided SmsReadAction
func (t *ActionSpace_Actions_Item) FromSmsReadAction(v SmsReadAction) error {
	tmp := "sms_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsReadAction performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided SmsReadAction
func (t *ActionSpace_Actions_Item) MergeSmsReadAction(v SmsReadAction) error {
	tmp := "sms_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsClickActionOutput returns the union data inside the ActionSpace_Actions_Item as a ClickActionOutput
func (t ActionSpace_Actions_Item) AsClickActionOutput() (ClickActionOutput, error) {
	var body ClickActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClickActionOutput overwrites any union data inside the ActionSpace_Actions_Item as the provided ClickActionOutput
func (t *ActionSpace_Actions_Item) FromClickActionOutput(v ClickActionOutput) error {
	tmp := "click"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClickActionOutput performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided ClickActionOutput
func (t *ActionSpace_Actions_Item) MergeClickActionOutput(v ClickActionOutput) error {
	tmp := "click"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFillActionOutput returns the union data inside the ActionSpace_Actions_Item as a FillActionOutput
func (t ActionSpace_Actions_Item) AsFillActionOutput() (FillActionOutput, error) {
	var body FillActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillActionOutput overwrites any union data inside the ActionSpace_Actions_Item as the provided FillActionOutput
func (t *ActionSpace_Actions_Item) FromFillActionOutput(v FillActionOutput) error {
	tmp := "fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillActionOutput performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided FillActionOutput
func (t *ActionSpace_Actions_Item) MergeFillActionOutput(v FillActionOutput) error {
	tmp := "fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiFactorFillActionOutput returns the union data inside the ActionSpace_Actions_Item as a MultiFactorFillActionOutput
func (t ActionSpace_Actions_Item) AsMultiFactorFillActionOutput() (MultiFactorFillActionOutput, error) {
	var body MultiFactorFillActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiFactorFillActionOutput overwrites any union data inside the ActionSpace_Actions_Item as the provided MultiFactorFillActionOutput
func (t *ActionSpace_Actions_Item) FromMultiFactorFillActionOutput(v MultiFactorFillActionOutput) error {
	tmp := "multi_factor_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiFactorFillActionOutput performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided MultiFactorFillActionOutput
func (t *ActionSpace_Actions_Item) MergeMultiFactorFillActionOutput(v MultiFactorFillActionOutput) error {
	tmp := "multi_factor_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFallbackFillActionOutput returns the union data inside the ActionSpace_Actions_Item as a FallbackFillActionOutput
func (t ActionSpace_Actions_Item) AsFallbackFillActionOutput() (FallbackFillActionOutput, error) {
	var body FallbackFillActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFallbackFillActionOutput overwrites any union data inside the ActionSpace_Actions_Item as the provided FallbackFillActionOutput
func (t *ActionSpace_Actions_Item) FromFallbackFillActionOutput(v FallbackFillActionOutput) error {
	tmp := "fallback_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFallbackFillActionOutput performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided FallbackFillActionOutput
func (t *ActionSpace_Actions_Item) MergeFallbackFillActionOutput(v FallbackFillActionOutput) error {
	tmp := "fallback_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCheckActionOutput returns the union data inside the ActionSpace_Actions_Item as a CheckActionOutput
func (t ActionSpace_Actions_Item) AsCheckActionOutput() (CheckActionOutput, error) {
	var body CheckActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCheckActionOutput overwrites any union data inside the ActionSpace_Actions_Item as the provided CheckActionOutput
func (t *ActionSpace_Actions_Item) FromCheckActionOutput(v CheckActionOutput) error {
	tmp := "check"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCheckActionOutput performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided CheckActionOutput
func (t *ActionSpace_Actions_Item) MergeCheckActionOutput(v CheckActionOutput) error {
	tmp := "check"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectDropdownOptionActionOutput returns the union data inside the ActionSpace_Actions_Item as a SelectDropdownOptionActionOutput
func (t ActionSpace_Actions_Item) AsSelectDropdownOptionActionOutput() (SelectDropdownOptionActionOutput, error) {
	var body SelectDropdownOptionActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectDropdownOptionActionOutput overwrites any union data inside the ActionSpace_Actions_Item as the provided SelectDropdownOptionActionOutput
func (t *ActionSpace_Actions_Item) FromSelectDropdownOptionActionOutput(v SelectDropdownOptionActionOutput) error {
	tmp := "select_dropdown_option"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectDropdownOptionActionOutput performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided SelectDropdownOptionActionOutput
func (t *ActionSpace_Actions_Item) MergeSelectDropdownOptionActionOutput(v SelectDropdownOptionActionOutput) error {
	tmp := "select_dropdown_option"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUploadFileActionOutput returns the union data inside the ActionSpace_Actions_Item as a UploadFileActionOutput
func (t ActionSpace_Actions_Item) AsUploadFileActionOutput() (UploadFileActionOutput, error) {
	var body UploadFileActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUploadFileActionOutput overwrites any union data inside the ActionSpace_Actions_Item as the provided UploadFileActionOutput
func (t *ActionSpace_Actions_Item) FromUploadFileActionOutput(v UploadFileActionOutput) error {
	tmp := "upload_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUploadFileActionOutput performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided UploadFileActionOutput
func (t *ActionSpace_Actions_Item) MergeUploadFileActionOutput(v UploadFileActionOutput) error {
	tmp := "upload_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDownloadFileActionOutput returns the union data inside the ActionSpace_Actions_Item as a DownloadFileActionOutput
func (t ActionSpace_Actions_Item) AsDownloadFileActionOutput() (DownloadFileActionOutput, error) {
	var body DownloadFileActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDownloadFileActionOutput overwrites any union data inside the ActionSpace_Actions_Item as the provided DownloadFileActionOutput
func (t *ActionSpace_Actions_Item) FromDownloadFileActionOutput(v DownloadFileActionOutput) error {
	tmp := "download_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDownloadFileActionOutput performs a merge with any union data inside the ActionSpace_Actions_Item, using the provided DownloadFileActionOutput
func (t *ActionSpace_Actions_Item) MergeDownloadFileActionOutput(v DownloadFileActionOutput) error {
	tmp := "download_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ActionSpace_Actions_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ActionSpace_Actions_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "captcha_solve":
		return t.AsCaptchaSolveAction()
	case "check":
		return t.AsCheckActionOutput()
	case "click":
		return t.AsClickActionOutput()
	case "close_tab":
		return t.AsCloseTabAction()
	case "completion":
		return t.AsCompletionAction()
	case "download_file":
		return t.AsDownloadFileActionOutput()
	case "email_read":
		return t.AsEmailReadAction()
	case "fallback_fill":
		return t.AsFallbackFillActionOutput()
	case "fill":
		return t.AsFillActionOutput()
	case "form_fill":
		return t.AsFormFillAction()
	case "go_back":
		return t.AsGoBackAction()
	case "go_forward":
		return t.AsGoForwardAction()
	case "goto":
		return t.AsGotoAction()
	case "goto_new_tab":
		return t.AsGotoNewTabAction()
	case "help":
		return t.AsHelpAction()
	case "multi_factor_fill":
		return t.AsMultiFactorFillActionOutput()
	case "press_key":
		return t.AsPressKeyAction()
	case "reload":
		return t.AsReloadAction()
	case "scrape":
		return t.AsScrapeAction()
	case "scroll_down":
		return t.AsScrollDownAction()
	case "scroll_up":
		return t.AsScrollUpAction()
	case "select_dropdown_option":
		return t.AsSelectDropdownOptionActionOutput()
	case "sms_read":
		return t.AsSmsReadAction()
	case "switch_tab":
		return t.AsSwitchTabAction()
	case "upload_file":
		return t.AsUploadFileActionOutput()
	case "wait":
		return t.AsWaitAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ActionSpace_Actions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ActionSpace_Actions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFormFillAction returns the union data inside the ActionSpace_BrowserActions_Item as a FormFillAction
func (t ActionSpace_BrowserActions_Item) AsFormFillAction() (FormFillAction, error) {
	var body FormFillAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormFillAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided FormFillAction
func (t *ActionSpace_BrowserActions_Item) FromFormFillAction(v FormFillAction) error {
	tmp := "form_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormFillAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided FormFillAction
func (t *ActionSpace_BrowserActions_Item) MergeFormFillAction(v FormFillAction) error {
	tmp := "form_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGotoAction returns the union data inside the ActionSpace_BrowserActions_Item as a GotoAction
func (t ActionSpace_BrowserActions_Item) AsGotoAction() (GotoAction, error) {
	var body GotoAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGotoAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided GotoAction
func (t *ActionSpace_BrowserActions_Item) FromGotoAction(v GotoAction) error {
	tmp := "goto"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGotoAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided GotoAction
func (t *ActionSpace_BrowserActions_Item) MergeGotoAction(v GotoAction) error {
	tmp := "goto"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGotoNewTabAction returns the union data inside the ActionSpace_BrowserActions_Item as a GotoNewTabAction
func (t ActionSpace_BrowserActions_Item) AsGotoNewTabAction() (GotoNewTabAction, error) {
	var body GotoNewTabAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGotoNewTabAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided GotoNewTabAction
func (t *ActionSpace_BrowserActions_Item) FromGotoNewTabAction(v GotoNewTabAction) error {
	tmp := "goto_new_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGotoNewTabAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided GotoNewTabAction
func (t *ActionSpace_BrowserActions_Item) MergeGotoNewTabAction(v GotoNewTabAction) error {
	tmp := "goto_new_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCloseTabAction returns the union data inside the ActionSpace_BrowserActions_Item as a CloseTabAction
func (t ActionSpace_BrowserActions_Item) AsCloseTabAction() (CloseTabAction, error) {
	var body CloseTabAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCloseTabAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided CloseTabAction
func (t *ActionSpace_BrowserActions_Item) FromCloseTabAction(v CloseTabAction) error {
	tmp := "close_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCloseTabAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided CloseTabAction
func (t *ActionSpace_BrowserActions_Item) MergeCloseTabAction(v CloseTabAction) error {
	tmp := "close_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwitchTabAction returns the union data inside the ActionSpace_BrowserActions_Item as a SwitchTabAction
func (t ActionSpace_BrowserActions_Item) AsSwitchTabAction() (SwitchTabAction, error) {
	var body SwitchTabAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwitchTabAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided SwitchTabAction
func (t *ActionSpace_BrowserActions_Item) FromSwitchTabAction(v SwitchTabAction) error {
	tmp := "switch_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwitchTabAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided SwitchTabAction
func (t *ActionSpace_BrowserActions_Item) MergeSwitchTabAction(v SwitchTabAction) error {
	tmp := "switch_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoBackAction returns the union data inside the ActionSpace_BrowserActions_Item as a GoBackAction
func (t ActionSpace_BrowserActions_Item) AsGoBackAction() (GoBackAction, error) {
	var body GoBackAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoBackAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided GoBackAction
func (t *ActionSpace_BrowserActions_Item) FromGoBackAction(v GoBackAction) error {
	tmp := "go_back"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoBackAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided GoBackAction
func (t *ActionSpace_BrowserActions_Item) MergeGoBackAction(v GoBackAction) error {
	tmp := "go_back"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoForwardAction returns the union data inside the ActionSpace_BrowserActions_Item as a GoForwardAction
func (t ActionSpace_BrowserActions_Item) AsGoForwardAction() (GoForwardAction, error) {
	var body GoForwardAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoForwardAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided GoForwardAction
func (t *ActionSpace_BrowserActions_Item) FromGoForwardAction(v GoForwardAction) error {
	tmp := "go_forward"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoForwardAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided GoForwardAction
func (t *ActionSpace_BrowserActions_Item) MergeGoForwardAction(v GoForwardAction) error {
	tmp := "go_forward"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReloadAction returns the union data inside the ActionSpace_BrowserActions_Item as a ReloadAction
func (t ActionSpace_BrowserActions_Item) AsReloadAction() (ReloadAction, error) {
	var body ReloadAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReloadAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided ReloadAction
func (t *ActionSpace_BrowserActions_Item) FromReloadAction(v ReloadAction) error {
	tmp := "reload"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReloadAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided ReloadAction
func (t *ActionSpace_BrowserActions_Item) MergeReloadAction(v ReloadAction) error {
	tmp := "reload"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWaitAction returns the union data inside the ActionSpace_BrowserActions_Item as a WaitAction
func (t ActionSpace_BrowserActions_Item) AsWaitAction() (WaitAction, error) {
	var body WaitAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWaitAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided WaitAction
func (t *ActionSpace_BrowserActions_Item) FromWaitAction(v WaitAction) error {
	tmp := "wait"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWaitAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided WaitAction
func (t *ActionSpace_BrowserActions_Item) MergeWaitAction(v WaitAction) error {
	tmp := "wait"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPressKeyAction returns the union data inside the ActionSpace_BrowserActions_Item as a PressKeyAction
func (t ActionSpace_BrowserActions_Item) AsPressKeyAction() (PressKeyAction, error) {
	var body PressKeyAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPressKeyAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided PressKeyAction
func (t *ActionSpace_BrowserActions_Item) FromPressKeyAction(v PressKeyAction) error {
	tmp := "press_key"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePressKeyAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided PressKeyAction
func (t *ActionSpace_BrowserActions_Item) MergePressKeyAction(v PressKeyAction) error {
	tmp := "press_key"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScrollUpAction returns the union data inside the ActionSpace_BrowserActions_Item as a ScrollUpAction
func (t ActionSpace_BrowserActions_Item) AsScrollUpAction() (ScrollUpAction, error) {
	var body ScrollUpAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollUpAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided ScrollUpAction
func (t *ActionSpace_BrowserActions_Item) FromScrollUpAction(v ScrollUpAction) error {
	tmp := "scroll_up"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollUpAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided ScrollUpAction
func (t *ActionSpace_BrowserActions_Item) MergeScrollUpAction(v ScrollUpAction) error {
	tmp := "scroll_up"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScrollDownAction returns the union data inside the ActionSpace_BrowserActions_Item as a ScrollDownAction
func (t ActionSpace_BrowserActions_Item) AsScrollDownAction() (ScrollDownAction, error) {
	var body ScrollDownAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollDownAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided ScrollDownAction
func (t *ActionSpace_BrowserActions_Item) FromScrollDownAction(v ScrollDownAction) error {
	tmp := "scroll_down"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollDownAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided ScrollDownAction
func (t *ActionSpace_BrowserActions_Item) MergeScrollDownAction(v ScrollDownAction) error {
	tmp := "scroll_down"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCaptchaSolveAction returns the union data inside the ActionSpace_BrowserActions_Item as a CaptchaSolveAction
func (t ActionSpace_BrowserActions_Item) AsCaptchaSolveAction() (CaptchaSolveAction, error) {
	var body CaptchaSolveAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCaptchaSolveAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided CaptchaSolveAction
func (t *ActionSpace_BrowserActions_Item) FromCaptchaSolveAction(v CaptchaSolveAction) error {
	tmp := "captcha_solve"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCaptchaSolveAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided CaptchaSolveAction
func (t *ActionSpace_BrowserActions_Item) MergeCaptchaSolveAction(v CaptchaSolveAction) error {
	tmp := "captcha_solve"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHelpAction returns the union data inside the ActionSpace_BrowserActions_Item as a HelpAction
func (t ActionSpace_BrowserActions_Item) AsHelpAction() (HelpAction, error) {
	var body HelpAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHelpAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided HelpAction
func (t *ActionSpace_BrowserActions_Item) FromHelpAction(v HelpAction) error {
	tmp := "help"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHelpAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided HelpAction
func (t *ActionSpace_BrowserActions_Item) MergeHelpAction(v HelpAction) error {
	tmp := "help"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCompletionAction returns the union data inside the ActionSpace_BrowserActions_Item as a CompletionAction
func (t ActionSpace_BrowserActions_Item) AsCompletionAction() (CompletionAction, error) {
	var body CompletionAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletionAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided CompletionAction
func (t *ActionSpace_BrowserActions_Item) FromCompletionAction(v CompletionAction) error {
	tmp := "completion"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletionAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided CompletionAction
func (t *ActionSpace_BrowserActions_Item) MergeCompletionAction(v CompletionAction) error {
	tmp := "completion"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScrapeAction returns the union data inside the ActionSpace_BrowserActions_Item as a ScrapeAction
func (t ActionSpace_BrowserActions_Item) AsScrapeAction() (ScrapeAction, error) {
	var body ScrapeAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrapeAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided ScrapeAction
func (t *ActionSpace_BrowserActions_Item) FromScrapeAction(v ScrapeAction) error {
	tmp := "scrape"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrapeAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided ScrapeAction
func (t *ActionSpace_BrowserActions_Item) MergeScrapeAction(v ScrapeAction) error {
	tmp := "scrape"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailReadAction returns the union data inside the ActionSpace_BrowserActions_Item as a EmailReadAction
func (t ActionSpace_BrowserActions_Item) AsEmailReadAction() (EmailReadAction, error) {
	var body EmailReadAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailReadAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided EmailReadAction
func (t *ActionSpace_BrowserActions_Item) FromEmailReadAction(v EmailReadAction) error {
	tmp := "email_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailReadAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided EmailReadAction
func (t *ActionSpace_BrowserActions_Item) MergeEmailReadAction(v EmailReadAction) error {
	tmp := "email_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsReadAction returns the union data inside the ActionSpace_BrowserActions_Item as a SmsReadAction
func (t ActionSpace_BrowserActions_Item) AsSmsReadAction() (SmsReadAction, error) {
	var body SmsReadAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsReadAction overwrites any union data inside the ActionSpace_BrowserActions_Item as the provided SmsReadAction
func (t *ActionSpace_BrowserActions_Item) FromSmsReadAction(v SmsReadAction) error {
	tmp := "sms_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsReadAction performs a merge with any union data inside the ActionSpace_BrowserActions_Item, using the provided SmsReadAction
func (t *ActionSpace_BrowserActions_Item) MergeSmsReadAction(v SmsReadAction) error {
	tmp := "sms_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ActionSpace_BrowserActions_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ActionSpace_BrowserActions_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "captcha_solve":
		return t.AsCaptchaSolveAction()
	case "close_tab":
		return t.AsCloseTabAction()
	case "completion":
		return t.AsCompletionAction()
	case "email_read":
		return t.AsEmailReadAction()
	case "form_fill":
		return t.AsFormFillAction()
	case "go_back":
		return t.AsGoBackAction()
	case "go_forward":
		return t.AsGoForwardAction()
	case "goto":
		return t.AsGotoAction()
	case "goto_new_tab":
		return t.AsGotoNewTabAction()
	case "help":
		return t.AsHelpAction()
	case "press_key":
		return t.AsPressKeyAction()
	case "reload":
		return t.AsReloadAction()
	case "scrape":
		return t.AsScrapeAction()
	case "scroll_down":
		return t.AsScrollDownAction()
	case "scroll_up":
		return t.AsScrollUpAction()
	case "sms_read":
		return t.AsSmsReadAction()
	case "switch_tab":
		return t.AsSwitchTabAction()
	case "wait":
		return t.AsWaitAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ActionSpace_BrowserActions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ActionSpace_BrowserActions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsClickActionOutput returns the union data inside the ActionSpace_InteractionActions_Item as a ClickActionOutput
func (t ActionSpace_InteractionActions_Item) AsClickActionOutput() (ClickActionOutput, error) {
	var body ClickActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClickActionOutput overwrites any union data inside the ActionSpace_InteractionActions_Item as the provided ClickActionOutput
func (t *ActionSpace_InteractionActions_Item) FromClickActionOutput(v ClickActionOutput) error {
	tmp := "click"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClickActionOutput performs a merge with any union data inside the ActionSpace_InteractionActions_Item, using the provided ClickActionOutput
func (t *ActionSpace_InteractionActions_Item) MergeClickActionOutput(v ClickActionOutput) error {
	tmp := "click"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFillActionOutput returns the union data inside the ActionSpace_InteractionActions_Item as a FillActionOutput
func (t ActionSpace_InteractionActions_Item) AsFillActionOutput() (FillActionOutput, error) {
	var body FillActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillActionOutput overwrites any union data inside the ActionSpace_InteractionActions_Item as the provided FillActionOutput
func (t *ActionSpace_InteractionActions_Item) FromFillActionOutput(v FillActionOutput) error {
	tmp := "fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillActionOutput performs a merge with any union data inside the ActionSpace_InteractionActions_Item, using the provided FillActionOutput
func (t *ActionSpace_InteractionActions_Item) MergeFillActionOutput(v FillActionOutput) error {
	tmp := "fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiFactorFillActionOutput returns the union data inside the ActionSpace_InteractionActions_Item as a MultiFactorFillActionOutput
func (t ActionSpace_InteractionActions_Item) AsMultiFactorFillActionOutput() (MultiFactorFillActionOutput, error) {
	var body MultiFactorFillActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiFactorFillActionOutput overwrites any union data inside the ActionSpace_InteractionActions_Item as the provided MultiFactorFillActionOutput
func (t *ActionSpace_InteractionActions_Item) FromMultiFactorFillActionOutput(v MultiFactorFillActionOutput) error {
	tmp := "multi_factor_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiFactorFillActionOutput performs a merge with any union data inside the ActionSpace_InteractionActions_Item, using the provided MultiFactorFillActionOutput
func (t *ActionSpace_InteractionActions_Item) MergeMultiFactorFillActionOutput(v MultiFactorFillActionOutput) error {
	tmp := "multi_factor_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFallbackFillActionOutput returns the union data inside the ActionSpace_InteractionActions_Item as a FallbackFillActionOutput
func (t ActionSpace_InteractionActions_Item) AsFallbackFillActionOutput() (FallbackFillActionOutput, error) {
	var body FallbackFillActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFallbackFillActionOutput overwrites any union data inside the ActionSpace_InteractionActions_Item as the provided FallbackFillActionOutput
func (t *ActionSpace_InteractionActions_Item) FromFallbackFillActionOutput(v FallbackFillActionOutput) error {
	tmp := "fallback_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFallbackFillActionOutput performs a merge with any union data inside the ActionSpace_InteractionActions_Item, using the provided FallbackFillActionOutput
func (t *ActionSpace_InteractionActions_Item) MergeFallbackFillActionOutput(v FallbackFillActionOutput) error {
	tmp := "fallback_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCheckActionOutput returns the union data inside the ActionSpace_InteractionActions_Item as a CheckActionOutput
func (t ActionSpace_InteractionActions_Item) AsCheckActionOutput() (CheckActionOutput, error) {
	var body CheckActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCheckActionOutput overwrites any union data inside the ActionSpace_InteractionActions_Item as the provided CheckActionOutput
func (t *ActionSpace_InteractionActions_Item) FromCheckActionOutput(v CheckActionOutput) error {
	tmp := "check"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCheckActionOutput performs a merge with any union data inside the ActionSpace_InteractionActions_Item, using the provided CheckActionOutput
func (t *ActionSpace_InteractionActions_Item) MergeCheckActionOutput(v CheckActionOutput) error {
	tmp := "check"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectDropdownOptionActionOutput returns the union data inside the ActionSpace_InteractionActions_Item as a SelectDropdownOptionActionOutput
func (t ActionSpace_InteractionActions_Item) AsSelectDropdownOptionActionOutput() (SelectDropdownOptionActionOutput, error) {
	var body SelectDropdownOptionActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectDropdownOptionActionOutput overwrites any union data inside the ActionSpace_InteractionActions_Item as the provided SelectDropdownOptionActionOutput
func (t *ActionSpace_InteractionActions_Item) FromSelectDropdownOptionActionOutput(v SelectDropdownOptionActionOutput) error {
	tmp := "select_dropdown_option"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectDropdownOptionActionOutput performs a merge with any union data inside the ActionSpace_InteractionActions_Item, using the provided SelectDropdownOptionActionOutput
func (t *ActionSpace_InteractionActions_Item) MergeSelectDropdownOptionActionOutput(v SelectDropdownOptionActionOutput) error {
	tmp := "select_dropdown_option"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUploadFileActionOutput returns the union data inside the ActionSpace_InteractionActions_Item as a UploadFileActionOutput
func (t ActionSpace_InteractionActions_Item) AsUploadFileActionOutput() (UploadFileActionOutput, error) {
	var body UploadFileActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUploadFileActionOutput overwrites any union data inside the ActionSpace_InteractionActions_Item as the provided UploadFileActionOutput
func (t *ActionSpace_InteractionActions_Item) FromUploadFileActionOutput(v UploadFileActionOutput) error {
	tmp := "upload_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUploadFileActionOutput performs a merge with any union data inside the ActionSpace_InteractionActions_Item, using the provided UploadFileActionOutput
func (t *ActionSpace_InteractionActions_Item) MergeUploadFileActionOutput(v UploadFileActionOutput) error {
	tmp := "upload_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDownloadFileActionOutput returns the union data inside the ActionSpace_InteractionActions_Item as a DownloadFileActionOutput
func (t ActionSpace_InteractionActions_Item) AsDownloadFileActionOutput() (DownloadFileActionOutput, error) {
	var body DownloadFileActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDownloadFileActionOutput overwrites any union data inside the ActionSpace_InteractionActions_Item as the provided DownloadFileActionOutput
func (t *ActionSpace_InteractionActions_Item) FromDownloadFileActionOutput(v DownloadFileActionOutput) error {
	tmp := "download_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDownloadFileActionOutput performs a merge with any union data inside the ActionSpace_InteractionActions_Item, using the provided DownloadFileActionOutput
func (t *ActionSpace_InteractionActions_Item) MergeDownloadFileActionOutput(v DownloadFileActionOutput) error {
	tmp := "download_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ActionSpace_InteractionActions_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ActionSpace_InteractionActions_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "check":
		return t.AsCheckActionOutput()
	case "click":
		return t.AsClickActionOutput()
	case "download_file":
		return t.AsDownloadFileActionOutput()
	case "fallback_fill":
		return t.AsFallbackFillActionOutput()
	case "fill":
		return t.AsFillActionOutput()
	case "multi_factor_fill":
		return t.AsMultiFactorFillActionOutput()
	case "select_dropdown_option":
		return t.AsSelectDropdownOptionActionOutput()
	case "upload_file":
		return t.AsUploadFileActionOutput()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ActionSpace_InteractionActions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ActionSpace_InteractionActions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLlmModel returns the union data inside the ApiAgentStartRequest_ReasoningModel as a LlmModel
func (t ApiAgentStartRequest_ReasoningModel) AsLlmModel() (LlmModel, error) {
	var body LlmModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLlmModel overwrites any union data inside the ApiAgentStartRequest_ReasoningModel as the provided LlmModel
func (t *ApiAgentStartRequest_ReasoningModel) FromLlmModel(v LlmModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLlmModel performs a merge with any union data inside the ApiAgentStartRequest_ReasoningModel, using the provided LlmModel
func (t *ApiAgentStartRequest_ReasoningModel) MergeLlmModel(v LlmModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsApiAgentStartRequestReasoningModel1 returns the union data inside the ApiAgentStartRequest_ReasoningModel as a ApiAgentStartRequestReasoningModel1
func (t ApiAgentStartRequest_ReasoningModel) AsApiAgentStartRequestReasoningModel1() (ApiAgentStartRequestReasoningModel1, error) {
	var body ApiAgentStartRequestReasoningModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiAgentStartRequestReasoningModel1 overwrites any union data inside the ApiAgentStartRequest_ReasoningModel as the provided ApiAgentStartRequestReasoningModel1
func (t *ApiAgentStartRequest_ReasoningModel) FromApiAgentStartRequestReasoningModel1(v ApiAgentStartRequestReasoningModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiAgentStartRequestReasoningModel1 performs a merge with any union data inside the ApiAgentStartRequest_ReasoningModel, using the provided ApiAgentStartRequestReasoningModel1
func (t *ApiAgentStartRequest_ReasoningModel) MergeApiAgentStartRequestReasoningModel1(v ApiAgentStartRequestReasoningModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiAgentStartRequest_ReasoningModel) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiAgentStartRequest_ReasoningModel) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFormFillAction returns the union data inside the ApiExecutionResponse_Action as a FormFillAction
func (t ApiExecutionResponse_Action) AsFormFillAction() (FormFillAction, error) {
	var body FormFillAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormFillAction overwrites any union data inside the ApiExecutionResponse_Action as the provided FormFillAction
func (t *ApiExecutionResponse_Action) FromFormFillAction(v FormFillAction) error {
	tmp := "form_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormFillAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided FormFillAction
func (t *ApiExecutionResponse_Action) MergeFormFillAction(v FormFillAction) error {
	tmp := "form_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGotoAction returns the union data inside the ApiExecutionResponse_Action as a GotoAction
func (t ApiExecutionResponse_Action) AsGotoAction() (GotoAction, error) {
	var body GotoAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGotoAction overwrites any union data inside the ApiExecutionResponse_Action as the provided GotoAction
func (t *ApiExecutionResponse_Action) FromGotoAction(v GotoAction) error {
	tmp := "goto"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGotoAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided GotoAction
func (t *ApiExecutionResponse_Action) MergeGotoAction(v GotoAction) error {
	tmp := "goto"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGotoNewTabAction returns the union data inside the ApiExecutionResponse_Action as a GotoNewTabAction
func (t ApiExecutionResponse_Action) AsGotoNewTabAction() (GotoNewTabAction, error) {
	var body GotoNewTabAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGotoNewTabAction overwrites any union data inside the ApiExecutionResponse_Action as the provided GotoNewTabAction
func (t *ApiExecutionResponse_Action) FromGotoNewTabAction(v GotoNewTabAction) error {
	tmp := "goto_new_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGotoNewTabAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided GotoNewTabAction
func (t *ApiExecutionResponse_Action) MergeGotoNewTabAction(v GotoNewTabAction) error {
	tmp := "goto_new_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCloseTabAction returns the union data inside the ApiExecutionResponse_Action as a CloseTabAction
func (t ApiExecutionResponse_Action) AsCloseTabAction() (CloseTabAction, error) {
	var body CloseTabAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCloseTabAction overwrites any union data inside the ApiExecutionResponse_Action as the provided CloseTabAction
func (t *ApiExecutionResponse_Action) FromCloseTabAction(v CloseTabAction) error {
	tmp := "close_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCloseTabAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided CloseTabAction
func (t *ApiExecutionResponse_Action) MergeCloseTabAction(v CloseTabAction) error {
	tmp := "close_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwitchTabAction returns the union data inside the ApiExecutionResponse_Action as a SwitchTabAction
func (t ApiExecutionResponse_Action) AsSwitchTabAction() (SwitchTabAction, error) {
	var body SwitchTabAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwitchTabAction overwrites any union data inside the ApiExecutionResponse_Action as the provided SwitchTabAction
func (t *ApiExecutionResponse_Action) FromSwitchTabAction(v SwitchTabAction) error {
	tmp := "switch_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwitchTabAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided SwitchTabAction
func (t *ApiExecutionResponse_Action) MergeSwitchTabAction(v SwitchTabAction) error {
	tmp := "switch_tab"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoBackAction returns the union data inside the ApiExecutionResponse_Action as a GoBackAction
func (t ApiExecutionResponse_Action) AsGoBackAction() (GoBackAction, error) {
	var body GoBackAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoBackAction overwrites any union data inside the ApiExecutionResponse_Action as the provided GoBackAction
func (t *ApiExecutionResponse_Action) FromGoBackAction(v GoBackAction) error {
	tmp := "go_back"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoBackAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided GoBackAction
func (t *ApiExecutionResponse_Action) MergeGoBackAction(v GoBackAction) error {
	tmp := "go_back"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoForwardAction returns the union data inside the ApiExecutionResponse_Action as a GoForwardAction
func (t ApiExecutionResponse_Action) AsGoForwardAction() (GoForwardAction, error) {
	var body GoForwardAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoForwardAction overwrites any union data inside the ApiExecutionResponse_Action as the provided GoForwardAction
func (t *ApiExecutionResponse_Action) FromGoForwardAction(v GoForwardAction) error {
	tmp := "go_forward"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoForwardAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided GoForwardAction
func (t *ApiExecutionResponse_Action) MergeGoForwardAction(v GoForwardAction) error {
	tmp := "go_forward"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReloadAction returns the union data inside the ApiExecutionResponse_Action as a ReloadAction
func (t ApiExecutionResponse_Action) AsReloadAction() (ReloadAction, error) {
	var body ReloadAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReloadAction overwrites any union data inside the ApiExecutionResponse_Action as the provided ReloadAction
func (t *ApiExecutionResponse_Action) FromReloadAction(v ReloadAction) error {
	tmp := "reload"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReloadAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided ReloadAction
func (t *ApiExecutionResponse_Action) MergeReloadAction(v ReloadAction) error {
	tmp := "reload"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWaitAction returns the union data inside the ApiExecutionResponse_Action as a WaitAction
func (t ApiExecutionResponse_Action) AsWaitAction() (WaitAction, error) {
	var body WaitAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWaitAction overwrites any union data inside the ApiExecutionResponse_Action as the provided WaitAction
func (t *ApiExecutionResponse_Action) FromWaitAction(v WaitAction) error {
	tmp := "wait"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWaitAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided WaitAction
func (t *ApiExecutionResponse_Action) MergeWaitAction(v WaitAction) error {
	tmp := "wait"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPressKeyAction returns the union data inside the ApiExecutionResponse_Action as a PressKeyAction
func (t ApiExecutionResponse_Action) AsPressKeyAction() (PressKeyAction, error) {
	var body PressKeyAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPressKeyAction overwrites any union data inside the ApiExecutionResponse_Action as the provided PressKeyAction
func (t *ApiExecutionResponse_Action) FromPressKeyAction(v PressKeyAction) error {
	tmp := "press_key"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePressKeyAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided PressKeyAction
func (t *ApiExecutionResponse_Action) MergePressKeyAction(v PressKeyAction) error {
	tmp := "press_key"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScrollUpAction returns the union data inside the ApiExecutionResponse_Action as a ScrollUpAction
func (t ApiExecutionResponse_Action) AsScrollUpAction() (ScrollUpAction, error) {
	var body ScrollUpAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollUpAction overwrites any union data inside the ApiExecutionResponse_Action as the provided ScrollUpAction
func (t *ApiExecutionResponse_Action) FromScrollUpAction(v ScrollUpAction) error {
	tmp := "scroll_up"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollUpAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided ScrollUpAction
func (t *ApiExecutionResponse_Action) MergeScrollUpAction(v ScrollUpAction) error {
	tmp := "scroll_up"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScrollDownAction returns the union data inside the ApiExecutionResponse_Action as a ScrollDownAction
func (t ApiExecutionResponse_Action) AsScrollDownAction() (ScrollDownAction, error) {
	var body ScrollDownAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrollDownAction overwrites any union data inside the ApiExecutionResponse_Action as the provided ScrollDownAction
func (t *ApiExecutionResponse_Action) FromScrollDownAction(v ScrollDownAction) error {
	tmp := "scroll_down"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrollDownAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided ScrollDownAction
func (t *ApiExecutionResponse_Action) MergeScrollDownAction(v ScrollDownAction) error {
	tmp := "scroll_down"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCaptchaSolveAction returns the union data inside the ApiExecutionResponse_Action as a CaptchaSolveAction
func (t ApiExecutionResponse_Action) AsCaptchaSolveAction() (CaptchaSolveAction, error) {
	var body CaptchaSolveAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCaptchaSolveAction overwrites any union data inside the ApiExecutionResponse_Action as the provided CaptchaSolveAction
func (t *ApiExecutionResponse_Action) FromCaptchaSolveAction(v CaptchaSolveAction) error {
	tmp := "captcha_solve"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCaptchaSolveAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided CaptchaSolveAction
func (t *ApiExecutionResponse_Action) MergeCaptchaSolveAction(v CaptchaSolveAction) error {
	tmp := "captcha_solve"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHelpAction returns the union data inside the ApiExecutionResponse_Action as a HelpAction
func (t ApiExecutionResponse_Action) AsHelpAction() (HelpAction, error) {
	var body HelpAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHelpAction overwrites any union data inside the ApiExecutionResponse_Action as the provided HelpAction
func (t *ApiExecutionResponse_Action) FromHelpAction(v HelpAction) error {
	tmp := "help"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHelpAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided HelpAction
func (t *ApiExecutionResponse_Action) MergeHelpAction(v HelpAction) error {
	tmp := "help"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCompletionAction returns the union data inside the ApiExecutionResponse_Action as a CompletionAction
func (t ApiExecutionResponse_Action) AsCompletionAction() (CompletionAction, error) {
	var body CompletionAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompletionAction overwrites any union data inside the ApiExecutionResponse_Action as the provided CompletionAction
func (t *ApiExecutionResponse_Action) FromCompletionAction(v CompletionAction) error {
	tmp := "completion"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompletionAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided CompletionAction
func (t *ApiExecutionResponse_Action) MergeCompletionAction(v CompletionAction) error {
	tmp := "completion"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScrapeAction returns the union data inside the ApiExecutionResponse_Action as a ScrapeAction
func (t ApiExecutionResponse_Action) AsScrapeAction() (ScrapeAction, error) {
	var body ScrapeAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScrapeAction overwrites any union data inside the ApiExecutionResponse_Action as the provided ScrapeAction
func (t *ApiExecutionResponse_Action) FromScrapeAction(v ScrapeAction) error {
	tmp := "scrape"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScrapeAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided ScrapeAction
func (t *ApiExecutionResponse_Action) MergeScrapeAction(v ScrapeAction) error {
	tmp := "scrape"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailReadAction returns the union data inside the ApiExecutionResponse_Action as a EmailReadAction
func (t ApiExecutionResponse_Action) AsEmailReadAction() (EmailReadAction, error) {
	var body EmailReadAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailReadAction overwrites any union data inside the ApiExecutionResponse_Action as the provided EmailReadAction
func (t *ApiExecutionResponse_Action) FromEmailReadAction(v EmailReadAction) error {
	tmp := "email_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailReadAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided EmailReadAction
func (t *ApiExecutionResponse_Action) MergeEmailReadAction(v EmailReadAction) error {
	tmp := "email_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSmsReadAction returns the union data inside the ApiExecutionResponse_Action as a SmsReadAction
func (t ApiExecutionResponse_Action) AsSmsReadAction() (SmsReadAction, error) {
	var body SmsReadAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSmsReadAction overwrites any union data inside the ApiExecutionResponse_Action as the provided SmsReadAction
func (t *ApiExecutionResponse_Action) FromSmsReadAction(v SmsReadAction) error {
	tmp := "sms_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSmsReadAction performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided SmsReadAction
func (t *ApiExecutionResponse_Action) MergeSmsReadAction(v SmsReadAction) error {
	tmp := "sms_read"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsClickActionOutput returns the union data inside the ApiExecutionResponse_Action as a ClickActionOutput
func (t ApiExecutionResponse_Action) AsClickActionOutput() (ClickActionOutput, error) {
	var body ClickActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClickActionOutput overwrites any union data inside the ApiExecutionResponse_Action as the provided ClickActionOutput
func (t *ApiExecutionResponse_Action) FromClickActionOutput(v ClickActionOutput) error {
	tmp := "click"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClickActionOutput performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided ClickActionOutput
func (t *ApiExecutionResponse_Action) MergeClickActionOutput(v ClickActionOutput) error {
	tmp := "click"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFillActionOutput returns the union data inside the ApiExecutionResponse_Action as a FillActionOutput
func (t ApiExecutionResponse_Action) AsFillActionOutput() (FillActionOutput, error) {
	var body FillActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillActionOutput overwrites any union data inside the ApiExecutionResponse_Action as the provided FillActionOutput
func (t *ApiExecutionResponse_Action) FromFillActionOutput(v FillActionOutput) error {
	tmp := "fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillActionOutput performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided FillActionOutput
func (t *ApiExecutionResponse_Action) MergeFillActionOutput(v FillActionOutput) error {
	tmp := "fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiFactorFillActionOutput returns the union data inside the ApiExecutionResponse_Action as a MultiFactorFillActionOutput
func (t ApiExecutionResponse_Action) AsMultiFactorFillActionOutput() (MultiFactorFillActionOutput, error) {
	var body MultiFactorFillActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiFactorFillActionOutput overwrites any union data inside the ApiExecutionResponse_Action as the provided MultiFactorFillActionOutput
func (t *ApiExecutionResponse_Action) FromMultiFactorFillActionOutput(v MultiFactorFillActionOutput) error {
	tmp := "multi_factor_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiFactorFillActionOutput performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided MultiFactorFillActionOutput
func (t *ApiExecutionResponse_Action) MergeMultiFactorFillActionOutput(v MultiFactorFillActionOutput) error {
	tmp := "multi_factor_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFallbackFillActionOutput returns the union data inside the ApiExecutionResponse_Action as a FallbackFillActionOutput
func (t ApiExecutionResponse_Action) AsFallbackFillActionOutput() (FallbackFillActionOutput, error) {
	var body FallbackFillActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFallbackFillActionOutput overwrites any union data inside the ApiExecutionResponse_Action as the provided FallbackFillActionOutput
func (t *ApiExecutionResponse_Action) FromFallbackFillActionOutput(v FallbackFillActionOutput) error {
	tmp := "fallback_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFallbackFillActionOutput performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided FallbackFillActionOutput
func (t *ApiExecutionResponse_Action) MergeFallbackFillActionOutput(v FallbackFillActionOutput) error {
	tmp := "fallback_fill"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCheckActionOutput returns the union data inside the ApiExecutionResponse_Action as a CheckActionOutput
func (t ApiExecutionResponse_Action) AsCheckActionOutput() (CheckActionOutput, error) {
	var body CheckActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCheckActionOutput overwrites any union data inside the ApiExecutionResponse_Action as the provided CheckActionOutput
func (t *ApiExecutionResponse_Action) FromCheckActionOutput(v CheckActionOutput) error {
	tmp := "check"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCheckActionOutput performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided CheckActionOutput
func (t *ApiExecutionResponse_Action) MergeCheckActionOutput(v CheckActionOutput) error {
	tmp := "check"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectDropdownOptionActionOutput returns the union data inside the ApiExecutionResponse_Action as a SelectDropdownOptionActionOutput
func (t ApiExecutionResponse_Action) AsSelectDropdownOptionActionOutput() (SelectDropdownOptionActionOutput, error) {
	var body SelectDropdownOptionActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectDropdownOptionActionOutput overwrites any union data inside the ApiExecutionResponse_Action as the provided SelectDropdownOptionActionOutput
func (t *ApiExecutionResponse_Action) FromSelectDropdownOptionActionOutput(v SelectDropdownOptionActionOutput) error {
	tmp := "select_dropdown_option"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectDropdownOptionActionOutput performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided SelectDropdownOptionActionOutput
func (t *ApiExecutionResponse_Action) MergeSelectDropdownOptionActionOutput(v SelectDropdownOptionActionOutput) error {
	tmp := "select_dropdown_option"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUploadFileActionOutput returns the union data inside the ApiExecutionResponse_Action as a UploadFileActionOutput
func (t ApiExecutionResponse_Action) AsUploadFileActionOutput() (UploadFileActionOutput, error) {
	var body UploadFileActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUploadFileActionOutput overwrites any union data inside the ApiExecutionResponse_Action as the provided UploadFileActionOutput
func (t *ApiExecutionResponse_Action) FromUploadFileActionOutput(v UploadFileActionOutput) error {
	tmp := "upload_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUploadFileActionOutput performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided UploadFileActionOutput
func (t *ApiExecutionResponse_Action) MergeUploadFileActionOutput(v UploadFileActionOutput) error {
	tmp := "upload_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDownloadFileActionOutput returns the union data inside the ApiExecutionResponse_Action as a DownloadFileActionOutput
func (t ApiExecutionResponse_Action) AsDownloadFileActionOutput() (DownloadFileActionOutput, error) {
	var body DownloadFileActionOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDownloadFileActionOutput overwrites any union data inside the ApiExecutionResponse_Action as the provided DownloadFileActionOutput
func (t *ApiExecutionResponse_Action) FromDownloadFileActionOutput(v DownloadFileActionOutput) error {
	tmp := "download_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDownloadFileActionOutput performs a merge with any union data inside the ApiExecutionResponse_Action, using the provided DownloadFileActionOutput
func (t *ApiExecutionResponse_Action) MergeDownloadFileActionOutput(v DownloadFileActionOutput) error {
	tmp := "download_file"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiExecutionResponse_Action) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ApiExecutionResponse_Action) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "captcha_solve":
		return t.AsCaptchaSolveAction()
	case "check":
		return t.AsCheckActionOutput()
	case "click":
		return t.AsClickActionOutput()
	case "close_tab":
		return t.AsCloseTabAction()
	case "completion":
		return t.AsCompletionAction()
	case "download_file":
		return t.AsDownloadFileActionOutput()
	case "email_read":
		return t.AsEmailReadAction()
	case "fallback_fill":
		return t.AsFallbackFillActionOutput()
	case "fill":
		return t.AsFillActionOutput()
	case "form_fill":
		return t.AsFormFillAction()
	case "go_back":
		return t.AsGoBackAction()
	case "go_forward":
		return t.AsGoForwardAction()
	case "goto":
		return t.AsGotoAction()
	case "goto_new_tab":
		return t.AsGotoNewTabAction()
	case "help":
		return t.AsHelpAction()
	case "multi_factor_fill":
		return t.AsMultiFactorFillActionOutput()
	case "press_key":
		return t.AsPressKeyAction()
	case "reload":
		return t.AsReloadAction()
	case "scrape":
		return t.AsScrapeAction()
	case "scroll_down":
		return t.AsScrollDownAction()
	case "scroll_up":
		return t.AsScrollUpAction()
	case "select_dropdown_option":
		return t.AsSelectDropdownOptionActionOutput()
	case "sms_read":
		return t.AsSmsReadAction()
	case "switch_tab":
		return t.AsSwitchTabAction()
	case "upload_file":
		return t.AsUploadFileActionOutput()
	case "wait":
		return t.AsWaitAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ApiExecutionResponse_Action) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiExecutionResponse_Action) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotteProxy returns the union data inside the ApiSessionStartRequest_Proxies_0_Item as a NotteProxy
func (t ApiSessionStartRequest_Proxies_0_Item) AsNotteProxy() (NotteProxy, error) {
	var body NotteProxy
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotteProxy overwrites any union data inside the ApiSessionStartRequest_Proxies_0_Item as the provided NotteProxy
func (t *ApiSessionStartRequest_Proxies_0_Item) FromNotteProxy(v NotteProxy) error {
	tmp := "notte"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotteProxy performs a merge with any union data inside the ApiSessionStartRequest_Proxies_0_Item, using the provided NotteProxy
func (t *ApiSessionStartRequest_Proxies_0_Item) MergeNotteProxy(v NotteProxy) error {
	tmp := "notte"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalProxy returns the union data inside the ApiSessionStartRequest_Proxies_0_Item as a ExternalProxy
func (t ApiSessionStartRequest_Proxies_0_Item) AsExternalProxy() (ExternalProxy, error) {
	var body ExternalProxy
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalProxy overwrites any union data inside the ApiSessionStartRequest_Proxies_0_Item as the provided ExternalProxy
func (t *ApiSessionStartRequest_Proxies_0_Item) FromExternalProxy(v ExternalProxy) error {
	tmp := "external"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalProxy performs a merge with any union data inside the ApiSessionStartRequest_Proxies_0_Item, using the provided ExternalProxy
func (t *ApiSessionStartRequest_Proxies_0_Item) MergeExternalProxy(v ExternalProxy) error {
	tmp := "external"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiSessionStartRequest_Proxies_0_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ApiSessionStartRequest_Proxies_0_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "external":
		return t.AsExternalProxy()
	case "notte":
		return t.AsNotteProxy()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ApiSessionStartRequest_Proxies_0_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiSessionStartRequest_Proxies_0_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsApiSessionStartRequestProxies0 returns the union data inside the ApiSessionStartRequest_Proxies as a ApiSessionStartRequestProxies0
func (t ApiSessionStartRequest_Proxies) AsApiSessionStartRequestProxies0() (ApiSessionStartRequestProxies0, error) {
	var body ApiSessionStartRequestProxies0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiSessionStartRequestProxies0 overwrites any union data inside the ApiSessionStartRequest_Proxies as the provided ApiSessionStartRequestProxies0
func (t *ApiSessionStartRequest_Proxies) FromApiSessionStartRequestProxies0(v ApiSessionStartRequestProxies0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiSessionStartRequestProxies0 performs a merge with any union data inside the ApiSessionStartRequest_Proxies, using the provided ApiSessionStartRequestProxies0
func (t *ApiSessionStartRequest_Proxies) MergeApiSessionStartRequestProxies0(v ApiSessionStartRequestProxies0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsApiSessionStartRequestProxies1 returns the union data inside the ApiSessionStartRequest_Proxies as a ApiSessionStartRequestProxies1
func (t ApiSessionStartRequest_Proxies) AsApiSessionStartRequestProxies1() (ApiSessionStartRequestProxies1, error) {
	var body ApiSessionStartRequestProxies1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiSessionStartRequestProxies1 overwrites any union data inside the ApiSessionStartRequest_Proxies as the provided ApiSessionStartRequestProxies1
func (t *ApiSessionStartRequest_Proxies) FromApiSessionStartRequestProxies1(v ApiSessionStartRequestProxies1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiSessionStartRequestProxies1 performs a merge with any union data inside the ApiSessionStartRequest_Proxies, using the provided ApiSessionStartRequestProxies1
func (t *ApiSessionStartRequest_Proxies) MergeApiSessionStartRequestProxies1(v ApiSessionStartRequestProxies1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiSessionStartRequest_Proxies) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiSessionStartRequest_Proxies) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCheckActionInputSelector0 returns the union data inside the CheckActionInput_Selector as a CheckActionInputSelector0
func (t CheckActionInput_Selector) AsCheckActionInputSelector0() (CheckActionInputSelector0, error) {
	var body CheckActionInputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCheckActionInputSelector0 overwrites any union data inside the CheckActionInput_Selector as the provided CheckActionInputSelector0
func (t *CheckActionInput_Selector) FromCheckActionInputSelector0(v CheckActionInputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCheckActionInputSelector0 performs a merge with any union data inside the CheckActionInput_Selector, using the provided CheckActionInputSelector0
func (t *CheckActionInput_Selector) MergeCheckActionInputSelector0(v CheckActionInputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the CheckActionInput_Selector as a NodeSelectors
func (t CheckActionInput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the CheckActionInput_Selector as the provided NodeSelectors
func (t *CheckActionInput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the CheckActionInput_Selector, using the provided NodeSelectors
func (t *CheckActionInput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CheckActionInput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CheckActionInput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCheckActionOutputSelector0 returns the union data inside the CheckActionOutput_Selector as a CheckActionOutputSelector0
func (t CheckActionOutput_Selector) AsCheckActionOutputSelector0() (CheckActionOutputSelector0, error) {
	var body CheckActionOutputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCheckActionOutputSelector0 overwrites any union data inside the CheckActionOutput_Selector as the provided CheckActionOutputSelector0
func (t *CheckActionOutput_Selector) FromCheckActionOutputSelector0(v CheckActionOutputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCheckActionOutputSelector0 performs a merge with any union data inside the CheckActionOutput_Selector, using the provided CheckActionOutputSelector0
func (t *CheckActionOutput_Selector) MergeCheckActionOutputSelector0(v CheckActionOutputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the CheckActionOutput_Selector as a NodeSelectors
func (t CheckActionOutput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the CheckActionOutput_Selector as the provided NodeSelectors
func (t *CheckActionOutput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the CheckActionOutput_Selector, using the provided NodeSelectors
func (t *CheckActionOutput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CheckActionOutput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CheckActionOutput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsClickActionInputSelector0 returns the union data inside the ClickActionInput_Selector as a ClickActionInputSelector0
func (t ClickActionInput_Selector) AsClickActionInputSelector0() (ClickActionInputSelector0, error) {
	var body ClickActionInputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClickActionInputSelector0 overwrites any union data inside the ClickActionInput_Selector as the provided ClickActionInputSelector0
func (t *ClickActionInput_Selector) FromClickActionInputSelector0(v ClickActionInputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClickActionInputSelector0 performs a merge with any union data inside the ClickActionInput_Selector, using the provided ClickActionInputSelector0
func (t *ClickActionInput_Selector) MergeClickActionInputSelector0(v ClickActionInputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the ClickActionInput_Selector as a NodeSelectors
func (t ClickActionInput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the ClickActionInput_Selector as the provided NodeSelectors
func (t *ClickActionInput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the ClickActionInput_Selector, using the provided NodeSelectors
func (t *ClickActionInput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ClickActionInput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ClickActionInput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsClickActionOutputSelector0 returns the union data inside the ClickActionOutput_Selector as a ClickActionOutputSelector0
func (t ClickActionOutput_Selector) AsClickActionOutputSelector0() (ClickActionOutputSelector0, error) {
	var body ClickActionOutputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClickActionOutputSelector0 overwrites any union data inside the ClickActionOutput_Selector as the provided ClickActionOutputSelector0
func (t *ClickActionOutput_Selector) FromClickActionOutputSelector0(v ClickActionOutputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClickActionOutputSelector0 performs a merge with any union data inside the ClickActionOutput_Selector, using the provided ClickActionOutputSelector0
func (t *ClickActionOutput_Selector) MergeClickActionOutputSelector0(v ClickActionOutputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the ClickActionOutput_Selector as a NodeSelectors
func (t ClickActionOutput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the ClickActionOutput_Selector as the provided NodeSelectors
func (t *ClickActionOutput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the ClickActionOutput_Selector, using the provided NodeSelectors
func (t *ClickActionOutput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ClickActionOutput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ClickActionOutput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDownloadFileActionInputSelector0 returns the union data inside the DownloadFileActionInput_Selector as a DownloadFileActionInputSelector0
func (t DownloadFileActionInput_Selector) AsDownloadFileActionInputSelector0() (DownloadFileActionInputSelector0, error) {
	var body DownloadFileActionInputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDownloadFileActionInputSelector0 overwrites any union data inside the DownloadFileActionInput_Selector as the provided DownloadFileActionInputSelector0
func (t *DownloadFileActionInput_Selector) FromDownloadFileActionInputSelector0(v DownloadFileActionInputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDownloadFileActionInputSelector0 performs a merge with any union data inside the DownloadFileActionInput_Selector, using the provided DownloadFileActionInputSelector0
func (t *DownloadFileActionInput_Selector) MergeDownloadFileActionInputSelector0(v DownloadFileActionInputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the DownloadFileActionInput_Selector as a NodeSelectors
func (t DownloadFileActionInput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the DownloadFileActionInput_Selector as the provided NodeSelectors
func (t *DownloadFileActionInput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the DownloadFileActionInput_Selector, using the provided NodeSelectors
func (t *DownloadFileActionInput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DownloadFileActionInput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DownloadFileActionInput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDownloadFileActionOutputSelector0 returns the union data inside the DownloadFileActionOutput_Selector as a DownloadFileActionOutputSelector0
func (t DownloadFileActionOutput_Selector) AsDownloadFileActionOutputSelector0() (DownloadFileActionOutputSelector0, error) {
	var body DownloadFileActionOutputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDownloadFileActionOutputSelector0 overwrites any union data inside the DownloadFileActionOutput_Selector as the provided DownloadFileActionOutputSelector0
func (t *DownloadFileActionOutput_Selector) FromDownloadFileActionOutputSelector0(v DownloadFileActionOutputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDownloadFileActionOutputSelector0 performs a merge with any union data inside the DownloadFileActionOutput_Selector, using the provided DownloadFileActionOutputSelector0
func (t *DownloadFileActionOutput_Selector) MergeDownloadFileActionOutputSelector0(v DownloadFileActionOutputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the DownloadFileActionOutput_Selector as a NodeSelectors
func (t DownloadFileActionOutput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the DownloadFileActionOutput_Selector as the provided NodeSelectors
func (t *DownloadFileActionOutput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the DownloadFileActionOutput_Selector, using the provided NodeSelectors
func (t *DownloadFileActionOutput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DownloadFileActionOutput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DownloadFileActionOutput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFallbackFillActionInputSelector0 returns the union data inside the FallbackFillActionInput_Selector as a FallbackFillActionInputSelector0
func (t FallbackFillActionInput_Selector) AsFallbackFillActionInputSelector0() (FallbackFillActionInputSelector0, error) {
	var body FallbackFillActionInputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFallbackFillActionInputSelector0 overwrites any union data inside the FallbackFillActionInput_Selector as the provided FallbackFillActionInputSelector0
func (t *FallbackFillActionInput_Selector) FromFallbackFillActionInputSelector0(v FallbackFillActionInputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFallbackFillActionInputSelector0 performs a merge with any union data inside the FallbackFillActionInput_Selector, using the provided FallbackFillActionInputSelector0
func (t *FallbackFillActionInput_Selector) MergeFallbackFillActionInputSelector0(v FallbackFillActionInputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the FallbackFillActionInput_Selector as a NodeSelectors
func (t FallbackFillActionInput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the FallbackFillActionInput_Selector as the provided NodeSelectors
func (t *FallbackFillActionInput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the FallbackFillActionInput_Selector, using the provided NodeSelectors
func (t *FallbackFillActionInput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FallbackFillActionInput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FallbackFillActionInput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFallbackFillActionInputValue0 returns the union data inside the FallbackFillActionInput_Value as a FallbackFillActionInputValue0
func (t FallbackFillActionInput_Value) AsFallbackFillActionInputValue0() (FallbackFillActionInputValue0, error) {
	var body FallbackFillActionInputValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFallbackFillActionInputValue0 overwrites any union data inside the FallbackFillActionInput_Value as the provided FallbackFillActionInputValue0
func (t *FallbackFillActionInput_Value) FromFallbackFillActionInputValue0(v FallbackFillActionInputValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFallbackFillActionInputValue0 performs a merge with any union data inside the FallbackFillActionInput_Value, using the provided FallbackFillActionInputValue0
func (t *FallbackFillActionInput_Value) MergeFallbackFillActionInputValue0(v FallbackFillActionInputValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFallbackFillActionInputValue1 returns the union data inside the FallbackFillActionInput_Value as a FallbackFillActionInputValue1
func (t FallbackFillActionInput_Value) AsFallbackFillActionInputValue1() (FallbackFillActionInputValue1, error) {
	var body FallbackFillActionInputValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFallbackFillActionInputValue1 overwrites any union data inside the FallbackFillActionInput_Value as the provided FallbackFillActionInputValue1
func (t *FallbackFillActionInput_Value) FromFallbackFillActionInputValue1(v FallbackFillActionInputValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFallbackFillActionInputValue1 performs a merge with any union data inside the FallbackFillActionInput_Value, using the provided FallbackFillActionInputValue1
func (t *FallbackFillActionInput_Value) MergeFallbackFillActionInputValue1(v FallbackFillActionInputValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FallbackFillActionInput_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FallbackFillActionInput_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFallbackFillActionOutputSelector0 returns the union data inside the FallbackFillActionOutput_Selector as a FallbackFillActionOutputSelector0
func (t FallbackFillActionOutput_Selector) AsFallbackFillActionOutputSelector0() (FallbackFillActionOutputSelector0, error) {
	var body FallbackFillActionOutputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFallbackFillActionOutputSelector0 overwrites any union data inside the FallbackFillActionOutput_Selector as the provided FallbackFillActionOutputSelector0
func (t *FallbackFillActionOutput_Selector) FromFallbackFillActionOutputSelector0(v FallbackFillActionOutputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFallbackFillActionOutputSelector0 performs a merge with any union data inside the FallbackFillActionOutput_Selector, using the provided FallbackFillActionOutputSelector0
func (t *FallbackFillActionOutput_Selector) MergeFallbackFillActionOutputSelector0(v FallbackFillActionOutputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the FallbackFillActionOutput_Selector as a NodeSelectors
func (t FallbackFillActionOutput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the FallbackFillActionOutput_Selector as the provided NodeSelectors
func (t *FallbackFillActionOutput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the FallbackFillActionOutput_Selector, using the provided NodeSelectors
func (t *FallbackFillActionOutput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FallbackFillActionOutput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FallbackFillActionOutput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFallbackFillActionOutputValue0 returns the union data inside the FallbackFillActionOutput_Value as a FallbackFillActionOutputValue0
func (t FallbackFillActionOutput_Value) AsFallbackFillActionOutputValue0() (FallbackFillActionOutputValue0, error) {
	var body FallbackFillActionOutputValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFallbackFillActionOutputValue0 overwrites any union data inside the FallbackFillActionOutput_Value as the provided FallbackFillActionOutputValue0
func (t *FallbackFillActionOutput_Value) FromFallbackFillActionOutputValue0(v FallbackFillActionOutputValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFallbackFillActionOutputValue0 performs a merge with any union data inside the FallbackFillActionOutput_Value, using the provided FallbackFillActionOutputValue0
func (t *FallbackFillActionOutput_Value) MergeFallbackFillActionOutputValue0(v FallbackFillActionOutputValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFallbackFillActionOutputValue1 returns the union data inside the FallbackFillActionOutput_Value as a FallbackFillActionOutputValue1
func (t FallbackFillActionOutput_Value) AsFallbackFillActionOutputValue1() (FallbackFillActionOutputValue1, error) {
	var body FallbackFillActionOutputValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFallbackFillActionOutputValue1 overwrites any union data inside the FallbackFillActionOutput_Value as the provided FallbackFillActionOutputValue1
func (t *FallbackFillActionOutput_Value) FromFallbackFillActionOutputValue1(v FallbackFillActionOutputValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFallbackFillActionOutputValue1 performs a merge with any union data inside the FallbackFillActionOutput_Value, using the provided FallbackFillActionOutputValue1
func (t *FallbackFillActionOutput_Value) MergeFallbackFillActionOutputValue1(v FallbackFillActionOutputValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FallbackFillActionOutput_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FallbackFillActionOutput_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFillActionInputSelector0 returns the union data inside the FillActionInput_Selector as a FillActionInputSelector0
func (t FillActionInput_Selector) AsFillActionInputSelector0() (FillActionInputSelector0, error) {
	var body FillActionInputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillActionInputSelector0 overwrites any union data inside the FillActionInput_Selector as the provided FillActionInputSelector0
func (t *FillActionInput_Selector) FromFillActionInputSelector0(v FillActionInputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillActionInputSelector0 performs a merge with any union data inside the FillActionInput_Selector, using the provided FillActionInputSelector0
func (t *FillActionInput_Selector) MergeFillActionInputSelector0(v FillActionInputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the FillActionInput_Selector as a NodeSelectors
func (t FillActionInput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the FillActionInput_Selector as the provided NodeSelectors
func (t *FillActionInput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the FillActionInput_Selector, using the provided NodeSelectors
func (t *FillActionInput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FillActionInput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FillActionInput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFillActionInputValue0 returns the union data inside the FillActionInput_Value as a FillActionInputValue0
func (t FillActionInput_Value) AsFillActionInputValue0() (FillActionInputValue0, error) {
	var body FillActionInputValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillActionInputValue0 overwrites any union data inside the FillActionInput_Value as the provided FillActionInputValue0
func (t *FillActionInput_Value) FromFillActionInputValue0(v FillActionInputValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillActionInputValue0 performs a merge with any union data inside the FillActionInput_Value, using the provided FillActionInputValue0
func (t *FillActionInput_Value) MergeFillActionInputValue0(v FillActionInputValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFillActionInputValue1 returns the union data inside the FillActionInput_Value as a FillActionInputValue1
func (t FillActionInput_Value) AsFillActionInputValue1() (FillActionInputValue1, error) {
	var body FillActionInputValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillActionInputValue1 overwrites any union data inside the FillActionInput_Value as the provided FillActionInputValue1
func (t *FillActionInput_Value) FromFillActionInputValue1(v FillActionInputValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillActionInputValue1 performs a merge with any union data inside the FillActionInput_Value, using the provided FillActionInputValue1
func (t *FillActionInput_Value) MergeFillActionInputValue1(v FillActionInputValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FillActionInput_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FillActionInput_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFillActionOutputSelector0 returns the union data inside the FillActionOutput_Selector as a FillActionOutputSelector0
func (t FillActionOutput_Selector) AsFillActionOutputSelector0() (FillActionOutputSelector0, error) {
	var body FillActionOutputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillActionOutputSelector0 overwrites any union data inside the FillActionOutput_Selector as the provided FillActionOutputSelector0
func (t *FillActionOutput_Selector) FromFillActionOutputSelector0(v FillActionOutputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillActionOutputSelector0 performs a merge with any union data inside the FillActionOutput_Selector, using the provided FillActionOutputSelector0
func (t *FillActionOutput_Selector) MergeFillActionOutputSelector0(v FillActionOutputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the FillActionOutput_Selector as a NodeSelectors
func (t FillActionOutput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the FillActionOutput_Selector as the provided NodeSelectors
func (t *FillActionOutput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the FillActionOutput_Selector, using the provided NodeSelectors
func (t *FillActionOutput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FillActionOutput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FillActionOutput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFillActionOutputValue0 returns the union data inside the FillActionOutput_Value as a FillActionOutputValue0
func (t FillActionOutput_Value) AsFillActionOutputValue0() (FillActionOutputValue0, error) {
	var body FillActionOutputValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillActionOutputValue0 overwrites any union data inside the FillActionOutput_Value as the provided FillActionOutputValue0
func (t *FillActionOutput_Value) FromFillActionOutputValue0(v FillActionOutputValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillActionOutputValue0 performs a merge with any union data inside the FillActionOutput_Value, using the provided FillActionOutputValue0
func (t *FillActionOutput_Value) MergeFillActionOutputValue0(v FillActionOutputValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFillActionOutputValue1 returns the union data inside the FillActionOutput_Value as a FillActionOutputValue1
func (t FillActionOutput_Value) AsFillActionOutputValue1() (FillActionOutputValue1, error) {
	var body FillActionOutputValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFillActionOutputValue1 overwrites any union data inside the FillActionOutput_Value as the provided FillActionOutputValue1
func (t *FillActionOutput_Value) FromFillActionOutputValue1(v FillActionOutputValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFillActionOutputValue1 performs a merge with any union data inside the FillActionOutput_Value, using the provided FillActionOutputValue1
func (t *FillActionOutput_Value) MergeFillActionOutputValue1(v FillActionOutputValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FillActionOutput_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FillActionOutput_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFormFillActionValue0 returns the union data inside the FormFillAction_Value_AdditionalProperties as a FormFillActionValue0
func (t FormFillAction_Value_AdditionalProperties) AsFormFillActionValue0() (FormFillActionValue0, error) {
	var body FormFillActionValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormFillActionValue0 overwrites any union data inside the FormFillAction_Value_AdditionalProperties as the provided FormFillActionValue0
func (t *FormFillAction_Value_AdditionalProperties) FromFormFillActionValue0(v FormFillActionValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormFillActionValue0 performs a merge with any union data inside the FormFillAction_Value_AdditionalProperties, using the provided FormFillActionValue0
func (t *FormFillAction_Value_AdditionalProperties) MergeFormFillActionValue0(v FormFillActionValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormFillActionValue1 returns the union data inside the FormFillAction_Value_AdditionalProperties as a FormFillActionValue1
func (t FormFillAction_Value_AdditionalProperties) AsFormFillActionValue1() (FormFillActionValue1, error) {
	var body FormFillActionValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormFillActionValue1 overwrites any union data inside the FormFillAction_Value_AdditionalProperties as the provided FormFillActionValue1
func (t *FormFillAction_Value_AdditionalProperties) FromFormFillActionValue1(v FormFillActionValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormFillActionValue1 performs a merge with any union data inside the FormFillAction_Value_AdditionalProperties, using the provided FormFillActionValue1
func (t *FormFillAction_Value_AdditionalProperties) MergeFormFillActionValue1(v FormFillActionValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FormFillAction_Value_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FormFillAction_Value_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotteProxy returns the union data inside the GlobalScrapeRequest_Proxies_0_Item as a NotteProxy
func (t GlobalScrapeRequest_Proxies_0_Item) AsNotteProxy() (NotteProxy, error) {
	var body NotteProxy
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotteProxy overwrites any union data inside the GlobalScrapeRequest_Proxies_0_Item as the provided NotteProxy
func (t *GlobalScrapeRequest_Proxies_0_Item) FromNotteProxy(v NotteProxy) error {
	tmp := "notte"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotteProxy performs a merge with any union data inside the GlobalScrapeRequest_Proxies_0_Item, using the provided NotteProxy
func (t *GlobalScrapeRequest_Proxies_0_Item) MergeNotteProxy(v NotteProxy) error {
	tmp := "notte"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalProxy returns the union data inside the GlobalScrapeRequest_Proxies_0_Item as a ExternalProxy
func (t GlobalScrapeRequest_Proxies_0_Item) AsExternalProxy() (ExternalProxy, error) {
	var body ExternalProxy
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalProxy overwrites any union data inside the GlobalScrapeRequest_Proxies_0_Item as the provided ExternalProxy
func (t *GlobalScrapeRequest_Proxies_0_Item) FromExternalProxy(v ExternalProxy) error {
	tmp := "external"
	v.Type = &tmp
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalProxy performs a merge with any union data inside the GlobalScrapeRequest_Proxies_0_Item, using the provided ExternalProxy
func (t *GlobalScrapeRequest_Proxies_0_Item) MergeExternalProxy(v ExternalProxy) error {
	tmp := "external"
	v.Type = &tmp
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GlobalScrapeRequest_Proxies_0_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GlobalScrapeRequest_Proxies_0_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "external":
		return t.AsExternalProxy()
	case "notte":
		return t.AsNotteProxy()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GlobalScrapeRequest_Proxies_0_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GlobalScrapeRequest_Proxies_0_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGlobalScrapeRequestProxies0 returns the union data inside the GlobalScrapeRequest_Proxies as a GlobalScrapeRequestProxies0
func (t GlobalScrapeRequest_Proxies) AsGlobalScrapeRequestProxies0() (GlobalScrapeRequestProxies0, error) {
	var body GlobalScrapeRequestProxies0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGlobalScrapeRequestProxies0 overwrites any union data inside the GlobalScrapeRequest_Proxies as the provided GlobalScrapeRequestProxies0
func (t *GlobalScrapeRequest_Proxies) FromGlobalScrapeRequestProxies0(v GlobalScrapeRequestProxies0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGlobalScrapeRequestProxies0 performs a merge with any union data inside the GlobalScrapeRequest_Proxies, using the provided GlobalScrapeRequestProxies0
func (t *GlobalScrapeRequest_Proxies) MergeGlobalScrapeRequestProxies0(v GlobalScrapeRequestProxies0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGlobalScrapeRequestProxies1 returns the union data inside the GlobalScrapeRequest_Proxies as a GlobalScrapeRequestProxies1
func (t GlobalScrapeRequest_Proxies) AsGlobalScrapeRequestProxies1() (GlobalScrapeRequestProxies1, error) {
	var body GlobalScrapeRequestProxies1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGlobalScrapeRequestProxies1 overwrites any union data inside the GlobalScrapeRequest_Proxies as the provided GlobalScrapeRequestProxies1
func (t *GlobalScrapeRequest_Proxies) FromGlobalScrapeRequestProxies1(v GlobalScrapeRequestProxies1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGlobalScrapeRequestProxies1 performs a merge with any union data inside the GlobalScrapeRequest_Proxies, using the provided GlobalScrapeRequestProxies1
func (t *GlobalScrapeRequest_Proxies) MergeGlobalScrapeRequestProxies1(v GlobalScrapeRequestProxies1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GlobalScrapeRequest_Proxies) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GlobalScrapeRequest_Proxies) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMultiFactorFillActionInputSelector0 returns the union data inside the MultiFactorFillActionInput_Selector as a MultiFactorFillActionInputSelector0
func (t MultiFactorFillActionInput_Selector) AsMultiFactorFillActionInputSelector0() (MultiFactorFillActionInputSelector0, error) {
	var body MultiFactorFillActionInputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiFactorFillActionInputSelector0 overwrites any union data inside the MultiFactorFillActionInput_Selector as the provided MultiFactorFillActionInputSelector0
func (t *MultiFactorFillActionInput_Selector) FromMultiFactorFillActionInputSelector0(v MultiFactorFillActionInputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiFactorFillActionInputSelector0 performs a merge with any union data inside the MultiFactorFillActionInput_Selector, using the provided MultiFactorFillActionInputSelector0
func (t *MultiFactorFillActionInput_Selector) MergeMultiFactorFillActionInputSelector0(v MultiFactorFillActionInputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the MultiFactorFillActionInput_Selector as a NodeSelectors
func (t MultiFactorFillActionInput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the MultiFactorFillActionInput_Selector as the provided NodeSelectors
func (t *MultiFactorFillActionInput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the MultiFactorFillActionInput_Selector, using the provided NodeSelectors
func (t *MultiFactorFillActionInput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MultiFactorFillActionInput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MultiFactorFillActionInput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMultiFactorFillActionInputValue0 returns the union data inside the MultiFactorFillActionInput_Value as a MultiFactorFillActionInputValue0
func (t MultiFactorFillActionInput_Value) AsMultiFactorFillActionInputValue0() (MultiFactorFillActionInputValue0, error) {
	var body MultiFactorFillActionInputValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiFactorFillActionInputValue0 overwrites any union data inside the MultiFactorFillActionInput_Value as the provided MultiFactorFillActionInputValue0
func (t *MultiFactorFillActionInput_Value) FromMultiFactorFillActionInputValue0(v MultiFactorFillActionInputValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiFactorFillActionInputValue0 performs a merge with any union data inside the MultiFactorFillActionInput_Value, using the provided MultiFactorFillActionInputValue0
func (t *MultiFactorFillActionInput_Value) MergeMultiFactorFillActionInputValue0(v MultiFactorFillActionInputValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiFactorFillActionInputValue1 returns the union data inside the MultiFactorFillActionInput_Value as a MultiFactorFillActionInputValue1
func (t MultiFactorFillActionInput_Value) AsMultiFactorFillActionInputValue1() (MultiFactorFillActionInputValue1, error) {
	var body MultiFactorFillActionInputValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiFactorFillActionInputValue1 overwrites any union data inside the MultiFactorFillActionInput_Value as the provided MultiFactorFillActionInputValue1
func (t *MultiFactorFillActionInput_Value) FromMultiFactorFillActionInputValue1(v MultiFactorFillActionInputValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiFactorFillActionInputValue1 performs a merge with any union data inside the MultiFactorFillActionInput_Value, using the provided MultiFactorFillActionInputValue1
func (t *MultiFactorFillActionInput_Value) MergeMultiFactorFillActionInputValue1(v MultiFactorFillActionInputValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MultiFactorFillActionInput_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MultiFactorFillActionInput_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMultiFactorFillActionOutputSelector0 returns the union data inside the MultiFactorFillActionOutput_Selector as a MultiFactorFillActionOutputSelector0
func (t MultiFactorFillActionOutput_Selector) AsMultiFactorFillActionOutputSelector0() (MultiFactorFillActionOutputSelector0, error) {
	var body MultiFactorFillActionOutputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiFactorFillActionOutputSelector0 overwrites any union data inside the MultiFactorFillActionOutput_Selector as the provided MultiFactorFillActionOutputSelector0
func (t *MultiFactorFillActionOutput_Selector) FromMultiFactorFillActionOutputSelector0(v MultiFactorFillActionOutputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiFactorFillActionOutputSelector0 performs a merge with any union data inside the MultiFactorFillActionOutput_Selector, using the provided MultiFactorFillActionOutputSelector0
func (t *MultiFactorFillActionOutput_Selector) MergeMultiFactorFillActionOutputSelector0(v MultiFactorFillActionOutputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the MultiFactorFillActionOutput_Selector as a NodeSelectors
func (t MultiFactorFillActionOutput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the MultiFactorFillActionOutput_Selector as the provided NodeSelectors
func (t *MultiFactorFillActionOutput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the MultiFactorFillActionOutput_Selector, using the provided NodeSelectors
func (t *MultiFactorFillActionOutput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MultiFactorFillActionOutput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MultiFactorFillActionOutput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMultiFactorFillActionOutputValue0 returns the union data inside the MultiFactorFillActionOutput_Value as a MultiFactorFillActionOutputValue0
func (t MultiFactorFillActionOutput_Value) AsMultiFactorFillActionOutputValue0() (MultiFactorFillActionOutputValue0, error) {
	var body MultiFactorFillActionOutputValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiFactorFillActionOutputValue0 overwrites any union data inside the MultiFactorFillActionOutput_Value as the provided MultiFactorFillActionOutputValue0
func (t *MultiFactorFillActionOutput_Value) FromMultiFactorFillActionOutputValue0(v MultiFactorFillActionOutputValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiFactorFillActionOutputValue0 performs a merge with any union data inside the MultiFactorFillActionOutput_Value, using the provided MultiFactorFillActionOutputValue0
func (t *MultiFactorFillActionOutput_Value) MergeMultiFactorFillActionOutputValue0(v MultiFactorFillActionOutputValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiFactorFillActionOutputValue1 returns the union data inside the MultiFactorFillActionOutput_Value as a MultiFactorFillActionOutputValue1
func (t MultiFactorFillActionOutput_Value) AsMultiFactorFillActionOutputValue1() (MultiFactorFillActionOutputValue1, error) {
	var body MultiFactorFillActionOutputValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiFactorFillActionOutputValue1 overwrites any union data inside the MultiFactorFillActionOutput_Value as the provided MultiFactorFillActionOutputValue1
func (t *MultiFactorFillActionOutput_Value) FromMultiFactorFillActionOutputValue1(v MultiFactorFillActionOutputValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiFactorFillActionOutputValue1 performs a merge with any union data inside the MultiFactorFillActionOutput_Value, using the provided MultiFactorFillActionOutputValue1
func (t *MultiFactorFillActionOutput_Value) MergeMultiFactorFillActionOutputValue1(v MultiFactorFillActionOutputValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MultiFactorFillActionOutput_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MultiFactorFillActionOutput_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRootModelUnionDictStrAnyListDictStrAny0 returns the union data inside the RootModelUnionDictStrAnyListDictStrAny as a RootModelUnionDictStrAnyListDictStrAny0
func (t RootModelUnionDictStrAnyListDictStrAny) AsRootModelUnionDictStrAnyListDictStrAny0() (RootModelUnionDictStrAnyListDictStrAny0, error) {
	var body RootModelUnionDictStrAnyListDictStrAny0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRootModelUnionDictStrAnyListDictStrAny0 overwrites any union data inside the RootModelUnionDictStrAnyListDictStrAny as the provided RootModelUnionDictStrAnyListDictStrAny0
func (t *RootModelUnionDictStrAnyListDictStrAny) FromRootModelUnionDictStrAnyListDictStrAny0(v RootModelUnionDictStrAnyListDictStrAny0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRootModelUnionDictStrAnyListDictStrAny0 performs a merge with any union data inside the RootModelUnionDictStrAnyListDictStrAny, using the provided RootModelUnionDictStrAnyListDictStrAny0
func (t *RootModelUnionDictStrAnyListDictStrAny) MergeRootModelUnionDictStrAnyListDictStrAny0(v RootModelUnionDictStrAnyListDictStrAny0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRootModelUnionDictStrAnyListDictStrAny1 returns the union data inside the RootModelUnionDictStrAnyListDictStrAny as a RootModelUnionDictStrAnyListDictStrAny1
func (t RootModelUnionDictStrAnyListDictStrAny) AsRootModelUnionDictStrAnyListDictStrAny1() (RootModelUnionDictStrAnyListDictStrAny1, error) {
	var body RootModelUnionDictStrAnyListDictStrAny1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRootModelUnionDictStrAnyListDictStrAny1 overwrites any union data inside the RootModelUnionDictStrAnyListDictStrAny as the provided RootModelUnionDictStrAnyListDictStrAny1
func (t *RootModelUnionDictStrAnyListDictStrAny) FromRootModelUnionDictStrAnyListDictStrAny1(v RootModelUnionDictStrAnyListDictStrAny1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRootModelUnionDictStrAnyListDictStrAny1 performs a merge with any union data inside the RootModelUnionDictStrAnyListDictStrAny, using the provided RootModelUnionDictStrAnyListDictStrAny1
func (t *RootModelUnionDictStrAnyListDictStrAny) MergeRootModelUnionDictStrAnyListDictStrAny1(v RootModelUnionDictStrAnyListDictStrAny1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RootModelUnionDictStrAnyListDictStrAny) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RootModelUnionDictStrAnyListDictStrAny) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSelectDropdownOptionActionInputSelector0 returns the union data inside the SelectDropdownOptionActionInput_Selector as a SelectDropdownOptionActionInputSelector0
func (t SelectDropdownOptionActionInput_Selector) AsSelectDropdownOptionActionInputSelector0() (SelectDropdownOptionActionInputSelector0, error) {
	var body SelectDropdownOptionActionInputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectDropdownOptionActionInputSelector0 overwrites any union data inside the SelectDropdownOptionActionInput_Selector as the provided SelectDropdownOptionActionInputSelector0
func (t *SelectDropdownOptionActionInput_Selector) FromSelectDropdownOptionActionInputSelector0(v SelectDropdownOptionActionInputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectDropdownOptionActionInputSelector0 performs a merge with any union data inside the SelectDropdownOptionActionInput_Selector, using the provided SelectDropdownOptionActionInputSelector0
func (t *SelectDropdownOptionActionInput_Selector) MergeSelectDropdownOptionActionInputSelector0(v SelectDropdownOptionActionInputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the SelectDropdownOptionActionInput_Selector as a NodeSelectors
func (t SelectDropdownOptionActionInput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the SelectDropdownOptionActionInput_Selector as the provided NodeSelectors
func (t *SelectDropdownOptionActionInput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the SelectDropdownOptionActionInput_Selector, using the provided NodeSelectors
func (t *SelectDropdownOptionActionInput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SelectDropdownOptionActionInput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SelectDropdownOptionActionInput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSelectDropdownOptionActionInputValue0 returns the union data inside the SelectDropdownOptionActionInput_Value as a SelectDropdownOptionActionInputValue0
func (t SelectDropdownOptionActionInput_Value) AsSelectDropdownOptionActionInputValue0() (SelectDropdownOptionActionInputValue0, error) {
	var body SelectDropdownOptionActionInputValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectDropdownOptionActionInputValue0 overwrites any union data inside the SelectDropdownOptionActionInput_Value as the provided SelectDropdownOptionActionInputValue0
func (t *SelectDropdownOptionActionInput_Value) FromSelectDropdownOptionActionInputValue0(v SelectDropdownOptionActionInputValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectDropdownOptionActionInputValue0 performs a merge with any union data inside the SelectDropdownOptionActionInput_Value, using the provided SelectDropdownOptionActionInputValue0
func (t *SelectDropdownOptionActionInput_Value) MergeSelectDropdownOptionActionInputValue0(v SelectDropdownOptionActionInputValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectDropdownOptionActionInputValue1 returns the union data inside the SelectDropdownOptionActionInput_Value as a SelectDropdownOptionActionInputValue1
func (t SelectDropdownOptionActionInput_Value) AsSelectDropdownOptionActionInputValue1() (SelectDropdownOptionActionInputValue1, error) {
	var body SelectDropdownOptionActionInputValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectDropdownOptionActionInputValue1 overwrites any union data inside the SelectDropdownOptionActionInput_Value as the provided SelectDropdownOptionActionInputValue1
func (t *SelectDropdownOptionActionInput_Value) FromSelectDropdownOptionActionInputValue1(v SelectDropdownOptionActionInputValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectDropdownOptionActionInputValue1 performs a merge with any union data inside the SelectDropdownOptionActionInput_Value, using the provided SelectDropdownOptionActionInputValue1
func (t *SelectDropdownOptionActionInput_Value) MergeSelectDropdownOptionActionInputValue1(v SelectDropdownOptionActionInputValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SelectDropdownOptionActionInput_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SelectDropdownOptionActionInput_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSelectDropdownOptionActionOutputSelector0 returns the union data inside the SelectDropdownOptionActionOutput_Selector as a SelectDropdownOptionActionOutputSelector0
func (t SelectDropdownOptionActionOutput_Selector) AsSelectDropdownOptionActionOutputSelector0() (SelectDropdownOptionActionOutputSelector0, error) {
	var body SelectDropdownOptionActionOutputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectDropdownOptionActionOutputSelector0 overwrites any union data inside the SelectDropdownOptionActionOutput_Selector as the provided SelectDropdownOptionActionOutputSelector0
func (t *SelectDropdownOptionActionOutput_Selector) FromSelectDropdownOptionActionOutputSelector0(v SelectDropdownOptionActionOutputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectDropdownOptionActionOutputSelector0 performs a merge with any union data inside the SelectDropdownOptionActionOutput_Selector, using the provided SelectDropdownOptionActionOutputSelector0
func (t *SelectDropdownOptionActionOutput_Selector) MergeSelectDropdownOptionActionOutputSelector0(v SelectDropdownOptionActionOutputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the SelectDropdownOptionActionOutput_Selector as a NodeSelectors
func (t SelectDropdownOptionActionOutput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the SelectDropdownOptionActionOutput_Selector as the provided NodeSelectors
func (t *SelectDropdownOptionActionOutput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the SelectDropdownOptionActionOutput_Selector, using the provided NodeSelectors
func (t *SelectDropdownOptionActionOutput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SelectDropdownOptionActionOutput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SelectDropdownOptionActionOutput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSelectDropdownOptionActionOutputValue0 returns the union data inside the SelectDropdownOptionActionOutput_Value as a SelectDropdownOptionActionOutputValue0
func (t SelectDropdownOptionActionOutput_Value) AsSelectDropdownOptionActionOutputValue0() (SelectDropdownOptionActionOutputValue0, error) {
	var body SelectDropdownOptionActionOutputValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectDropdownOptionActionOutputValue0 overwrites any union data inside the SelectDropdownOptionActionOutput_Value as the provided SelectDropdownOptionActionOutputValue0
func (t *SelectDropdownOptionActionOutput_Value) FromSelectDropdownOptionActionOutputValue0(v SelectDropdownOptionActionOutputValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectDropdownOptionActionOutputValue0 performs a merge with any union data inside the SelectDropdownOptionActionOutput_Value, using the provided SelectDropdownOptionActionOutputValue0
func (t *SelectDropdownOptionActionOutput_Value) MergeSelectDropdownOptionActionOutputValue0(v SelectDropdownOptionActionOutputValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectDropdownOptionActionOutputValue1 returns the union data inside the SelectDropdownOptionActionOutput_Value as a SelectDropdownOptionActionOutputValue1
func (t SelectDropdownOptionActionOutput_Value) AsSelectDropdownOptionActionOutputValue1() (SelectDropdownOptionActionOutputValue1, error) {
	var body SelectDropdownOptionActionOutputValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectDropdownOptionActionOutputValue1 overwrites any union data inside the SelectDropdownOptionActionOutput_Value as the provided SelectDropdownOptionActionOutputValue1
func (t *SelectDropdownOptionActionOutput_Value) FromSelectDropdownOptionActionOutputValue1(v SelectDropdownOptionActionOutputValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectDropdownOptionActionOutputValue1 performs a merge with any union data inside the SelectDropdownOptionActionOutput_Value, using the provided SelectDropdownOptionActionOutputValue1
func (t *SelectDropdownOptionActionOutput_Value) MergeSelectDropdownOptionActionOutputValue1(v SelectDropdownOptionActionOutputValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SelectDropdownOptionActionOutput_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SelectDropdownOptionActionOutput_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseModel returns the union data inside the StructuredDataBaseModel_Data as a BaseModel
func (t StructuredDataBaseModel_Data) AsBaseModel() (BaseModel, error) {
	var body BaseModel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseModel overwrites any union data inside the StructuredDataBaseModel_Data as the provided BaseModel
func (t *StructuredDataBaseModel_Data) FromBaseModel(v BaseModel) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseModel performs a merge with any union data inside the StructuredDataBaseModel_Data, using the provided BaseModel
func (t *StructuredDataBaseModel_Data) MergeBaseModel(v BaseModel) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRootModelUnionDictStrAnyListDictStrAny returns the union data inside the StructuredDataBaseModel_Data as a RootModelUnionDictStrAnyListDictStrAny
func (t StructuredDataBaseModel_Data) AsRootModelUnionDictStrAnyListDictStrAny() (RootModelUnionDictStrAnyListDictStrAny, error) {
	var body RootModelUnionDictStrAnyListDictStrAny
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRootModelUnionDictStrAnyListDictStrAny overwrites any union data inside the StructuredDataBaseModel_Data as the provided RootModelUnionDictStrAnyListDictStrAny
func (t *StructuredDataBaseModel_Data) FromRootModelUnionDictStrAnyListDictStrAny(v RootModelUnionDictStrAnyListDictStrAny) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRootModelUnionDictStrAnyListDictStrAny performs a merge with any union data inside the StructuredDataBaseModel_Data, using the provided RootModelUnionDictStrAnyListDictStrAny
func (t *StructuredDataBaseModel_Data) MergeRootModelUnionDictStrAnyListDictStrAny(v RootModelUnionDictStrAnyListDictStrAny) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StructuredDataBaseModel_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StructuredDataBaseModel_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUploadFileActionInputSelector0 returns the union data inside the UploadFileActionInput_Selector as a UploadFileActionInputSelector0
func (t UploadFileActionInput_Selector) AsUploadFileActionInputSelector0() (UploadFileActionInputSelector0, error) {
	var body UploadFileActionInputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUploadFileActionInputSelector0 overwrites any union data inside the UploadFileActionInput_Selector as the provided UploadFileActionInputSelector0
func (t *UploadFileActionInput_Selector) FromUploadFileActionInputSelector0(v UploadFileActionInputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUploadFileActionInputSelector0 performs a merge with any union data inside the UploadFileActionInput_Selector, using the provided UploadFileActionInputSelector0
func (t *UploadFileActionInput_Selector) MergeUploadFileActionInputSelector0(v UploadFileActionInputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the UploadFileActionInput_Selector as a NodeSelectors
func (t UploadFileActionInput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the UploadFileActionInput_Selector as the provided NodeSelectors
func (t *UploadFileActionInput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the UploadFileActionInput_Selector, using the provided NodeSelectors
func (t *UploadFileActionInput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UploadFileActionInput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UploadFileActionInput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUploadFileActionOutputSelector0 returns the union data inside the UploadFileActionOutput_Selector as a UploadFileActionOutputSelector0
func (t UploadFileActionOutput_Selector) AsUploadFileActionOutputSelector0() (UploadFileActionOutputSelector0, error) {
	var body UploadFileActionOutputSelector0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUploadFileActionOutputSelector0 overwrites any union data inside the UploadFileActionOutput_Selector as the provided UploadFileActionOutputSelector0
func (t *UploadFileActionOutput_Selector) FromUploadFileActionOutputSelector0(v UploadFileActionOutputSelector0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUploadFileActionOutputSelector0 performs a merge with any union data inside the UploadFileActionOutput_Selector, using the provided UploadFileActionOutputSelector0
func (t *UploadFileActionOutput_Selector) MergeUploadFileActionOutputSelector0(v UploadFileActionOutputSelector0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNodeSelectors returns the union data inside the UploadFileActionOutput_Selector as a NodeSelectors
func (t UploadFileActionOutput_Selector) AsNodeSelectors() (NodeSelectors, error) {
	var body NodeSelectors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNodeSelectors overwrites any union data inside the UploadFileActionOutput_Selector as the provided NodeSelectors
func (t *UploadFileActionOutput_Selector) FromNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNodeSelectors performs a merge with any union data inside the UploadFileActionOutput_Selector, using the provided NodeSelectors
func (t *UploadFileActionOutput_Selector) MergeNodeSelectors(v NodeSelectors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UploadFileActionOutput_Selector) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UploadFileActionOutput_Selector) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSubscriptionType returns the union data inside the UsageResponse_PlanType as a SubscriptionType
func (t UsageResponse_PlanType) AsSubscriptionType() (SubscriptionType, error) {
	var body SubscriptionType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubscriptionType overwrites any union data inside the UsageResponse_PlanType as the provided SubscriptionType
func (t *UsageResponse_PlanType) FromSubscriptionType(v SubscriptionType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubscriptionType performs a merge with any union data inside the UsageResponse_PlanType, using the provided SubscriptionType
func (t *UsageResponse_PlanType) MergeSubscriptionType(v SubscriptionType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUsageResponsePlanType1 returns the union data inside the UsageResponse_PlanType as a UsageResponsePlanType1
func (t UsageResponse_PlanType) AsUsageResponsePlanType1() (UsageResponsePlanType1, error) {
	var body UsageResponsePlanType1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUsageResponsePlanType1 overwrites any union data inside the UsageResponse_PlanType as the provided UsageResponsePlanType1
func (t *UsageResponse_PlanType) FromUsageResponsePlanType1(v UsageResponsePlanType1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUsageResponsePlanType1 performs a merge with any union data inside the UsageResponse_PlanType, using the provided UsageResponsePlanType1
func (t *UsageResponse_PlanType) MergeUsageResponsePlanType1(v UsageResponsePlanType1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UsageResponse_PlanType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UsageResponse_PlanType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsValidationErrorLoc0 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc0
func (t ValidationError_Loc_Item) AsValidationErrorLoc0() (ValidationErrorLoc0, error) {
	var body ValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc0 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) FromValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc0 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLoc1 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc1
func (t ValidationError_Loc_Item) AsValidationErrorLoc1() (ValidationErrorLoc1, error) {
	var body ValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc1 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) FromValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc1 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func newGeneratedClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAgents request
	ListAgents(ctx context.Context, params *ListAgentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentStartWithBody request with any body
	AgentStartWithBody(ctx context.Context, params *AgentStartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AgentStart(ctx context.Context, params *AgentStartParams, body AgentStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentStatus request
	AgentStatus(ctx context.Context, agentId string, params *AgentStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentReplay request
	AgentReplay(ctx context.Context, agentId string, params *AgentReplayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentStop request
	AgentStop(ctx context.Context, agentId string, params *AgentStopParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScript request
	GetScript(ctx context.Context, agentId string, params *GetScriptParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFunctions request
	ListFunctions(ctx context.Context, params *ListFunctionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionCreateWithBody request with any body
	FunctionCreateWithBody(ctx context.Context, params *FunctionCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionDelete request
	FunctionDelete(ctx context.Context, functionId string, params *FunctionDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionDownloadUrl request
	FunctionDownloadUrl(ctx context.Context, functionId string, params *FunctionDownloadUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionUpdateWithBody request with any body
	FunctionUpdateWithBody(ctx context.Context, functionId string, params *FunctionUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionFork request
	FunctionFork(ctx context.Context, functionId string, params *FunctionForkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFunctionRunsByFunctionId request
	ListFunctionRunsByFunctionId(ctx context.Context, functionId string, params *ListFunctionRunsByFunctionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionRunStart request
	FunctionRunStart(ctx context.Context, functionId string, params *FunctionRunStartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionRunStop request
	FunctionRunStop(ctx context.Context, functionId string, runId string, params *FunctionRunStopParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionRunGetMetadata request
	FunctionRunGetMetadata(ctx context.Context, functionId string, runId string, params *FunctionRunGetMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionRunUpdateMetadataWithBody request with any body
	FunctionRunUpdateMetadataWithBody(ctx context.Context, functionId string, runId string, params *FunctionRunUpdateMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FunctionRunUpdateMetadata(ctx context.Context, functionId string, runId string, params *FunctionRunUpdateMetadataParams, body FunctionRunUpdateMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionScheduleDelete request
	FunctionScheduleDelete(ctx context.Context, functionId string, params *FunctionScheduleDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionScheduleSetWithBody request with any body
	FunctionScheduleSetWithBody(ctx context.Context, functionId string, params *FunctionScheduleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FunctionScheduleSet(ctx context.Context, functionId string, params *FunctionScheduleSetParams, body FunctionScheduleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPersonas request
	ListPersonas(ctx context.Context, params *ListPersonasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonaCreateWithBody request with any body
	PersonaCreateWithBody(ctx context.Context, params *PersonaCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PersonaCreate(ctx context.Context, params *PersonaCreateParams, body PersonaCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonaDelete request
	PersonaDelete(ctx context.Context, personaId string, params *PersonaDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonaGet request
	PersonaGet(ctx context.Context, personaId string, params *PersonaGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonaEmailsList request
	PersonaEmailsList(ctx context.Context, personaId string, params *PersonaEmailsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonaSmsList request
	PersonaSmsList(ctx context.Context, personaId string, params *PersonaSmsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonaDeleteNumber request
	PersonaDeleteNumber(ctx context.Context, personaId string, params *PersonaDeleteNumberParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersonaCreateNumber request
	PersonaCreateNumber(ctx context.Context, personaId string, params *PersonaCreateNumberParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileList request
	ProfileList(ctx context.Context, params *ProfileListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileCreateWithBody request with any body
	ProfileCreateWithBody(ctx context.Context, params *ProfileCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProfileCreate(ctx context.Context, params *ProfileCreateParams, body ProfileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileDelete request
	ProfileDelete(ctx context.Context, profileId string, params *ProfileDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileGet request
	ProfileGet(ctx context.Context, profileId string, params *ProfileGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImprovePromptWithBody request with any body
	ImprovePromptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImprovePrompt(ctx context.Context, body ImprovePromptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NudgePromptWithBody request with any body
	NudgePromptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NudgePrompt(ctx context.Context, body NudgePromptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScrapeWebpageWithBody request with any body
	ScrapeWebpageWithBody(ctx context.Context, params *ScrapeWebpageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScrapeWebpage(ctx context.Context, params *ScrapeWebpageParams, body ScrapeWebpageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScrapeFromHtmlWithBody request with any body
	ScrapeFromHtmlWithBody(ctx context.Context, params *ScrapeFromHtmlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScrapeFromHtml(ctx context.Context, params *ScrapeFromHtmlParams, body ScrapeFromHtmlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSessions request
	ListSessions(ctx context.Context, params *ListSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionStartWithBody request with any body
	SessionStartWithBody(ctx context.Context, params *SessionStartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SessionStart(ctx context.Context, params *SessionStartParams, body SessionStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionStatus request
	SessionStatus(ctx context.Context, sessionId string, params *SessionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionCookiesGet request
	SessionCookiesGet(ctx context.Context, sessionId string, params *SessionCookiesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionCookiesSetWithBody request with any body
	SessionCookiesSetWithBody(ctx context.Context, sessionId string, params *SessionCookiesSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SessionCookiesSet(ctx context.Context, sessionId string, params *SessionCookiesSetParams, body SessionCookiesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionDebugInfo request
	SessionDebugInfo(ctx context.Context, sessionId string, params *SessionDebugInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionNetworkLogs request
	SessionNetworkLogs(ctx context.Context, sessionId string, params *SessionNetworkLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionOffset request
	SessionOffset(ctx context.Context, sessionId string, params *SessionOffsetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PageExecuteWithBody request with any body
	PageExecuteWithBody(ctx context.Context, sessionId string, params *PageExecuteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PageExecute(ctx context.Context, sessionId string, params *PageExecuteParams, body PageExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PageObserveWithBody request with any body
	PageObserveWithBody(ctx context.Context, sessionId string, params *PageObserveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PageObserve(ctx context.Context, sessionId string, params *PageObserveParams, body PageObserveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PageScrapeWithBody request with any body
	PageScrapeWithBody(ctx context.Context, sessionId string, params *PageScrapeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PageScrape(ctx context.Context, sessionId string, params *PageScrapeParams, body PageScrapeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionReplay request
	SessionReplay(ctx context.Context, sessionId string, params *SessionReplayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SessionStop request
	SessionStop(ctx context.Context, sessionId string, params *SessionStopParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionScript request
	GetSessionScript(ctx context.Context, sessionId string, params *GetSessionScriptParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileListUploads request
	FileListUploads(ctx context.Context, params *FileListUploadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileUploadWithBody request with any body
	FileUploadWithBody(ctx context.Context, filename string, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileListDownloads request
	FileListDownloads(ctx context.Context, sessionId string, params *FileListDownloadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileDownload request
	FileDownload(ctx context.Context, sessionId string, filename string, params *FileDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileUploadDownloadedFileWithBody request with any body
	FileUploadDownloadedFileWithBody(ctx context.Context, sessionId string, filename string, params *FileUploadDownloadedFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsage request
	GetUsage(ctx context.Context, params *GetUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageLogs request
	GetUsageLogs(ctx context.Context, params *GetUsageLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVaults request
	ListVaults(ctx context.Context, params *ListVaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultCreateWithBody request with any body
	VaultCreateWithBody(ctx context.Context, params *VaultCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VaultCreate(ctx context.Context, params *VaultCreateParams, body VaultCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultDelete request
	VaultDelete(ctx context.Context, vaultId string, params *VaultDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultCredentialsList request
	VaultCredentialsList(ctx context.Context, vaultId string, params *VaultCredentialsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultUpdateWithBody request with any body
	VaultUpdateWithBody(ctx context.Context, vaultId string, params *VaultUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VaultUpdate(ctx context.Context, vaultId string, params *VaultUpdateParams, body VaultUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultCreditCardDelete request
	VaultCreditCardDelete(ctx context.Context, vaultId string, params *VaultCreditCardDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultCreditCardGet request
	VaultCreditCardGet(ctx context.Context, vaultId string, params *VaultCreditCardGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultCreditCardSetWithBody request with any body
	VaultCreditCardSetWithBody(ctx context.Context, vaultId string, params *VaultCreditCardSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VaultCreditCardSet(ctx context.Context, vaultId string, params *VaultCreditCardSetParams, body VaultCreditCardSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultCredentialsDelete request
	VaultCredentialsDelete(ctx context.Context, vaultId string, params *VaultCredentialsDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultCredentialsGet request
	VaultCredentialsGet(ctx context.Context, vaultId string, params *VaultCredentialsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VaultCredentialsAddWithBody request with any body
	VaultCredentialsAddWithBody(ctx context.Context, vaultId string, params *VaultCredentialsAddParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VaultCredentialsAdd(ctx context.Context, vaultId string, params *VaultCredentialsAddParams, body VaultCredentialsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAgents(ctx context.Context, params *ListAgentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAgentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AgentStartWithBody(ctx context.Context, params *AgentStartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentStartRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AgentStart(ctx context.Context, params *AgentStartParams, body AgentStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentStartRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AgentStatus(ctx context.Context, agentId string, params *AgentStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentStatusRequest(c.Server, agentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AgentReplay(ctx context.Context, agentId string, params *AgentReplayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentReplayRequest(c.Server, agentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AgentStop(ctx context.Context, agentId string, params *AgentStopParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentStopRequest(c.Server, agentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScript(ctx context.Context, agentId string, params *GetScriptParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptRequest(c.Server, agentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFunctions(ctx context.Context, params *ListFunctionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFunctionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionCreateWithBody(ctx context.Context, params *FunctionCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionDelete(ctx context.Context, functionId string, params *FunctionDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionDeleteRequest(c.Server, functionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionDownloadUrl(ctx context.Context, functionId string, params *FunctionDownloadUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionDownloadUrlRequest(c.Server, functionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionUpdateWithBody(ctx context.Context, functionId string, params *FunctionUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionUpdateRequestWithBody(c.Server, functionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionFork(ctx context.Context, functionId string, params *FunctionForkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionForkRequest(c.Server, functionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFunctionRunsByFunctionId(ctx context.Context, functionId string, params *ListFunctionRunsByFunctionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFunctionRunsByFunctionIdRequest(c.Server, functionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionRunStart(ctx context.Context, functionId string, params *FunctionRunStartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionRunStartRequest(c.Server, functionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionRunStop(ctx context.Context, functionId string, runId string, params *FunctionRunStopParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionRunStopRequest(c.Server, functionId, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionRunGetMetadata(ctx context.Context, functionId string, runId string, params *FunctionRunGetMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionRunGetMetadataRequest(c.Server, functionId, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionRunUpdateMetadataWithBody(ctx context.Context, functionId string, runId string, params *FunctionRunUpdateMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionRunUpdateMetadataRequestWithBody(c.Server, functionId, runId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionRunUpdateMetadata(ctx context.Context, functionId string, runId string, params *FunctionRunUpdateMetadataParams, body FunctionRunUpdateMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionRunUpdateMetadataRequest(c.Server, functionId, runId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionScheduleDelete(ctx context.Context, functionId string, params *FunctionScheduleDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionScheduleDeleteRequest(c.Server, functionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionScheduleSetWithBody(ctx context.Context, functionId string, params *FunctionScheduleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionScheduleSetRequestWithBody(c.Server, functionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionScheduleSet(ctx context.Context, functionId string, params *FunctionScheduleSetParams, body FunctionScheduleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionScheduleSetRequest(c.Server, functionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPersonas(ctx context.Context, params *ListPersonasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPersonasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonaCreateWithBody(ctx context.Context, params *PersonaCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonaCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonaCreate(ctx context.Context, params *PersonaCreateParams, body PersonaCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonaCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonaDelete(ctx context.Context, personaId string, params *PersonaDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonaDeleteRequest(c.Server, personaId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonaGet(ctx context.Context, personaId string, params *PersonaGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonaGetRequest(c.Server, personaId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonaEmailsList(ctx context.Context, personaId string, params *PersonaEmailsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonaEmailsListRequest(c.Server, personaId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonaSmsList(ctx context.Context, personaId string, params *PersonaSmsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonaSmsListRequest(c.Server, personaId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonaDeleteNumber(ctx context.Context, personaId string, params *PersonaDeleteNumberParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonaDeleteNumberRequest(c.Server, personaId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersonaCreateNumber(ctx context.Context, personaId string, params *PersonaCreateNumberParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersonaCreateNumberRequest(c.Server, personaId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileList(ctx context.Context, params *ProfileListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileCreateWithBody(ctx context.Context, params *ProfileCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileCreate(ctx context.Context, params *ProfileCreateParams, body ProfileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileDelete(ctx context.Context, profileId string, params *ProfileDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileDeleteRequest(c.Server, profileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileGet(ctx context.Context, profileId string, params *ProfileGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileGetRequest(c.Server, profileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImprovePromptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImprovePromptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImprovePrompt(ctx context.Context, body ImprovePromptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImprovePromptRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NudgePromptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNudgePromptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NudgePrompt(ctx context.Context, body NudgePromptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNudgePromptRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScrapeWebpageWithBody(ctx context.Context, params *ScrapeWebpageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrapeWebpageRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScrapeWebpage(ctx context.Context, params *ScrapeWebpageParams, body ScrapeWebpageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrapeWebpageRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScrapeFromHtmlWithBody(ctx context.Context, params *ScrapeFromHtmlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrapeFromHtmlRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScrapeFromHtml(ctx context.Context, params *ScrapeFromHtmlParams, body ScrapeFromHtmlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrapeFromHtmlRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSessions(ctx context.Context, params *ListSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionStartWithBody(ctx context.Context, params *SessionStartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionStartRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionStart(ctx context.Context, params *SessionStartParams, body SessionStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionStartRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionStatus(ctx context.Context, sessionId string, params *SessionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionStatusRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionCookiesGet(ctx context.Context, sessionId string, params *SessionCookiesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionCookiesGetRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionCookiesSetWithBody(ctx context.Context, sessionId string, params *SessionCookiesSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionCookiesSetRequestWithBody(c.Server, sessionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionCookiesSet(ctx context.Context, sessionId string, params *SessionCookiesSetParams, body SessionCookiesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionCookiesSetRequest(c.Server, sessionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionDebugInfo(ctx context.Context, sessionId string, params *SessionDebugInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionDebugInfoRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionNetworkLogs(ctx context.Context, sessionId string, params *SessionNetworkLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionNetworkLogsRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionOffset(ctx context.Context, sessionId string, params *SessionOffsetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionOffsetRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PageExecuteWithBody(ctx context.Context, sessionId string, params *PageExecuteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPageExecuteRequestWithBody(c.Server, sessionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PageExecute(ctx context.Context, sessionId string, params *PageExecuteParams, body PageExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPageExecuteRequest(c.Server, sessionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PageObserveWithBody(ctx context.Context, sessionId string, params *PageObserveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPageObserveRequestWithBody(c.Server, sessionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PageObserve(ctx context.Context, sessionId string, params *PageObserveParams, body PageObserveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPageObserveRequest(c.Server, sessionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PageScrapeWithBody(ctx context.Context, sessionId string, params *PageScrapeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPageScrapeRequestWithBody(c.Server, sessionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PageScrape(ctx context.Context, sessionId string, params *PageScrapeParams, body PageScrapeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPageScrapeRequest(c.Server, sessionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionReplay(ctx context.Context, sessionId string, params *SessionReplayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionReplayRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SessionStop(ctx context.Context, sessionId string, params *SessionStopParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSessionStopRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionScript(ctx context.Context, sessionId string, params *GetSessionScriptParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionScriptRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileListUploads(ctx context.Context, params *FileListUploadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileListUploadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileUploadWithBody(ctx context.Context, filename string, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileUploadRequestWithBody(c.Server, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileListDownloads(ctx context.Context, sessionId string, params *FileListDownloadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileListDownloadsRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileDownload(ctx context.Context, sessionId string, filename string, params *FileDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileDownloadRequest(c.Server, sessionId, filename, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileUploadDownloadedFileWithBody(ctx context.Context, sessionId string, filename string, params *FileUploadDownloadedFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileUploadDownloadedFileRequestWithBody(c.Server, sessionId, filename, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsage(ctx context.Context, params *GetUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageLogs(ctx context.Context, params *GetUsageLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVaults(ctx context.Context, params *ListVaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVaultsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCreateWithBody(ctx context.Context, params *VaultCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCreate(ctx context.Context, params *VaultCreateParams, body VaultCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultDelete(ctx context.Context, vaultId string, params *VaultDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultDeleteRequest(c.Server, vaultId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCredentialsList(ctx context.Context, vaultId string, params *VaultCredentialsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCredentialsListRequest(c.Server, vaultId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultUpdateWithBody(ctx context.Context, vaultId string, params *VaultUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultUpdateRequestWithBody(c.Server, vaultId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultUpdate(ctx context.Context, vaultId string, params *VaultUpdateParams, body VaultUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultUpdateRequest(c.Server, vaultId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCreditCardDelete(ctx context.Context, vaultId string, params *VaultCreditCardDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCreditCardDeleteRequest(c.Server, vaultId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCreditCardGet(ctx context.Context, vaultId string, params *VaultCreditCardGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCreditCardGetRequest(c.Server, vaultId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCreditCardSetWithBody(ctx context.Context, vaultId string, params *VaultCreditCardSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCreditCardSetRequestWithBody(c.Server, vaultId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCreditCardSet(ctx context.Context, vaultId string, params *VaultCreditCardSetParams, body VaultCreditCardSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCreditCardSetRequest(c.Server, vaultId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCredentialsDelete(ctx context.Context, vaultId string, params *VaultCredentialsDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCredentialsDeleteRequest(c.Server, vaultId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCredentialsGet(ctx context.Context, vaultId string, params *VaultCredentialsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCredentialsGetRequest(c.Server, vaultId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCredentialsAddWithBody(ctx context.Context, vaultId string, params *VaultCredentialsAddParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCredentialsAddRequestWithBody(c.Server, vaultId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VaultCredentialsAdd(ctx context.Context, vaultId string, params *VaultCredentialsAddParams, body VaultCredentialsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVaultCredentialsAddRequest(c.Server, vaultId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAgentsRequest generates requests for ListAgents
func NewListAgentsRequest(server string, params *ListAgentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_active", runtime.ParamLocationQuery, *params.OnlyActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlySaved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_saved", runtime.ParamLocationQuery, *params.OnlySaved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyCurrentToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_current_token", runtime.ParamLocationQuery, *params.OnlyCurrentToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewAgentStartRequest calls the generic AgentStart builder with application/json body
func NewAgentStartRequest(server string, params *AgentStartParams, body AgentStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAgentStartRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAgentStartRequestWithBody generates requests for AgentStart with any type of body
func NewAgentStartRequestWithBody(server string, params *AgentStartParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewAgentStatusRequest generates requests for AgentStatus
func NewAgentStatusRequest(server string, agentId string, params *AgentStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agent_id", runtime.ParamLocationPath, agentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewAgentReplayRequest generates requests for AgentReplay
func NewAgentReplayRequest(server string, agentId string, params *AgentReplayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agent_id", runtime.ParamLocationPath, agentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s/replay", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewAgentStopRequest generates requests for AgentStop
func NewAgentStopRequest(server string, agentId string, params *AgentStopParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agent_id", runtime.ParamLocationPath, agentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewGetScriptRequest generates requests for GetScript
func NewGetScriptRequest(server string, agentId string, params *GetScriptParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agent_id", runtime.ParamLocationPath, agentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agents/%s/workflow/code", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "as_workflow", runtime.ParamLocationQuery, params.AsWorkflow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewListFunctionsRequest generates requests for ListFunctions
func NewListFunctionsRequest(server string, params *ListFunctionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_active", runtime.ParamLocationQuery, *params.OnlyActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyCurrentToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_current_token", runtime.ParamLocationQuery, *params.OnlyCurrentToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionCreateRequestWithBody generates requests for FunctionCreate with any type of body
func NewFunctionCreateRequestWithBody(server string, params *FunctionCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Restricted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restricted", runtime.ParamLocationQuery, *params.Restricted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionDeleteRequest generates requests for FunctionDelete
func NewFunctionDeleteRequest(server string, functionId string, params *FunctionDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionDownloadUrlRequest generates requests for FunctionDownloadUrl
func NewFunctionDownloadUrlRequest(server string, functionId string, params *FunctionDownloadUrlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DecryptionKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "decryption_key", runtime.ParamLocationQuery, *params.DecryptionKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionUpdateRequestWithBody generates requests for FunctionUpdate with any type of body
func NewFunctionUpdateRequestWithBody(server string, functionId string, params *FunctionUpdateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Restricted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restricted", runtime.ParamLocationQuery, *params.Restricted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionForkRequest generates requests for FunctionFork
func NewFunctionForkRequest(server string, functionId string, params *FunctionForkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/fork", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewListFunctionRunsByFunctionIdRequest generates requests for ListFunctionRunsByFunctionId
func NewListFunctionRunsByFunctionIdRequest(server string, functionId string, params *ListFunctionRunsByFunctionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_active", runtime.ParamLocationQuery, *params.OnlyActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyCurrentToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_current_token", runtime.ParamLocationQuery, *params.OnlyCurrentToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionRunStartRequest generates requests for FunctionRunStart
func NewFunctionRunStartRequest(server string, functionId string, params *FunctionRunStartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/runs/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-api-key", runtime.ParamLocationHeader, params.XNotteApiKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-notte-api-key", headerParam0)

		if params.XNotteRequestOrigin != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam1)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam2)
		}

	}

	return req, nil
}

// NewFunctionRunStopRequest generates requests for FunctionRunStop
func NewFunctionRunStopRequest(server string, functionId string, runId string, params *FunctionRunStopParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionRunGetMetadataRequest generates requests for FunctionRunGetMetadata
func NewFunctionRunGetMetadataRequest(server string, functionId string, runId string, params *FunctionRunGetMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionRunUpdateMetadataRequest calls the generic FunctionRunUpdateMetadata builder with application/json body
func NewFunctionRunUpdateMetadataRequest(server string, functionId string, runId string, params *FunctionRunUpdateMetadataParams, body FunctionRunUpdateMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFunctionRunUpdateMetadataRequestWithBody(server, functionId, runId, params, "application/json", bodyReader)
}

// NewFunctionRunUpdateMetadataRequestWithBody generates requests for FunctionRunUpdateMetadata with any type of body
func NewFunctionRunUpdateMetadataRequestWithBody(server string, functionId string, runId string, params *FunctionRunUpdateMetadataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionScheduleDeleteRequest generates requests for FunctionScheduleDelete
func NewFunctionScheduleDeleteRequest(server string, functionId string, params *FunctionScheduleDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFunctionScheduleSetRequest calls the generic FunctionScheduleSet builder with application/json body
func NewFunctionScheduleSetRequest(server string, functionId string, params *FunctionScheduleSetParams, body FunctionScheduleSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFunctionScheduleSetRequestWithBody(server, functionId, params, "application/json", bodyReader)
}

// NewFunctionScheduleSetRequestWithBody generates requests for FunctionScheduleSet with any type of body
func NewFunctionScheduleSetRequestWithBody(server string, functionId string, params *FunctionScheduleSetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "function_id", runtime.ParamLocationPath, functionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPersonasRequest generates requests for ListPersonas
func NewListPersonasRequest(server string, params *ListPersonasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_active", runtime.ParamLocationQuery, *params.OnlyActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyCurrentToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_current_token", runtime.ParamLocationQuery, *params.OnlyCurrentToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPersonaCreateRequest calls the generic PersonaCreate builder with application/json body
func NewPersonaCreateRequest(server string, params *PersonaCreateParams, body PersonaCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPersonaCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPersonaCreateRequestWithBody generates requests for PersonaCreate with any type of body
func NewPersonaCreateRequestWithBody(server string, params *PersonaCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personas/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPersonaDeleteRequest generates requests for PersonaDelete
func NewPersonaDeleteRequest(server string, personaId string, params *PersonaDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "persona_id", runtime.ParamLocationPath, personaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPersonaGetRequest generates requests for PersonaGet
func NewPersonaGetRequest(server string, personaId string, params *PersonaGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "persona_id", runtime.ParamLocationPath, personaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPersonaEmailsListRequest generates requests for PersonaEmailsList
func NewPersonaEmailsListRequest(server string, personaId string, params *PersonaEmailsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "persona_id", runtime.ParamLocationPath, personaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personas/%s/emails", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timedelta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timedelta", runtime.ParamLocationQuery, *params.Timedelta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyUnread != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_unread", runtime.ParamLocationQuery, *params.OnlyUnread); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPersonaSmsListRequest generates requests for PersonaSmsList
func NewPersonaSmsListRequest(server string, personaId string, params *PersonaSmsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "persona_id", runtime.ParamLocationPath, personaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personas/%s/sms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timedelta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timedelta", runtime.ParamLocationQuery, *params.Timedelta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyUnread != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_unread", runtime.ParamLocationQuery, *params.OnlyUnread); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPersonaDeleteNumberRequest generates requests for PersonaDeleteNumber
func NewPersonaDeleteNumberRequest(server string, personaId string, params *PersonaDeleteNumberParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "persona_id", runtime.ParamLocationPath, personaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personas/%s/sms/number", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPersonaCreateNumberRequest generates requests for PersonaCreateNumber
func NewPersonaCreateNumberRequest(server string, personaId string, params *PersonaCreateNumberParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "persona_id", runtime.ParamLocationPath, personaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/personas/%s/sms/number", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewProfileListRequest generates requests for ProfileList
func NewProfileListRequest(server string, params *ProfileListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewProfileCreateRequest calls the generic ProfileCreate builder with application/json body
func NewProfileCreateRequest(server string, params *ProfileCreateParams, body ProfileCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProfileCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewProfileCreateRequestWithBody generates requests for ProfileCreate with any type of body
func NewProfileCreateRequestWithBody(server string, params *ProfileCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profiles/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewProfileDeleteRequest generates requests for ProfileDelete
func NewProfileDeleteRequest(server string, profileId string, params *ProfileDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profile_id", runtime.ParamLocationPath, profileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewProfileGetRequest generates requests for ProfileGet
func NewProfileGetRequest(server string, profileId string, params *ProfileGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profile_id", runtime.ParamLocationPath, profileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewImprovePromptRequest calls the generic ImprovePrompt builder with application/json body
func NewImprovePromptRequest(server string, body ImprovePromptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImprovePromptRequestWithBody(server, "application/json", bodyReader)
}

// NewImprovePromptRequestWithBody generates requests for ImprovePrompt with any type of body
func NewImprovePromptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/prompts/improve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNudgePromptRequest calls the generic NudgePrompt builder with application/json body
func NewNudgePromptRequest(server string, body NudgePromptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNudgePromptRequestWithBody(server, "application/json", bodyReader)
}

// NewNudgePromptRequestWithBody generates requests for NudgePrompt with any type of body
func NewNudgePromptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/prompts/nudge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScrapeWebpageRequest calls the generic ScrapeWebpage builder with application/json body
func NewScrapeWebpageRequest(server string, params *ScrapeWebpageParams, body ScrapeWebpageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScrapeWebpageRequestWithBody(server, params, "application/json", bodyReader)
}

// NewScrapeWebpageRequestWithBody generates requests for ScrapeWebpage with any type of body
func NewScrapeWebpageRequestWithBody(server string, params *ScrapeWebpageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrape")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewScrapeFromHtmlRequest calls the generic ScrapeFromHtml builder with application/json body
func NewScrapeFromHtmlRequest(server string, params *ScrapeFromHtmlParams, body ScrapeFromHtmlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScrapeFromHtmlRequestWithBody(server, params, "application/json", bodyReader)
}

// NewScrapeFromHtmlRequestWithBody generates requests for ScrapeFromHtml with any type of body
func NewScrapeFromHtmlRequestWithBody(server string, params *ScrapeFromHtmlParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scrape_from_html")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewListSessionsRequest generates requests for ListSessions
func NewListSessionsRequest(server string, params *ListSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_active", runtime.ParamLocationQuery, *params.OnlyActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyCurrentToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_current_token", runtime.ParamLocationQuery, *params.OnlyCurrentToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewSessionStartRequest calls the generic SessionStart builder with application/json body
func NewSessionStartRequest(server string, params *SessionStartParams, body SessionStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSessionStartRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSessionStartRequestWithBody generates requests for SessionStart with any type of body
func NewSessionStartRequestWithBody(server string, params *SessionStartParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewSessionStatusRequest generates requests for SessionStatus
func NewSessionStatusRequest(server string, sessionId string, params *SessionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewSessionCookiesGetRequest generates requests for SessionCookiesGet
func NewSessionCookiesGetRequest(server string, sessionId string, params *SessionCookiesGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/cookies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewSessionCookiesSetRequest calls the generic SessionCookiesSet builder with application/json body
func NewSessionCookiesSetRequest(server string, sessionId string, params *SessionCookiesSetParams, body SessionCookiesSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSessionCookiesSetRequestWithBody(server, sessionId, params, "application/json", bodyReader)
}

// NewSessionCookiesSetRequestWithBody generates requests for SessionCookiesSet with any type of body
func NewSessionCookiesSetRequestWithBody(server string, sessionId string, params *SessionCookiesSetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/cookies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewSessionDebugInfoRequest generates requests for SessionDebugInfo
func NewSessionDebugInfoRequest(server string, sessionId string, params *SessionDebugInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/debug", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewSessionNetworkLogsRequest generates requests for SessionNetworkLogs
func NewSessionNetworkLogsRequest(server string, sessionId string, params *SessionNetworkLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/network/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Download != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "download", runtime.ParamLocationQuery, *params.Download); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewSessionOffsetRequest generates requests for SessionOffset
func NewSessionOffsetRequest(server string, sessionId string, params *SessionOffsetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/offset", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPageExecuteRequest calls the generic PageExecute builder with application/json body
func NewPageExecuteRequest(server string, sessionId string, params *PageExecuteParams, body PageExecuteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPageExecuteRequestWithBody(server, sessionId, params, "application/json", bodyReader)
}

// NewPageExecuteRequestWithBody generates requests for PageExecute with any type of body
func NewPageExecuteRequestWithBody(server string, sessionId string, params *PageExecuteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/page/execute", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPageObserveRequest calls the generic PageObserve builder with application/json body
func NewPageObserveRequest(server string, sessionId string, params *PageObserveParams, body PageObserveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPageObserveRequestWithBody(server, sessionId, params, "application/json", bodyReader)
}

// NewPageObserveRequestWithBody generates requests for PageObserve with any type of body
func NewPageObserveRequestWithBody(server string, sessionId string, params *PageObserveParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/page/observe", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewPageScrapeRequest calls the generic PageScrape builder with application/json body
func NewPageScrapeRequest(server string, sessionId string, params *PageScrapeParams, body PageScrapeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPageScrapeRequestWithBody(server, sessionId, params, "application/json", bodyReader)
}

// NewPageScrapeRequestWithBody generates requests for PageScrape with any type of body
func NewPageScrapeRequestWithBody(server string, sessionId string, params *PageScrapeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/page/scrape", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewSessionReplayRequest generates requests for SessionReplay
func NewSessionReplayRequest(server string, sessionId string, params *SessionReplayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/replay", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewSessionStopRequest generates requests for SessionStop
func NewSessionStopRequest(server string, sessionId string, params *SessionStopParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewGetSessionScriptRequest generates requests for GetSessionScript
func NewGetSessionScriptRequest(server string, sessionId string, params *GetSessionScriptParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sessions/%s/workflow/code", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "as_workflow", runtime.ParamLocationQuery, params.AsWorkflow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFileListUploadsRequest generates requests for FileListUploads
func NewFileListUploadsRequest(server string, params *FileListUploadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/uploads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFileUploadRequestWithBody generates requests for FileUpload with any type of body
func NewFileUploadRequestWithBody(server string, filename string, params *FileUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/uploads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFileListDownloadsRequest generates requests for FileListDownloads
func NewFileListDownloadsRequest(server string, sessionId string, params *FileListDownloadsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/downloads", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFileDownloadRequest generates requests for FileDownload
func NewFileDownloadRequest(server string, sessionId string, filename string, params *FileDownloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/downloads/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewFileUploadDownloadedFileRequestWithBody generates requests for FileUploadDownloadedFile with any type of body
func NewFileUploadDownloadedFileRequestWithBody(server string, sessionId string, filename string, params *FileUploadDownloadedFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "session_id", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filename", runtime.ParamLocationPath, filename)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storage/%s/downloads/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewGetUsageRequest generates requests for GetUsage
func NewGetUsageRequest(server string, params *GetUsageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Period != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period", runtime.ParamLocationQuery, *params.Period); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewGetUsageLogsRequest generates requests for GetUsageLogs
func NewGetUsageLogsRequest(server string, params *GetUsageLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Endpoint != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endpoint", runtime.ParamLocationQuery, *params.Endpoint); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_active", runtime.ParamLocationQuery, *params.OnlyActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyCurrentToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_current_token", runtime.ParamLocationQuery, *params.OnlyCurrentToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewListVaultsRequest generates requests for ListVaults
func NewListVaultsRequest(server string, params *ListVaultsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_active", runtime.ParamLocationQuery, *params.OnlyActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyCurrentToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_current_token", runtime.ParamLocationQuery, *params.OnlyCurrentToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultCreateRequest calls the generic VaultCreate builder with application/json body
func NewVaultCreateRequest(server string, params *VaultCreateParams, body VaultCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVaultCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewVaultCreateRequestWithBody generates requests for VaultCreate with any type of body
func NewVaultCreateRequestWithBody(server string, params *VaultCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultDeleteRequest generates requests for VaultDelete
func NewVaultDeleteRequest(server string, vaultId string, params *VaultDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultCredentialsListRequest generates requests for VaultCredentialsList
func NewVaultCredentialsListRequest(server string, vaultId string, params *VaultCredentialsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultUpdateRequest calls the generic VaultUpdate builder with application/json body
func NewVaultUpdateRequest(server string, vaultId string, params *VaultUpdateParams, body VaultUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVaultUpdateRequestWithBody(server, vaultId, params, "application/json", bodyReader)
}

// NewVaultUpdateRequestWithBody generates requests for VaultUpdate with any type of body
func NewVaultUpdateRequestWithBody(server string, vaultId string, params *VaultUpdateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultCreditCardDeleteRequest generates requests for VaultCreditCardDelete
func NewVaultCreditCardDeleteRequest(server string, vaultId string, params *VaultCreditCardDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s/card", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultCreditCardGetRequest generates requests for VaultCreditCardGet
func NewVaultCreditCardGetRequest(server string, vaultId string, params *VaultCreditCardGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s/card", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultCreditCardSetRequest calls the generic VaultCreditCardSet builder with application/json body
func NewVaultCreditCardSetRequest(server string, vaultId string, params *VaultCreditCardSetParams, body VaultCreditCardSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVaultCreditCardSetRequestWithBody(server, vaultId, params, "application/json", bodyReader)
}

// NewVaultCreditCardSetRequestWithBody generates requests for VaultCreditCardSet with any type of body
func NewVaultCreditCardSetRequestWithBody(server string, vaultId string, params *VaultCreditCardSetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s/card", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultCredentialsDeleteRequest generates requests for VaultCredentialsDelete
func NewVaultCredentialsDeleteRequest(server string, vaultId string, params *VaultCredentialsDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultCredentialsGetRequest generates requests for VaultCredentialsGet
func NewVaultCredentialsGetRequest(server string, vaultId string, params *VaultCredentialsGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

// NewVaultCredentialsAddRequest calls the generic VaultCredentialsAdd builder with application/json body
func NewVaultCredentialsAddRequest(server string, vaultId string, params *VaultCredentialsAddParams, body VaultCredentialsAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVaultCredentialsAddRequestWithBody(server, vaultId, params, "application/json", bodyReader)
}

// NewVaultCredentialsAddRequestWithBody generates requests for VaultCredentialsAdd with any type of body
func NewVaultCredentialsAddRequestWithBody(server string, vaultId string, params *VaultCredentialsAddParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vaults/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XNotteRequestOrigin != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-notte-request-origin", runtime.ParamLocationHeader, *params.XNotteRequestOrigin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-request-origin", headerParam0)
		}

		if params.XNotteSdkVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-notte-sdk-version", runtime.ParamLocationHeader, *params.XNotteSdkVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-notte-sdk-version", headerParam1)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := newGeneratedClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAgentsWithResponse request
	ListAgentsWithResponse(ctx context.Context, params *ListAgentsParams, reqEditors ...RequestEditorFn) (*ListAgentsResult, error)

	// AgentStartWithBodyWithResponse request with any body
	AgentStartWithBodyWithResponse(ctx context.Context, params *AgentStartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentStartResult, error)

	AgentStartWithResponse(ctx context.Context, params *AgentStartParams, body AgentStartJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentStartResult, error)

	// AgentStatusWithResponse request
	AgentStatusWithResponse(ctx context.Context, agentId string, params *AgentStatusParams, reqEditors ...RequestEditorFn) (*AgentStatusResult, error)

	// AgentReplayWithResponse request
	AgentReplayWithResponse(ctx context.Context, agentId string, params *AgentReplayParams, reqEditors ...RequestEditorFn) (*AgentReplayResult, error)

	// AgentStopWithResponse request
	AgentStopWithResponse(ctx context.Context, agentId string, params *AgentStopParams, reqEditors ...RequestEditorFn) (*AgentStopResult, error)

	// GetScriptWithResponse request
	GetScriptWithResponse(ctx context.Context, agentId string, params *GetScriptParams, reqEditors ...RequestEditorFn) (*GetScriptResult, error)

	// ListFunctionsWithResponse request
	ListFunctionsWithResponse(ctx context.Context, params *ListFunctionsParams, reqEditors ...RequestEditorFn) (*ListFunctionsResult, error)

	// FunctionCreateWithBodyWithResponse request with any body
	FunctionCreateWithBodyWithResponse(ctx context.Context, params *FunctionCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionCreateResult, error)

	// FunctionDeleteWithResponse request
	FunctionDeleteWithResponse(ctx context.Context, functionId string, params *FunctionDeleteParams, reqEditors ...RequestEditorFn) (*FunctionDeleteResult, error)

	// FunctionDownloadUrlWithResponse request
	FunctionDownloadUrlWithResponse(ctx context.Context, functionId string, params *FunctionDownloadUrlParams, reqEditors ...RequestEditorFn) (*FunctionDownloadUrlResult, error)

	// FunctionUpdateWithBodyWithResponse request with any body
	FunctionUpdateWithBodyWithResponse(ctx context.Context, functionId string, params *FunctionUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionUpdateResult, error)

	// FunctionForkWithResponse request
	FunctionForkWithResponse(ctx context.Context, functionId string, params *FunctionForkParams, reqEditors ...RequestEditorFn) (*FunctionForkResult, error)

	// ListFunctionRunsByFunctionIdWithResponse request
	ListFunctionRunsByFunctionIdWithResponse(ctx context.Context, functionId string, params *ListFunctionRunsByFunctionIdParams, reqEditors ...RequestEditorFn) (*ListFunctionRunsByFunctionIdResult, error)

	// FunctionRunStartWithResponse request
	FunctionRunStartWithResponse(ctx context.Context, functionId string, params *FunctionRunStartParams, reqEditors ...RequestEditorFn) (*FunctionRunStartResult, error)

	// FunctionRunStopWithResponse request
	FunctionRunStopWithResponse(ctx context.Context, functionId string, runId string, params *FunctionRunStopParams, reqEditors ...RequestEditorFn) (*FunctionRunStopResult, error)

	// FunctionRunGetMetadataWithResponse request
	FunctionRunGetMetadataWithResponse(ctx context.Context, functionId string, runId string, params *FunctionRunGetMetadataParams, reqEditors ...RequestEditorFn) (*FunctionRunGetMetadataResult, error)

	// FunctionRunUpdateMetadataWithBodyWithResponse request with any body
	FunctionRunUpdateMetadataWithBodyWithResponse(ctx context.Context, functionId string, runId string, params *FunctionRunUpdateMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionRunUpdateMetadataResult, error)

	FunctionRunUpdateMetadataWithResponse(ctx context.Context, functionId string, runId string, params *FunctionRunUpdateMetadataParams, body FunctionRunUpdateMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*FunctionRunUpdateMetadataResult, error)

	// FunctionScheduleDeleteWithResponse request
	FunctionScheduleDeleteWithResponse(ctx context.Context, functionId string, params *FunctionScheduleDeleteParams, reqEditors ...RequestEditorFn) (*FunctionScheduleDeleteResult, error)

	// FunctionScheduleSetWithBodyWithResponse request with any body
	FunctionScheduleSetWithBodyWithResponse(ctx context.Context, functionId string, params *FunctionScheduleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionScheduleSetResult, error)

	FunctionScheduleSetWithResponse(ctx context.Context, functionId string, params *FunctionScheduleSetParams, body FunctionScheduleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*FunctionScheduleSetResult, error)

	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResult, error)

	// ListPersonasWithResponse request
	ListPersonasWithResponse(ctx context.Context, params *ListPersonasParams, reqEditors ...RequestEditorFn) (*ListPersonasResult, error)

	// PersonaCreateWithBodyWithResponse request with any body
	PersonaCreateWithBodyWithResponse(ctx context.Context, params *PersonaCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersonaCreateResult, error)

	PersonaCreateWithResponse(ctx context.Context, params *PersonaCreateParams, body PersonaCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PersonaCreateResult, error)

	// PersonaDeleteWithResponse request
	PersonaDeleteWithResponse(ctx context.Context, personaId string, params *PersonaDeleteParams, reqEditors ...RequestEditorFn) (*PersonaDeleteResult, error)

	// PersonaGetWithResponse request
	PersonaGetWithResponse(ctx context.Context, personaId string, params *PersonaGetParams, reqEditors ...RequestEditorFn) (*PersonaGetResult, error)

	// PersonaEmailsListWithResponse request
	PersonaEmailsListWithResponse(ctx context.Context, personaId string, params *PersonaEmailsListParams, reqEditors ...RequestEditorFn) (*PersonaEmailsListResult, error)

	// PersonaSmsListWithResponse request
	PersonaSmsListWithResponse(ctx context.Context, personaId string, params *PersonaSmsListParams, reqEditors ...RequestEditorFn) (*PersonaSmsListResult, error)

	// PersonaDeleteNumberWithResponse request
	PersonaDeleteNumberWithResponse(ctx context.Context, personaId string, params *PersonaDeleteNumberParams, reqEditors ...RequestEditorFn) (*PersonaDeleteNumberResult, error)

	// PersonaCreateNumberWithResponse request
	PersonaCreateNumberWithResponse(ctx context.Context, personaId string, params *PersonaCreateNumberParams, reqEditors ...RequestEditorFn) (*PersonaCreateNumberResult, error)

	// ProfileListWithResponse request
	ProfileListWithResponse(ctx context.Context, params *ProfileListParams, reqEditors ...RequestEditorFn) (*ProfileListResult, error)

	// ProfileCreateWithBodyWithResponse request with any body
	ProfileCreateWithBodyWithResponse(ctx context.Context, params *ProfileCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProfileCreateResult, error)

	ProfileCreateWithResponse(ctx context.Context, params *ProfileCreateParams, body ProfileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProfileCreateResult, error)

	// ProfileDeleteWithResponse request
	ProfileDeleteWithResponse(ctx context.Context, profileId string, params *ProfileDeleteParams, reqEditors ...RequestEditorFn) (*ProfileDeleteResult, error)

	// ProfileGetWithResponse request
	ProfileGetWithResponse(ctx context.Context, profileId string, params *ProfileGetParams, reqEditors ...RequestEditorFn) (*ProfileGetResult, error)

	// ImprovePromptWithBodyWithResponse request with any body
	ImprovePromptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImprovePromptResult, error)

	ImprovePromptWithResponse(ctx context.Context, body ImprovePromptJSONRequestBody, reqEditors ...RequestEditorFn) (*ImprovePromptResult, error)

	// NudgePromptWithBodyWithResponse request with any body
	NudgePromptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NudgePromptResult, error)

	NudgePromptWithResponse(ctx context.Context, body NudgePromptJSONRequestBody, reqEditors ...RequestEditorFn) (*NudgePromptResult, error)

	// ScrapeWebpageWithBodyWithResponse request with any body
	ScrapeWebpageWithBodyWithResponse(ctx context.Context, params *ScrapeWebpageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrapeWebpageResult, error)

	ScrapeWebpageWithResponse(ctx context.Context, params *ScrapeWebpageParams, body ScrapeWebpageJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrapeWebpageResult, error)

	// ScrapeFromHtmlWithBodyWithResponse request with any body
	ScrapeFromHtmlWithBodyWithResponse(ctx context.Context, params *ScrapeFromHtmlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrapeFromHtmlResult, error)

	ScrapeFromHtmlWithResponse(ctx context.Context, params *ScrapeFromHtmlParams, body ScrapeFromHtmlJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrapeFromHtmlResult, error)

	// ListSessionsWithResponse request
	ListSessionsWithResponse(ctx context.Context, params *ListSessionsParams, reqEditors ...RequestEditorFn) (*ListSessionsResult, error)

	// SessionStartWithBodyWithResponse request with any body
	SessionStartWithBodyWithResponse(ctx context.Context, params *SessionStartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SessionStartResult, error)

	SessionStartWithResponse(ctx context.Context, params *SessionStartParams, body SessionStartJSONRequestBody, reqEditors ...RequestEditorFn) (*SessionStartResult, error)

	// SessionStatusWithResponse request
	SessionStatusWithResponse(ctx context.Context, sessionId string, params *SessionStatusParams, reqEditors ...RequestEditorFn) (*SessionStatusResult, error)

	// SessionCookiesGetWithResponse request
	SessionCookiesGetWithResponse(ctx context.Context, sessionId string, params *SessionCookiesGetParams, reqEditors ...RequestEditorFn) (*SessionCookiesGetResult, error)

	// SessionCookiesSetWithBodyWithResponse request with any body
	SessionCookiesSetWithBodyWithResponse(ctx context.Context, sessionId string, params *SessionCookiesSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SessionCookiesSetResult, error)

	SessionCookiesSetWithResponse(ctx context.Context, sessionId string, params *SessionCookiesSetParams, body SessionCookiesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*SessionCookiesSetResult, error)

	// SessionDebugInfoWithResponse request
	SessionDebugInfoWithResponse(ctx context.Context, sessionId string, params *SessionDebugInfoParams, reqEditors ...RequestEditorFn) (*SessionDebugInfoResult, error)

	// SessionNetworkLogsWithResponse request
	SessionNetworkLogsWithResponse(ctx context.Context, sessionId string, params *SessionNetworkLogsParams, reqEditors ...RequestEditorFn) (*SessionNetworkLogsResult, error)

	// SessionOffsetWithResponse request
	SessionOffsetWithResponse(ctx context.Context, sessionId string, params *SessionOffsetParams, reqEditors ...RequestEditorFn) (*SessionOffsetResult, error)

	// PageExecuteWithBodyWithResponse request with any body
	PageExecuteWithBodyWithResponse(ctx context.Context, sessionId string, params *PageExecuteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PageExecuteResult, error)

	PageExecuteWithResponse(ctx context.Context, sessionId string, params *PageExecuteParams, body PageExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*PageExecuteResult, error)

	// PageObserveWithBodyWithResponse request with any body
	PageObserveWithBodyWithResponse(ctx context.Context, sessionId string, params *PageObserveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PageObserveResult, error)

	PageObserveWithResponse(ctx context.Context, sessionId string, params *PageObserveParams, body PageObserveJSONRequestBody, reqEditors ...RequestEditorFn) (*PageObserveResult, error)

	// PageScrapeWithBodyWithResponse request with any body
	PageScrapeWithBodyWithResponse(ctx context.Context, sessionId string, params *PageScrapeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PageScrapeResult, error)

	PageScrapeWithResponse(ctx context.Context, sessionId string, params *PageScrapeParams, body PageScrapeJSONRequestBody, reqEditors ...RequestEditorFn) (*PageScrapeResult, error)

	// SessionReplayWithResponse request
	SessionReplayWithResponse(ctx context.Context, sessionId string, params *SessionReplayParams, reqEditors ...RequestEditorFn) (*SessionReplayResult, error)

	// SessionStopWithResponse request
	SessionStopWithResponse(ctx context.Context, sessionId string, params *SessionStopParams, reqEditors ...RequestEditorFn) (*SessionStopResult, error)

	// GetSessionScriptWithResponse request
	GetSessionScriptWithResponse(ctx context.Context, sessionId string, params *GetSessionScriptParams, reqEditors ...RequestEditorFn) (*GetSessionScriptResult, error)

	// FileListUploadsWithResponse request
	FileListUploadsWithResponse(ctx context.Context, params *FileListUploadsParams, reqEditors ...RequestEditorFn) (*FileListUploadsResult, error)

	// FileUploadWithBodyWithResponse request with any body
	FileUploadWithBodyWithResponse(ctx context.Context, filename string, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadResult, error)

	// FileListDownloadsWithResponse request
	FileListDownloadsWithResponse(ctx context.Context, sessionId string, params *FileListDownloadsParams, reqEditors ...RequestEditorFn) (*FileListDownloadsResult, error)

	// FileDownloadWithResponse request
	FileDownloadWithResponse(ctx context.Context, sessionId string, filename string, params *FileDownloadParams, reqEditors ...RequestEditorFn) (*FileDownloadResult, error)

	// FileUploadDownloadedFileWithBodyWithResponse request with any body
	FileUploadDownloadedFileWithBodyWithResponse(ctx context.Context, sessionId string, filename string, params *FileUploadDownloadedFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadDownloadedFileResult, error)

	// GetUsageWithResponse request
	GetUsageWithResponse(ctx context.Context, params *GetUsageParams, reqEditors ...RequestEditorFn) (*GetUsageResult, error)

	// GetUsageLogsWithResponse request
	GetUsageLogsWithResponse(ctx context.Context, params *GetUsageLogsParams, reqEditors ...RequestEditorFn) (*GetUsageLogsResult, error)

	// ListVaultsWithResponse request
	ListVaultsWithResponse(ctx context.Context, params *ListVaultsParams, reqEditors ...RequestEditorFn) (*ListVaultsResult, error)

	// VaultCreateWithBodyWithResponse request with any body
	VaultCreateWithBodyWithResponse(ctx context.Context, params *VaultCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VaultCreateResult, error)

	VaultCreateWithResponse(ctx context.Context, params *VaultCreateParams, body VaultCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*VaultCreateResult, error)

	// VaultDeleteWithResponse request
	VaultDeleteWithResponse(ctx context.Context, vaultId string, params *VaultDeleteParams, reqEditors ...RequestEditorFn) (*VaultDeleteResult, error)

	// VaultCredentialsListWithResponse request
	VaultCredentialsListWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsListParams, reqEditors ...RequestEditorFn) (*VaultCredentialsListResult, error)

	// VaultUpdateWithBodyWithResponse request with any body
	VaultUpdateWithBodyWithResponse(ctx context.Context, vaultId string, params *VaultUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VaultUpdateResult, error)

	VaultUpdateWithResponse(ctx context.Context, vaultId string, params *VaultUpdateParams, body VaultUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*VaultUpdateResult, error)

	// VaultCreditCardDeleteWithResponse request
	VaultCreditCardDeleteWithResponse(ctx context.Context, vaultId string, params *VaultCreditCardDeleteParams, reqEditors ...RequestEditorFn) (*VaultCreditCardDeleteResult, error)

	// VaultCreditCardGetWithResponse request
	VaultCreditCardGetWithResponse(ctx context.Context, vaultId string, params *VaultCreditCardGetParams, reqEditors ...RequestEditorFn) (*VaultCreditCardGetResult, error)

	// VaultCreditCardSetWithBodyWithResponse request with any body
	VaultCreditCardSetWithBodyWithResponse(ctx context.Context, vaultId string, params *VaultCreditCardSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VaultCreditCardSetResult, error)

	VaultCreditCardSetWithResponse(ctx context.Context, vaultId string, params *VaultCreditCardSetParams, body VaultCreditCardSetJSONRequestBody, reqEditors ...RequestEditorFn) (*VaultCreditCardSetResult, error)

	// VaultCredentialsDeleteWithResponse request
	VaultCredentialsDeleteWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsDeleteParams, reqEditors ...RequestEditorFn) (*VaultCredentialsDeleteResult, error)

	// VaultCredentialsGetWithResponse request
	VaultCredentialsGetWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsGetParams, reqEditors ...RequestEditorFn) (*VaultCredentialsGetResult, error)

	// VaultCredentialsAddWithBodyWithResponse request with any body
	VaultCredentialsAddWithBodyWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsAddParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VaultCredentialsAddResult, error)

	VaultCredentialsAddWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsAddParams, body VaultCredentialsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*VaultCredentialsAddResult, error)
}

type ListAgentsResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseAgentResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListAgentsResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAgentsResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentStartResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r AgentStartResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentStartResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentStatusResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyAgentStatusResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r AgentStatusResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentStatusResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentReplayResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r AgentReplayResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentReplayResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentStopResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentStatusResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r AgentStopResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentStopResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentFunctionCodeResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetScriptResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFunctionsResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseGetFunctionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListFunctionsResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionsResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionCreateResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFunctionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionCreateResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionCreateResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionDeleteResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteFunctionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionDeleteResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionDeleteResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionDownloadUrlResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFunctionWithLinkResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionDownloadUrlResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionDownloadUrlResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionUpdateResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFunctionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionUpdateResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionUpdateResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionForkResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFunctionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionForkResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionForkResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFunctionRunsByFunctionIdResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseGetFunctionRunResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListFunctionRunsByFunctionIdResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionRunsByFunctionIdResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionRunStartResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionRunStartResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionRunStartResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionRunStopResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateFunctionRunResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionRunStopResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionRunStopResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionRunGetMetadataResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFunctionRunResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionRunGetMetadataResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionRunGetMetadataResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionRunUpdateMetadataResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateFunctionRunResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionRunUpdateMetadataResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionRunUpdateMetadataResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionScheduleDeleteResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduleDeleteResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionScheduleDeleteResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionScheduleDeleteResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionScheduleSetResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduleResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FunctionScheduleSetResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionScheduleSetResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthResponse
}

// Status returns HTTPResponse.Status
func (r HealthCheckResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPersonasResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponsePersonaResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListPersonasResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPersonasResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonaCreateResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonaResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PersonaCreateResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonaCreateResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonaDeleteResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletePersonaResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PersonaDeleteResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonaDeleteResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonaGetResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonaResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PersonaGetResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonaGetResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonaEmailsListResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EmailResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PersonaEmailsListResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonaEmailsListResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonaSmsListResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SMSResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PersonaSmsListResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonaSmsListResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonaDeleteNumberResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletePhoneNumberResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PersonaDeleteNumberResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonaDeleteNumberResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersonaCreateNumberResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePhoneNumberResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PersonaCreateNumberResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersonaCreateNumberResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileListResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseProfileResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ProfileListResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileListResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileCreateResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ProfileCreateResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileCreateResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileDeleteResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileDeleteResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ProfileDeleteResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileDeleteResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileGetResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ProfileGetResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileGetResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImprovePromptResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImprovePromptResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ImprovePromptResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImprovePromptResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NudgePromptResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NudgePromptResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r NudgePromptResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NudgePromptResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScrapeWebpageResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScrapeResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ScrapeWebpageResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScrapeWebpageResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScrapeFromHtmlResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScrapeSchemaResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ScrapeFromHtmlResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScrapeFromHtmlResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSessionsResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseSessionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListSessionsResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSessionsResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionStartResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SessionStartResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionStartResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionStatusResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SessionStatusResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionStatusResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionCookiesGetResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCookiesResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SessionCookiesGetResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionCookiesGetResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionCookiesSetResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExecutionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SessionCookiesSetResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionCookiesSetResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionDebugInfoResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionDebugResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SessionDebugInfoResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionDebugInfoResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionNetworkLogsResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkLogsResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SessionNetworkLogsResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionNetworkLogsResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionOffsetResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionOffsetResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SessionOffsetResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionOffsetResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PageExecuteResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiExecutionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PageExecuteResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PageExecuteResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PageObserveResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObserveResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PageObserveResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PageObserveResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PageScrapeResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScrapeResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PageScrapeResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PageScrapeResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionReplayResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SessionReplayResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionReplayResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SessionStopResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SessionStopResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SessionStopResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionScriptResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentFunctionCodeResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetSessionScriptResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionScriptResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileListUploadsResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListFilesResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FileListUploadsResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileListUploadsResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileUploadResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileUploadResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FileUploadResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileUploadResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileListDownloadsResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListFilesResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FileListDownloadsResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileListDownloadsResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileDownloadResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON422 *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FileDownloadResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileDownloadResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileUploadDownloadedFileResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileUploadResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r FileUploadDownloadedFileResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileUploadDownloadedFileResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsageResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetUsageResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageLogsResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseUsageLog
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetUsageLogsResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageLogsResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVaultsResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseVault
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListVaultsResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVaultsResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultCreateResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vault
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultCreateResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultCreateResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultDeleteResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteVaultResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultDeleteResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultDeleteResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultCredentialsListResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCredentialsResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultCredentialsListResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultCredentialsListResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultUpdateResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vault
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultUpdateResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultUpdateResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultCreditCardDeleteResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteCreditCardResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultCreditCardDeleteResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultCreditCardDeleteResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultCreditCardGetResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCreditCardResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultCreditCardGetResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultCreditCardGetResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultCreditCardSetResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddCreditCardResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultCreditCardSetResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultCreditCardSetResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultCredentialsDeleteResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteCredentialsResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultCredentialsDeleteResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultCredentialsDeleteResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultCredentialsGetResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCredentialsResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultCredentialsGetResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultCredentialsGetResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VaultCredentialsAddResult struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddCredentialsResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r VaultCredentialsAddResult) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VaultCredentialsAddResult) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAgentsWithResponse request returning *ListAgentsResult
func (c *ClientWithResponses) ListAgentsWithResponse(ctx context.Context, params *ListAgentsParams, reqEditors ...RequestEditorFn) (*ListAgentsResult, error) {
	rsp, err := c.ListAgents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAgentsResult(rsp)
}

// AgentStartWithBodyWithResponse request with arbitrary body returning *AgentStartResult
func (c *ClientWithResponses) AgentStartWithBodyWithResponse(ctx context.Context, params *AgentStartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentStartResult, error) {
	rsp, err := c.AgentStartWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentStartResult(rsp)
}

func (c *ClientWithResponses) AgentStartWithResponse(ctx context.Context, params *AgentStartParams, body AgentStartJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentStartResult, error) {
	rsp, err := c.AgentStart(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentStartResult(rsp)
}

// AgentStatusWithResponse request returning *AgentStatusResult
func (c *ClientWithResponses) AgentStatusWithResponse(ctx context.Context, agentId string, params *AgentStatusParams, reqEditors ...RequestEditorFn) (*AgentStatusResult, error) {
	rsp, err := c.AgentStatus(ctx, agentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentStatusResult(rsp)
}

// AgentReplayWithResponse request returning *AgentReplayResult
func (c *ClientWithResponses) AgentReplayWithResponse(ctx context.Context, agentId string, params *AgentReplayParams, reqEditors ...RequestEditorFn) (*AgentReplayResult, error) {
	rsp, err := c.AgentReplay(ctx, agentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentReplayResult(rsp)
}

// AgentStopWithResponse request returning *AgentStopResult
func (c *ClientWithResponses) AgentStopWithResponse(ctx context.Context, agentId string, params *AgentStopParams, reqEditors ...RequestEditorFn) (*AgentStopResult, error) {
	rsp, err := c.AgentStop(ctx, agentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentStopResult(rsp)
}

// GetScriptWithResponse request returning *GetScriptResult
func (c *ClientWithResponses) GetScriptWithResponse(ctx context.Context, agentId string, params *GetScriptParams, reqEditors ...RequestEditorFn) (*GetScriptResult, error) {
	rsp, err := c.GetScript(ctx, agentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptResult(rsp)
}

// ListFunctionsWithResponse request returning *ListFunctionsResult
func (c *ClientWithResponses) ListFunctionsWithResponse(ctx context.Context, params *ListFunctionsParams, reqEditors ...RequestEditorFn) (*ListFunctionsResult, error) {
	rsp, err := c.ListFunctions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFunctionsResult(rsp)
}

// FunctionCreateWithBodyWithResponse request with arbitrary body returning *FunctionCreateResult
func (c *ClientWithResponses) FunctionCreateWithBodyWithResponse(ctx context.Context, params *FunctionCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionCreateResult, error) {
	rsp, err := c.FunctionCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionCreateResult(rsp)
}

// FunctionDeleteWithResponse request returning *FunctionDeleteResult
func (c *ClientWithResponses) FunctionDeleteWithResponse(ctx context.Context, functionId string, params *FunctionDeleteParams, reqEditors ...RequestEditorFn) (*FunctionDeleteResult, error) {
	rsp, err := c.FunctionDelete(ctx, functionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionDeleteResult(rsp)
}

// FunctionDownloadUrlWithResponse request returning *FunctionDownloadUrlResult
func (c *ClientWithResponses) FunctionDownloadUrlWithResponse(ctx context.Context, functionId string, params *FunctionDownloadUrlParams, reqEditors ...RequestEditorFn) (*FunctionDownloadUrlResult, error) {
	rsp, err := c.FunctionDownloadUrl(ctx, functionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionDownloadUrlResult(rsp)
}

// FunctionUpdateWithBodyWithResponse request with arbitrary body returning *FunctionUpdateResult
func (c *ClientWithResponses) FunctionUpdateWithBodyWithResponse(ctx context.Context, functionId string, params *FunctionUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionUpdateResult, error) {
	rsp, err := c.FunctionUpdateWithBody(ctx, functionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionUpdateResult(rsp)
}

// FunctionForkWithResponse request returning *FunctionForkResult
func (c *ClientWithResponses) FunctionForkWithResponse(ctx context.Context, functionId string, params *FunctionForkParams, reqEditors ...RequestEditorFn) (*FunctionForkResult, error) {
	rsp, err := c.FunctionFork(ctx, functionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionForkResult(rsp)
}

// ListFunctionRunsByFunctionIdWithResponse request returning *ListFunctionRunsByFunctionIdResult
func (c *ClientWithResponses) ListFunctionRunsByFunctionIdWithResponse(ctx context.Context, functionId string, params *ListFunctionRunsByFunctionIdParams, reqEditors ...RequestEditorFn) (*ListFunctionRunsByFunctionIdResult, error) {
	rsp, err := c.ListFunctionRunsByFunctionId(ctx, functionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFunctionRunsByFunctionIdResult(rsp)
}

// FunctionRunStartWithResponse request returning *FunctionRunStartResult
func (c *ClientWithResponses) FunctionRunStartWithResponse(ctx context.Context, functionId string, params *FunctionRunStartParams, reqEditors ...RequestEditorFn) (*FunctionRunStartResult, error) {
	rsp, err := c.FunctionRunStart(ctx, functionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionRunStartResult(rsp)
}

// FunctionRunStopWithResponse request returning *FunctionRunStopResult
func (c *ClientWithResponses) FunctionRunStopWithResponse(ctx context.Context, functionId string, runId string, params *FunctionRunStopParams, reqEditors ...RequestEditorFn) (*FunctionRunStopResult, error) {
	rsp, err := c.FunctionRunStop(ctx, functionId, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionRunStopResult(rsp)
}

// FunctionRunGetMetadataWithResponse request returning *FunctionRunGetMetadataResult
func (c *ClientWithResponses) FunctionRunGetMetadataWithResponse(ctx context.Context, functionId string, runId string, params *FunctionRunGetMetadataParams, reqEditors ...RequestEditorFn) (*FunctionRunGetMetadataResult, error) {
	rsp, err := c.FunctionRunGetMetadata(ctx, functionId, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionRunGetMetadataResult(rsp)
}

// FunctionRunUpdateMetadataWithBodyWithResponse request with arbitrary body returning *FunctionRunUpdateMetadataResult
func (c *ClientWithResponses) FunctionRunUpdateMetadataWithBodyWithResponse(ctx context.Context, functionId string, runId string, params *FunctionRunUpdateMetadataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionRunUpdateMetadataResult, error) {
	rsp, err := c.FunctionRunUpdateMetadataWithBody(ctx, functionId, runId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionRunUpdateMetadataResult(rsp)
}

func (c *ClientWithResponses) FunctionRunUpdateMetadataWithResponse(ctx context.Context, functionId string, runId string, params *FunctionRunUpdateMetadataParams, body FunctionRunUpdateMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*FunctionRunUpdateMetadataResult, error) {
	rsp, err := c.FunctionRunUpdateMetadata(ctx, functionId, runId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionRunUpdateMetadataResult(rsp)
}

// FunctionScheduleDeleteWithResponse request returning *FunctionScheduleDeleteResult
func (c *ClientWithResponses) FunctionScheduleDeleteWithResponse(ctx context.Context, functionId string, params *FunctionScheduleDeleteParams, reqEditors ...RequestEditorFn) (*FunctionScheduleDeleteResult, error) {
	rsp, err := c.FunctionScheduleDelete(ctx, functionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionScheduleDeleteResult(rsp)
}

// FunctionScheduleSetWithBodyWithResponse request with arbitrary body returning *FunctionScheduleSetResult
func (c *ClientWithResponses) FunctionScheduleSetWithBodyWithResponse(ctx context.Context, functionId string, params *FunctionScheduleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionScheduleSetResult, error) {
	rsp, err := c.FunctionScheduleSetWithBody(ctx, functionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionScheduleSetResult(rsp)
}

func (c *ClientWithResponses) FunctionScheduleSetWithResponse(ctx context.Context, functionId string, params *FunctionScheduleSetParams, body FunctionScheduleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*FunctionScheduleSetResult, error) {
	rsp, err := c.FunctionScheduleSet(ctx, functionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionScheduleSetResult(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResult
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResult, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResult(rsp)
}

// ListPersonasWithResponse request returning *ListPersonasResult
func (c *ClientWithResponses) ListPersonasWithResponse(ctx context.Context, params *ListPersonasParams, reqEditors ...RequestEditorFn) (*ListPersonasResult, error) {
	rsp, err := c.ListPersonas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPersonasResult(rsp)
}

// PersonaCreateWithBodyWithResponse request with arbitrary body returning *PersonaCreateResult
func (c *ClientWithResponses) PersonaCreateWithBodyWithResponse(ctx context.Context, params *PersonaCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersonaCreateResult, error) {
	rsp, err := c.PersonaCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonaCreateResult(rsp)
}

func (c *ClientWithResponses) PersonaCreateWithResponse(ctx context.Context, params *PersonaCreateParams, body PersonaCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PersonaCreateResult, error) {
	rsp, err := c.PersonaCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonaCreateResult(rsp)
}

// PersonaDeleteWithResponse request returning *PersonaDeleteResult
func (c *ClientWithResponses) PersonaDeleteWithResponse(ctx context.Context, personaId string, params *PersonaDeleteParams, reqEditors ...RequestEditorFn) (*PersonaDeleteResult, error) {
	rsp, err := c.PersonaDelete(ctx, personaId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonaDeleteResult(rsp)
}

// PersonaGetWithResponse request returning *PersonaGetResult
func (c *ClientWithResponses) PersonaGetWithResponse(ctx context.Context, personaId string, params *PersonaGetParams, reqEditors ...RequestEditorFn) (*PersonaGetResult, error) {
	rsp, err := c.PersonaGet(ctx, personaId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonaGetResult(rsp)
}

// PersonaEmailsListWithResponse request returning *PersonaEmailsListResult
func (c *ClientWithResponses) PersonaEmailsListWithResponse(ctx context.Context, personaId string, params *PersonaEmailsListParams, reqEditors ...RequestEditorFn) (*PersonaEmailsListResult, error) {
	rsp, err := c.PersonaEmailsList(ctx, personaId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonaEmailsListResult(rsp)
}

// PersonaSmsListWithResponse request returning *PersonaSmsListResult
func (c *ClientWithResponses) PersonaSmsListWithResponse(ctx context.Context, personaId string, params *PersonaSmsListParams, reqEditors ...RequestEditorFn) (*PersonaSmsListResult, error) {
	rsp, err := c.PersonaSmsList(ctx, personaId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonaSmsListResult(rsp)
}

// PersonaDeleteNumberWithResponse request returning *PersonaDeleteNumberResult
func (c *ClientWithResponses) PersonaDeleteNumberWithResponse(ctx context.Context, personaId string, params *PersonaDeleteNumberParams, reqEditors ...RequestEditorFn) (*PersonaDeleteNumberResult, error) {
	rsp, err := c.PersonaDeleteNumber(ctx, personaId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonaDeleteNumberResult(rsp)
}

// PersonaCreateNumberWithResponse request returning *PersonaCreateNumberResult
func (c *ClientWithResponses) PersonaCreateNumberWithResponse(ctx context.Context, personaId string, params *PersonaCreateNumberParams, reqEditors ...RequestEditorFn) (*PersonaCreateNumberResult, error) {
	rsp, err := c.PersonaCreateNumber(ctx, personaId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersonaCreateNumberResult(rsp)
}

// ProfileListWithResponse request returning *ProfileListResult
func (c *ClientWithResponses) ProfileListWithResponse(ctx context.Context, params *ProfileListParams, reqEditors ...RequestEditorFn) (*ProfileListResult, error) {
	rsp, err := c.ProfileList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileListResult(rsp)
}

// ProfileCreateWithBodyWithResponse request with arbitrary body returning *ProfileCreateResult
func (c *ClientWithResponses) ProfileCreateWithBodyWithResponse(ctx context.Context, params *ProfileCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProfileCreateResult, error) {
	rsp, err := c.ProfileCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileCreateResult(rsp)
}

func (c *ClientWithResponses) ProfileCreateWithResponse(ctx context.Context, params *ProfileCreateParams, body ProfileCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProfileCreateResult, error) {
	rsp, err := c.ProfileCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileCreateResult(rsp)
}

// ProfileDeleteWithResponse request returning *ProfileDeleteResult
func (c *ClientWithResponses) ProfileDeleteWithResponse(ctx context.Context, profileId string, params *ProfileDeleteParams, reqEditors ...RequestEditorFn) (*ProfileDeleteResult, error) {
	rsp, err := c.ProfileDelete(ctx, profileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileDeleteResult(rsp)
}

// ProfileGetWithResponse request returning *ProfileGetResult
func (c *ClientWithResponses) ProfileGetWithResponse(ctx context.Context, profileId string, params *ProfileGetParams, reqEditors ...RequestEditorFn) (*ProfileGetResult, error) {
	rsp, err := c.ProfileGet(ctx, profileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileGetResult(rsp)
}

// ImprovePromptWithBodyWithResponse request with arbitrary body returning *ImprovePromptResult
func (c *ClientWithResponses) ImprovePromptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImprovePromptResult, error) {
	rsp, err := c.ImprovePromptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImprovePromptResult(rsp)
}

func (c *ClientWithResponses) ImprovePromptWithResponse(ctx context.Context, body ImprovePromptJSONRequestBody, reqEditors ...RequestEditorFn) (*ImprovePromptResult, error) {
	rsp, err := c.ImprovePrompt(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImprovePromptResult(rsp)
}

// NudgePromptWithBodyWithResponse request with arbitrary body returning *NudgePromptResult
func (c *ClientWithResponses) NudgePromptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NudgePromptResult, error) {
	rsp, err := c.NudgePromptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNudgePromptResult(rsp)
}

func (c *ClientWithResponses) NudgePromptWithResponse(ctx context.Context, body NudgePromptJSONRequestBody, reqEditors ...RequestEditorFn) (*NudgePromptResult, error) {
	rsp, err := c.NudgePrompt(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNudgePromptResult(rsp)
}

// ScrapeWebpageWithBodyWithResponse request with arbitrary body returning *ScrapeWebpageResult
func (c *ClientWithResponses) ScrapeWebpageWithBodyWithResponse(ctx context.Context, params *ScrapeWebpageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrapeWebpageResult, error) {
	rsp, err := c.ScrapeWebpageWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrapeWebpageResult(rsp)
}

func (c *ClientWithResponses) ScrapeWebpageWithResponse(ctx context.Context, params *ScrapeWebpageParams, body ScrapeWebpageJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrapeWebpageResult, error) {
	rsp, err := c.ScrapeWebpage(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrapeWebpageResult(rsp)
}

// ScrapeFromHtmlWithBodyWithResponse request with arbitrary body returning *ScrapeFromHtmlResult
func (c *ClientWithResponses) ScrapeFromHtmlWithBodyWithResponse(ctx context.Context, params *ScrapeFromHtmlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrapeFromHtmlResult, error) {
	rsp, err := c.ScrapeFromHtmlWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrapeFromHtmlResult(rsp)
}

func (c *ClientWithResponses) ScrapeFromHtmlWithResponse(ctx context.Context, params *ScrapeFromHtmlParams, body ScrapeFromHtmlJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrapeFromHtmlResult, error) {
	rsp, err := c.ScrapeFromHtml(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrapeFromHtmlResult(rsp)
}

// ListSessionsWithResponse request returning *ListSessionsResult
func (c *ClientWithResponses) ListSessionsWithResponse(ctx context.Context, params *ListSessionsParams, reqEditors ...RequestEditorFn) (*ListSessionsResult, error) {
	rsp, err := c.ListSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSessionsResult(rsp)
}

// SessionStartWithBodyWithResponse request with arbitrary body returning *SessionStartResult
func (c *ClientWithResponses) SessionStartWithBodyWithResponse(ctx context.Context, params *SessionStartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SessionStartResult, error) {
	rsp, err := c.SessionStartWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionStartResult(rsp)
}

func (c *ClientWithResponses) SessionStartWithResponse(ctx context.Context, params *SessionStartParams, body SessionStartJSONRequestBody, reqEditors ...RequestEditorFn) (*SessionStartResult, error) {
	rsp, err := c.SessionStart(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionStartResult(rsp)
}

// SessionStatusWithResponse request returning *SessionStatusResult
func (c *ClientWithResponses) SessionStatusWithResponse(ctx context.Context, sessionId string, params *SessionStatusParams, reqEditors ...RequestEditorFn) (*SessionStatusResult, error) {
	rsp, err := c.SessionStatus(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionStatusResult(rsp)
}

// SessionCookiesGetWithResponse request returning *SessionCookiesGetResult
func (c *ClientWithResponses) SessionCookiesGetWithResponse(ctx context.Context, sessionId string, params *SessionCookiesGetParams, reqEditors ...RequestEditorFn) (*SessionCookiesGetResult, error) {
	rsp, err := c.SessionCookiesGet(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionCookiesGetResult(rsp)
}

// SessionCookiesSetWithBodyWithResponse request with arbitrary body returning *SessionCookiesSetResult
func (c *ClientWithResponses) SessionCookiesSetWithBodyWithResponse(ctx context.Context, sessionId string, params *SessionCookiesSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SessionCookiesSetResult, error) {
	rsp, err := c.SessionCookiesSetWithBody(ctx, sessionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionCookiesSetResult(rsp)
}

func (c *ClientWithResponses) SessionCookiesSetWithResponse(ctx context.Context, sessionId string, params *SessionCookiesSetParams, body SessionCookiesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*SessionCookiesSetResult, error) {
	rsp, err := c.SessionCookiesSet(ctx, sessionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionCookiesSetResult(rsp)
}

// SessionDebugInfoWithResponse request returning *SessionDebugInfoResult
func (c *ClientWithResponses) SessionDebugInfoWithResponse(ctx context.Context, sessionId string, params *SessionDebugInfoParams, reqEditors ...RequestEditorFn) (*SessionDebugInfoResult, error) {
	rsp, err := c.SessionDebugInfo(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionDebugInfoResult(rsp)
}

// SessionNetworkLogsWithResponse request returning *SessionNetworkLogsResult
func (c *ClientWithResponses) SessionNetworkLogsWithResponse(ctx context.Context, sessionId string, params *SessionNetworkLogsParams, reqEditors ...RequestEditorFn) (*SessionNetworkLogsResult, error) {
	rsp, err := c.SessionNetworkLogs(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionNetworkLogsResult(rsp)
}

// SessionOffsetWithResponse request returning *SessionOffsetResult
func (c *ClientWithResponses) SessionOffsetWithResponse(ctx context.Context, sessionId string, params *SessionOffsetParams, reqEditors ...RequestEditorFn) (*SessionOffsetResult, error) {
	rsp, err := c.SessionOffset(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionOffsetResult(rsp)
}

// PageExecuteWithBodyWithResponse request with arbitrary body returning *PageExecuteResult
func (c *ClientWithResponses) PageExecuteWithBodyWithResponse(ctx context.Context, sessionId string, params *PageExecuteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PageExecuteResult, error) {
	rsp, err := c.PageExecuteWithBody(ctx, sessionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePageExecuteResult(rsp)
}

func (c *ClientWithResponses) PageExecuteWithResponse(ctx context.Context, sessionId string, params *PageExecuteParams, body PageExecuteJSONRequestBody, reqEditors ...RequestEditorFn) (*PageExecuteResult, error) {
	rsp, err := c.PageExecute(ctx, sessionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePageExecuteResult(rsp)
}

// PageObserveWithBodyWithResponse request with arbitrary body returning *PageObserveResult
func (c *ClientWithResponses) PageObserveWithBodyWithResponse(ctx context.Context, sessionId string, params *PageObserveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PageObserveResult, error) {
	rsp, err := c.PageObserveWithBody(ctx, sessionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePageObserveResult(rsp)
}

func (c *ClientWithResponses) PageObserveWithResponse(ctx context.Context, sessionId string, params *PageObserveParams, body PageObserveJSONRequestBody, reqEditors ...RequestEditorFn) (*PageObserveResult, error) {
	rsp, err := c.PageObserve(ctx, sessionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePageObserveResult(rsp)
}

// PageScrapeWithBodyWithResponse request with arbitrary body returning *PageScrapeResult
func (c *ClientWithResponses) PageScrapeWithBodyWithResponse(ctx context.Context, sessionId string, params *PageScrapeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PageScrapeResult, error) {
	rsp, err := c.PageScrapeWithBody(ctx, sessionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePageScrapeResult(rsp)
}

func (c *ClientWithResponses) PageScrapeWithResponse(ctx context.Context, sessionId string, params *PageScrapeParams, body PageScrapeJSONRequestBody, reqEditors ...RequestEditorFn) (*PageScrapeResult, error) {
	rsp, err := c.PageScrape(ctx, sessionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePageScrapeResult(rsp)
}

// SessionReplayWithResponse request returning *SessionReplayResult
func (c *ClientWithResponses) SessionReplayWithResponse(ctx context.Context, sessionId string, params *SessionReplayParams, reqEditors ...RequestEditorFn) (*SessionReplayResult, error) {
	rsp, err := c.SessionReplay(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionReplayResult(rsp)
}

// SessionStopWithResponse request returning *SessionStopResult
func (c *ClientWithResponses) SessionStopWithResponse(ctx context.Context, sessionId string, params *SessionStopParams, reqEditors ...RequestEditorFn) (*SessionStopResult, error) {
	rsp, err := c.SessionStop(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSessionStopResult(rsp)
}

// GetSessionScriptWithResponse request returning *GetSessionScriptResult
func (c *ClientWithResponses) GetSessionScriptWithResponse(ctx context.Context, sessionId string, params *GetSessionScriptParams, reqEditors ...RequestEditorFn) (*GetSessionScriptResult, error) {
	rsp, err := c.GetSessionScript(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionScriptResult(rsp)
}

// FileListUploadsWithResponse request returning *FileListUploadsResult
func (c *ClientWithResponses) FileListUploadsWithResponse(ctx context.Context, params *FileListUploadsParams, reqEditors ...RequestEditorFn) (*FileListUploadsResult, error) {
	rsp, err := c.FileListUploads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileListUploadsResult(rsp)
}

// FileUploadWithBodyWithResponse request with arbitrary body returning *FileUploadResult
func (c *ClientWithResponses) FileUploadWithBodyWithResponse(ctx context.Context, filename string, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadResult, error) {
	rsp, err := c.FileUploadWithBody(ctx, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileUploadResult(rsp)
}

// FileListDownloadsWithResponse request returning *FileListDownloadsResult
func (c *ClientWithResponses) FileListDownloadsWithResponse(ctx context.Context, sessionId string, params *FileListDownloadsParams, reqEditors ...RequestEditorFn) (*FileListDownloadsResult, error) {
	rsp, err := c.FileListDownloads(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileListDownloadsResult(rsp)
}

// FileDownloadWithResponse request returning *FileDownloadResult
func (c *ClientWithResponses) FileDownloadWithResponse(ctx context.Context, sessionId string, filename string, params *FileDownloadParams, reqEditors ...RequestEditorFn) (*FileDownloadResult, error) {
	rsp, err := c.FileDownload(ctx, sessionId, filename, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileDownloadResult(rsp)
}

// FileUploadDownloadedFileWithBodyWithResponse request with arbitrary body returning *FileUploadDownloadedFileResult
func (c *ClientWithResponses) FileUploadDownloadedFileWithBodyWithResponse(ctx context.Context, sessionId string, filename string, params *FileUploadDownloadedFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadDownloadedFileResult, error) {
	rsp, err := c.FileUploadDownloadedFileWithBody(ctx, sessionId, filename, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileUploadDownloadedFileResult(rsp)
}

// GetUsageWithResponse request returning *GetUsageResult
func (c *ClientWithResponses) GetUsageWithResponse(ctx context.Context, params *GetUsageParams, reqEditors ...RequestEditorFn) (*GetUsageResult, error) {
	rsp, err := c.GetUsage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageResult(rsp)
}

// GetUsageLogsWithResponse request returning *GetUsageLogsResult
func (c *ClientWithResponses) GetUsageLogsWithResponse(ctx context.Context, params *GetUsageLogsParams, reqEditors ...RequestEditorFn) (*GetUsageLogsResult, error) {
	rsp, err := c.GetUsageLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageLogsResult(rsp)
}

// ListVaultsWithResponse request returning *ListVaultsResult
func (c *ClientWithResponses) ListVaultsWithResponse(ctx context.Context, params *ListVaultsParams, reqEditors ...RequestEditorFn) (*ListVaultsResult, error) {
	rsp, err := c.ListVaults(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVaultsResult(rsp)
}

// VaultCreateWithBodyWithResponse request with arbitrary body returning *VaultCreateResult
func (c *ClientWithResponses) VaultCreateWithBodyWithResponse(ctx context.Context, params *VaultCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VaultCreateResult, error) {
	rsp, err := c.VaultCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCreateResult(rsp)
}

func (c *ClientWithResponses) VaultCreateWithResponse(ctx context.Context, params *VaultCreateParams, body VaultCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*VaultCreateResult, error) {
	rsp, err := c.VaultCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCreateResult(rsp)
}

// VaultDeleteWithResponse request returning *VaultDeleteResult
func (c *ClientWithResponses) VaultDeleteWithResponse(ctx context.Context, vaultId string, params *VaultDeleteParams, reqEditors ...RequestEditorFn) (*VaultDeleteResult, error) {
	rsp, err := c.VaultDelete(ctx, vaultId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultDeleteResult(rsp)
}

// VaultCredentialsListWithResponse request returning *VaultCredentialsListResult
func (c *ClientWithResponses) VaultCredentialsListWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsListParams, reqEditors ...RequestEditorFn) (*VaultCredentialsListResult, error) {
	rsp, err := c.VaultCredentialsList(ctx, vaultId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCredentialsListResult(rsp)
}

// VaultUpdateWithBodyWithResponse request with arbitrary body returning *VaultUpdateResult
func (c *ClientWithResponses) VaultUpdateWithBodyWithResponse(ctx context.Context, vaultId string, params *VaultUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VaultUpdateResult, error) {
	rsp, err := c.VaultUpdateWithBody(ctx, vaultId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultUpdateResult(rsp)
}

func (c *ClientWithResponses) VaultUpdateWithResponse(ctx context.Context, vaultId string, params *VaultUpdateParams, body VaultUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*VaultUpdateResult, error) {
	rsp, err := c.VaultUpdate(ctx, vaultId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultUpdateResult(rsp)
}

// VaultCreditCardDeleteWithResponse request returning *VaultCreditCardDeleteResult
func (c *ClientWithResponses) VaultCreditCardDeleteWithResponse(ctx context.Context, vaultId string, params *VaultCreditCardDeleteParams, reqEditors ...RequestEditorFn) (*VaultCreditCardDeleteResult, error) {
	rsp, err := c.VaultCreditCardDelete(ctx, vaultId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCreditCardDeleteResult(rsp)
}

// VaultCreditCardGetWithResponse request returning *VaultCreditCardGetResult
func (c *ClientWithResponses) VaultCreditCardGetWithResponse(ctx context.Context, vaultId string, params *VaultCreditCardGetParams, reqEditors ...RequestEditorFn) (*VaultCreditCardGetResult, error) {
	rsp, err := c.VaultCreditCardGet(ctx, vaultId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCreditCardGetResult(rsp)
}

// VaultCreditCardSetWithBodyWithResponse request with arbitrary body returning *VaultCreditCardSetResult
func (c *ClientWithResponses) VaultCreditCardSetWithBodyWithResponse(ctx context.Context, vaultId string, params *VaultCreditCardSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VaultCreditCardSetResult, error) {
	rsp, err := c.VaultCreditCardSetWithBody(ctx, vaultId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCreditCardSetResult(rsp)
}

func (c *ClientWithResponses) VaultCreditCardSetWithResponse(ctx context.Context, vaultId string, params *VaultCreditCardSetParams, body VaultCreditCardSetJSONRequestBody, reqEditors ...RequestEditorFn) (*VaultCreditCardSetResult, error) {
	rsp, err := c.VaultCreditCardSet(ctx, vaultId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCreditCardSetResult(rsp)
}

// VaultCredentialsDeleteWithResponse request returning *VaultCredentialsDeleteResult
func (c *ClientWithResponses) VaultCredentialsDeleteWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsDeleteParams, reqEditors ...RequestEditorFn) (*VaultCredentialsDeleteResult, error) {
	rsp, err := c.VaultCredentialsDelete(ctx, vaultId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCredentialsDeleteResult(rsp)
}

// VaultCredentialsGetWithResponse request returning *VaultCredentialsGetResult
func (c *ClientWithResponses) VaultCredentialsGetWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsGetParams, reqEditors ...RequestEditorFn) (*VaultCredentialsGetResult, error) {
	rsp, err := c.VaultCredentialsGet(ctx, vaultId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCredentialsGetResult(rsp)
}

// VaultCredentialsAddWithBodyWithResponse request with arbitrary body returning *VaultCredentialsAddResult
func (c *ClientWithResponses) VaultCredentialsAddWithBodyWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsAddParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VaultCredentialsAddResult, error) {
	rsp, err := c.VaultCredentialsAddWithBody(ctx, vaultId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCredentialsAddResult(rsp)
}

func (c *ClientWithResponses) VaultCredentialsAddWithResponse(ctx context.Context, vaultId string, params *VaultCredentialsAddParams, body VaultCredentialsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*VaultCredentialsAddResult, error) {
	rsp, err := c.VaultCredentialsAdd(ctx, vaultId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVaultCredentialsAddResult(rsp)
}

// ParseListAgentsResult parses an HTTP response from a ListAgentsWithResponse call
func ParseListAgentsResult(rsp *http.Response) (*ListAgentsResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAgentsResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseAgentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAgentStartResult parses an HTTP response from a AgentStartWithResponse call
func ParseAgentStartResult(rsp *http.Response) (*AgentStartResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentStartResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAgentStatusResult parses an HTTP response from a AgentStatusWithResponse call
func ParseAgentStatusResult(rsp *http.Response) (*AgentStatusResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentStatusResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyAgentStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAgentReplayResult parses an HTTP response from a AgentReplayWithResponse call
func ParseAgentReplayResult(rsp *http.Response) (*AgentReplayResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentReplayResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAgentStopResult parses an HTTP response from a AgentStopWithResponse call
func ParseAgentStopResult(rsp *http.Response) (*AgentStopResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentStopResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetScriptResult parses an HTTP response from a GetScriptWithResponse call
func ParseGetScriptResult(rsp *http.Response) (*GetScriptResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentFunctionCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListFunctionsResult parses an HTTP response from a ListFunctionsWithResponse call
func ParseListFunctionsResult(rsp *http.Response) (*ListFunctionsResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFunctionsResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseGetFunctionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionCreateResult parses an HTTP response from a FunctionCreateWithResponse call
func ParseFunctionCreateResult(rsp *http.Response) (*FunctionCreateResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionCreateResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFunctionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionDeleteResult parses an HTTP response from a FunctionDeleteWithResponse call
func ParseFunctionDeleteResult(rsp *http.Response) (*FunctionDeleteResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionDeleteResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteFunctionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionDownloadUrlResult parses an HTTP response from a FunctionDownloadUrlWithResponse call
func ParseFunctionDownloadUrlResult(rsp *http.Response) (*FunctionDownloadUrlResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionDownloadUrlResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFunctionWithLinkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionUpdateResult parses an HTTP response from a FunctionUpdateWithResponse call
func ParseFunctionUpdateResult(rsp *http.Response) (*FunctionUpdateResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionUpdateResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFunctionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionForkResult parses an HTTP response from a FunctionForkWithResponse call
func ParseFunctionForkResult(rsp *http.Response) (*FunctionForkResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionForkResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFunctionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListFunctionRunsByFunctionIdResult parses an HTTP response from a ListFunctionRunsByFunctionIdWithResponse call
func ParseListFunctionRunsByFunctionIdResult(rsp *http.Response) (*ListFunctionRunsByFunctionIdResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFunctionRunsByFunctionIdResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseGetFunctionRunResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionRunStartResult parses an HTTP response from a FunctionRunStartWithResponse call
func ParseFunctionRunStartResult(rsp *http.Response) (*FunctionRunStartResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionRunStartResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionRunStopResult parses an HTTP response from a FunctionRunStopWithResponse call
func ParseFunctionRunStopResult(rsp *http.Response) (*FunctionRunStopResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionRunStopResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateFunctionRunResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionRunGetMetadataResult parses an HTTP response from a FunctionRunGetMetadataWithResponse call
func ParseFunctionRunGetMetadataResult(rsp *http.Response) (*FunctionRunGetMetadataResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionRunGetMetadataResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFunctionRunResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionRunUpdateMetadataResult parses an HTTP response from a FunctionRunUpdateMetadataWithResponse call
func ParseFunctionRunUpdateMetadataResult(rsp *http.Response) (*FunctionRunUpdateMetadataResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionRunUpdateMetadataResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateFunctionRunResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionScheduleDeleteResult parses an HTTP response from a FunctionScheduleDeleteWithResponse call
func ParseFunctionScheduleDeleteResult(rsp *http.Response) (*FunctionScheduleDeleteResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionScheduleDeleteResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduleDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFunctionScheduleSetResult parses an HTTP response from a FunctionScheduleSetWithResponse call
func ParseFunctionScheduleSetResult(rsp *http.Response) (*FunctionScheduleSetResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionScheduleSetResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseHealthCheckResult parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResult(rsp *http.Response) (*HealthCheckResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPersonasResult parses an HTTP response from a ListPersonasWithResponse call
func ParseListPersonasResult(rsp *http.Response) (*ListPersonasResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPersonasResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponsePersonaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePersonaCreateResult parses an HTTP response from a PersonaCreateWithResponse call
func ParsePersonaCreateResult(rsp *http.Response) (*PersonaCreateResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonaCreateResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePersonaDeleteResult parses an HTTP response from a PersonaDeleteWithResponse call
func ParsePersonaDeleteResult(rsp *http.Response) (*PersonaDeleteResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonaDeleteResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletePersonaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePersonaGetResult parses an HTTP response from a PersonaGetWithResponse call
func ParsePersonaGetResult(rsp *http.Response) (*PersonaGetResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonaGetResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePersonaEmailsListResult parses an HTTP response from a PersonaEmailsListWithResponse call
func ParsePersonaEmailsListResult(rsp *http.Response) (*PersonaEmailsListResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonaEmailsListResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EmailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePersonaSmsListResult parses an HTTP response from a PersonaSmsListWithResponse call
func ParsePersonaSmsListResult(rsp *http.Response) (*PersonaSmsListResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonaSmsListResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SMSResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePersonaDeleteNumberResult parses an HTTP response from a PersonaDeleteNumberWithResponse call
func ParsePersonaDeleteNumberResult(rsp *http.Response) (*PersonaDeleteNumberResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonaDeleteNumberResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletePhoneNumberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePersonaCreateNumberResult parses an HTTP response from a PersonaCreateNumberWithResponse call
func ParsePersonaCreateNumberResult(rsp *http.Response) (*PersonaCreateNumberResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersonaCreateNumberResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePhoneNumberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProfileListResult parses an HTTP response from a ProfileListWithResponse call
func ParseProfileListResult(rsp *http.Response) (*ProfileListResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileListResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProfileCreateResult parses an HTTP response from a ProfileCreateWithResponse call
func ParseProfileCreateResult(rsp *http.Response) (*ProfileCreateResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileCreateResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProfileDeleteResult parses an HTTP response from a ProfileDeleteWithResponse call
func ParseProfileDeleteResult(rsp *http.Response) (*ProfileDeleteResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileDeleteResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProfileGetResult parses an HTTP response from a ProfileGetWithResponse call
func ParseProfileGetResult(rsp *http.Response) (*ProfileGetResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileGetResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseImprovePromptResult parses an HTTP response from a ImprovePromptWithResponse call
func ParseImprovePromptResult(rsp *http.Response) (*ImprovePromptResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImprovePromptResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImprovePromptResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseNudgePromptResult parses an HTTP response from a NudgePromptWithResponse call
func ParseNudgePromptResult(rsp *http.Response) (*NudgePromptResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NudgePromptResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NudgePromptResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseScrapeWebpageResult parses an HTTP response from a ScrapeWebpageWithResponse call
func ParseScrapeWebpageResult(rsp *http.Response) (*ScrapeWebpageResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScrapeWebpageResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScrapeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseScrapeFromHtmlResult parses an HTTP response from a ScrapeFromHtmlWithResponse call
func ParseScrapeFromHtmlResult(rsp *http.Response) (*ScrapeFromHtmlResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScrapeFromHtmlResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScrapeSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListSessionsResult parses an HTTP response from a ListSessionsWithResponse call
func ParseListSessionsResult(rsp *http.Response) (*ListSessionsResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSessionsResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSessionStartResult parses an HTTP response from a SessionStartWithResponse call
func ParseSessionStartResult(rsp *http.Response) (*SessionStartResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionStartResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSessionStatusResult parses an HTTP response from a SessionStatusWithResponse call
func ParseSessionStatusResult(rsp *http.Response) (*SessionStatusResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionStatusResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSessionCookiesGetResult parses an HTTP response from a SessionCookiesGetWithResponse call
func ParseSessionCookiesGetResult(rsp *http.Response) (*SessionCookiesGetResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionCookiesGetResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCookiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSessionCookiesSetResult parses an HTTP response from a SessionCookiesSetWithResponse call
func ParseSessionCookiesSetResult(rsp *http.Response) (*SessionCookiesSetResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionCookiesSetResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExecutionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSessionDebugInfoResult parses an HTTP response from a SessionDebugInfoWithResponse call
func ParseSessionDebugInfoResult(rsp *http.Response) (*SessionDebugInfoResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionDebugInfoResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionDebugResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSessionNetworkLogsResult parses an HTTP response from a SessionNetworkLogsWithResponse call
func ParseSessionNetworkLogsResult(rsp *http.Response) (*SessionNetworkLogsResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionNetworkLogsResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSessionOffsetResult parses an HTTP response from a SessionOffsetWithResponse call
func ParseSessionOffsetResult(rsp *http.Response) (*SessionOffsetResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionOffsetResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionOffsetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePageExecuteResult parses an HTTP response from a PageExecuteWithResponse call
func ParsePageExecuteResult(rsp *http.Response) (*PageExecuteResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PageExecuteResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiExecutionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePageObserveResult parses an HTTP response from a PageObserveWithResponse call
func ParsePageObserveResult(rsp *http.Response) (*PageObserveResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PageObserveResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObserveResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePageScrapeResult parses an HTTP response from a PageScrapeWithResponse call
func ParsePageScrapeResult(rsp *http.Response) (*PageScrapeResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PageScrapeResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScrapeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSessionReplayResult parses an HTTP response from a SessionReplayWithResponse call
func ParseSessionReplayResult(rsp *http.Response) (*SessionReplayResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionReplayResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSessionStopResult parses an HTTP response from a SessionStopWithResponse call
func ParseSessionStopResult(rsp *http.Response) (*SessionStopResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SessionStopResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetSessionScriptResult parses an HTTP response from a GetSessionScriptWithResponse call
func ParseGetSessionScriptResult(rsp *http.Response) (*GetSessionScriptResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionScriptResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentFunctionCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFileListUploadsResult parses an HTTP response from a FileListUploadsWithResponse call
func ParseFileListUploadsResult(rsp *http.Response) (*FileListUploadsResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileListUploadsResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFileUploadResult parses an HTTP response from a FileUploadWithResponse call
func ParseFileUploadResult(rsp *http.Response) (*FileUploadResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileUploadResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileUploadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFileListDownloadsResult parses an HTTP response from a FileListDownloadsWithResponse call
func ParseFileListDownloadsResult(rsp *http.Response) (*FileListDownloadsResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileListDownloadsResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFileDownloadResult parses an HTTP response from a FileDownloadWithResponse call
func ParseFileDownloadResult(rsp *http.Response) (*FileDownloadResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileDownloadResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFileUploadDownloadedFileResult parses an HTTP response from a FileUploadDownloadedFileWithResponse call
func ParseFileUploadDownloadedFileResult(rsp *http.Response) (*FileUploadDownloadedFileResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileUploadDownloadedFileResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileUploadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetUsageResult parses an HTTP response from a GetUsageWithResponse call
func ParseGetUsageResult(rsp *http.Response) (*GetUsageResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetUsageLogsResult parses an HTTP response from a GetUsageLogsWithResponse call
func ParseGetUsageLogsResult(rsp *http.Response) (*GetUsageLogsResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageLogsResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseUsageLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListVaultsResult parses an HTTP response from a ListVaultsWithResponse call
func ParseListVaultsResult(rsp *http.Response) (*ListVaultsResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVaultsResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseVault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultCreateResult parses an HTTP response from a VaultCreateWithResponse call
func ParseVaultCreateResult(rsp *http.Response) (*VaultCreateResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultCreateResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultDeleteResult parses an HTTP response from a VaultDeleteWithResponse call
func ParseVaultDeleteResult(rsp *http.Response) (*VaultDeleteResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultDeleteResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteVaultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultCredentialsListResult parses an HTTP response from a VaultCredentialsListWithResponse call
func ParseVaultCredentialsListResult(rsp *http.Response) (*VaultCredentialsListResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultCredentialsListResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCredentialsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultUpdateResult parses an HTTP response from a VaultUpdateWithResponse call
func ParseVaultUpdateResult(rsp *http.Response) (*VaultUpdateResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultUpdateResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultCreditCardDeleteResult parses an HTTP response from a VaultCreditCardDeleteWithResponse call
func ParseVaultCreditCardDeleteResult(rsp *http.Response) (*VaultCreditCardDeleteResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultCreditCardDeleteResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteCreditCardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultCreditCardGetResult parses an HTTP response from a VaultCreditCardGetWithResponse call
func ParseVaultCreditCardGetResult(rsp *http.Response) (*VaultCreditCardGetResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultCreditCardGetResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCreditCardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultCreditCardSetResult parses an HTTP response from a VaultCreditCardSetWithResponse call
func ParseVaultCreditCardSetResult(rsp *http.Response) (*VaultCreditCardSetResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultCreditCardSetResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddCreditCardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultCredentialsDeleteResult parses an HTTP response from a VaultCredentialsDeleteWithResponse call
func ParseVaultCredentialsDeleteResult(rsp *http.Response) (*VaultCredentialsDeleteResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultCredentialsDeleteResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteCredentialsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultCredentialsGetResult parses an HTTP response from a VaultCredentialsGetWithResponse call
func ParseVaultCredentialsGetResult(rsp *http.Response) (*VaultCredentialsGetResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultCredentialsGetResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCredentialsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVaultCredentialsAddResult parses an HTTP response from a VaultCredentialsAddWithResponse call
func ParseVaultCredentialsAddResult(rsp *http.Response) (*VaultCredentialsAddResult, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VaultCredentialsAddResult{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddCredentialsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}
